# file opened: CPM22.asm
   1  0000              ; BLOAD header
   2  0000 FE               db 0x0fe
   3  0001 00 DC 00 F2      dw BEGIN, ENDADR, START_BASIC
   3  0005 00 DC
   4  0007
   5  0007              ;**************************************************************
   6  0007              ;*
   7  0007              ;*             C P / M   version   2 . 2
   8  0007              ;*
   9  0007              ;*   Reconstructed from memory image on February 27, 1981
  10  0007              ;*
  11  0007              ;*                by Clark A. Calkins
  12  0007              ;*
  13  0007              ;**************************************************************
  14  0007              ;
  15  0007              ;   Set memory limit here. This is the amount of contigeous
  16  0007              ; ram starting from 0000. CP/M will reside at the end of this space.
  17  0007              ;
  18  0007              MEM	EQU	62		;for a 62k system (TS802 TEST - WORKS OK).
  19  0007              ;
  20  0007              IOBYTE	EQU	3		;i/o definition byte.
  21  0007              TDRIVE	EQU	4		;current drive name and user number.
  22  0007              ENTRY	EQU	5		;entry point for the cp/m bdos.
  23  0007              TFCB	EQU	5CH		;default file control block.
  24  0007              TBUFF	EQU	80H		;i/o buffer and command line storage.
  25  0007              TBASE	EQU	100H		;transiant program storage area.
  26  0007              ;
  27  0007              ;   Set control character equates.
  28  0007              ;
  29  0007              CNTRLC	EQU	3		;control-c
  30  0007              CNTRLE	EQU	05H		;control-e
  31  0007              BS	EQU	08H		;backspace
  32  0007              TAB	EQU	09H		;tab
  33  0007              LF	EQU	0AH		;line feed
  34  0007              FF	EQU	0CH		;form feed
  35  0007              CR	EQU	0DH		;carriage return
  36  0007              CNTRLP	EQU	10H		;control-p
  37  0007              CNTRLR	EQU	12H		;control-r
  38  0007              CNTRLS	EQU	13H		;control-s
  39  0007              CNTRLU	EQU	15H		;control-u
  40  0007              CNTRLX	EQU	18H		;control-x
  41  0007              CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
  42  0007              DEL	EQU	7FH		;rubout
  43  0007              ;
  44  0007              ;   Set origin for CP/M
  45  0007              ;
  46  0007              	ORG	(MEM-7)*1024
  47  DC00              ;
  48  DC00              BEGIN:
  49  DC00              START_BASIC:
  50  DC00
  51  DC00 C3 5C DF     CBASE:	JP	COMMAND		;execute command processor (ccp).
  52  DC03 C3 58 DF     	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
  53  DC06
  54  DC06              ;
  55  DC06              ;   Standard cp/m ccp input buffer. Format is (max length),
  56  DC06              ; (actual length), (char #1), (char #2), (char #3), etc.
  57  DC06              ;
  58  DC06 7F           INBUFF:	DEFB	127		;length of input buffer.
  59  DC07 00           	DEFB	0		;current length of contents.
  60  DC08 43 6F 70 79  	DEFB	'Copyright'
  60  DC0C 72 69 67 68
  60  DC10 74
  61  DC11 20 31 39 37  	DEFB	' 1979 (c) by Digital Research      '
  61  DC15 39 20 28 63
  61  DC19 29 20 62 79
  61  DC1D 20 44 69 67
  61  DC21 69 74 61 6C
  61  DC25 20 52 65 73
  61  DC29 65 61 72 63
  61  DC2D 68 20 20 20
  61  DC31 20 20 20
  62  DC34 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  62  DC38 00 00 00 00
  62  DC3C 00 00 00 00
  62  DC40 00 00 00 00
  62  DC44 00 00 00 00
  62  DC48 00 00 00
  63  DC4B 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  63  DC4F 00 00 00 00
  63  DC53 00 00 00 00
  63  DC57 00 00 00 00
  63  DC5B 00 00 00 00
  63  DC5F 00 00 00
  64  DC62 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  64  DC66 00 00 00 00
  64  DC6A 00 00 00 00
  64  DC6E 00 00 00 00
  64  DC72 00 00 00 00
  64  DC76 00 00 00
  65  DC79 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  65  DC7D 00 00 00 00
  65  DC81 00 00 00 00
  65  DC85 00 00 00
  66  DC88 08 DC        INPOINT:DEFW	INBUFF+2	;input line pointer
  67  DC8A 00 00        NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
  68  DC8C              ;			;start of name in error.
  69  DC8C              ;
  70  DC8C              ;   Routine to print (A) on the console. All registers used.
  71  DC8C              ;
  72  DC8C 5F           PRINT:	LD	E,A		;setup bdos call.
  73  DC8D 0E 02        	LD	C,2
  74  DC8F C3 05 00     	JP	ENTRY
  75  DC92              ;
  76  DC92              ;   Routine to print (A) on the console and to save (BC).
  77  DC92              ;
  78  DC92 C5           PRINTB:	PUSH	BC
  79  DC93 CD 8C DC     	CALL	PRINT
  80  DC96 C1           	POP	BC
  81  DC97 C9           	RET
  82  DC98              ;
  83  DC98              ;   Routine to send a carriage return, line feed combination
  84  DC98              ; to the console.
  85  DC98              ;
  86  DC98 3E 0D        CRLF:	LD	A,CR
  87  DC9A CD 92 DC     	CALL	PRINTB
  88  DC9D 3E 0A        	LD	A,LF
  89  DC9F C3 92 DC     	JP	PRINTB
  90  DCA2              ;
  91  DCA2              ;   Routine to send one space to the console and save (BC).
  92  DCA2              ;
  93  DCA2 3E 20        SPACE:	LD	A,' '
  94  DCA4 C3 92 DC     	JP	PRINTB
  95  DCA7              ;
  96  DCA7              ;   Routine to print character string pointed to be (BC) on the
  97  DCA7              ; console. It must terminate with a null byte.
  98  DCA7              ;
  99  DCA7 C5           PLINE:	PUSH	BC
 100  DCA8 CD 98 DC     	CALL	CRLF
 101  DCAB E1           	POP	HL
 102  DCAC 7E           PLINE2:	LD	A,(HL)
 103  DCAD B7           	OR	A
 104  DCAE C8           	RET	Z
 105  DCAF 23           	INC	HL
 106  DCB0 E5           	PUSH	HL
 107  DCB1 CD 8C DC     	CALL	PRINT
 108  DCB4 E1           	POP	HL
 109  DCB5 C3 AC DC     	JP	PLINE2
 110  DCB8              ;
 111  DCB8              ;   Routine to reset the disk system.
 112  DCB8              ;
 113  DCB8 0E 0D        RESDSK:	LD	C,13
 114  DCBA C3 05 00     	JP	ENTRY
 115  DCBD              ;
 116  DCBD              ;   Routine to select disk (A).
 117  DCBD              ;
 118  DCBD 5F           DSKSEL:	LD	E,A
 119  DCBE 0E 0E        	LD	C,14
 120  DCC0 C3 05 00     	JP	ENTRY
 121  DCC3              ;
 122  DCC3              ;   Routine to call bdos and save the return code. The zero
 123  DCC3              ; flag is set on a return of 0ffh.
 124  DCC3              ;
 125  DCC3 CD 05 00     ENTRY1:	CALL	ENTRY
 126  DCC6 32 EE E3     	LD	(RTNCODE),A	;save return code.
 127  DCC9 3C           	INC	A		;set zero if 0ffh returned.
 128  DCCA C9           	RET
 129  DCCB              ;
 130  DCCB              ;   Routine to open a file. (DE) must point to the FCB.
 131  DCCB              ;
 132  DCCB 0E 0F        OPEN:	LD	C,15
 133  DCCD C3 C3 DC     	JP	ENTRY1
 134  DCD0              ;
 135  DCD0              ;   Routine to open file at (FCB).
 136  DCD0              ;
 137  DCD0 AF           OPENFCB:XOR	A		;clear the record number byte at fcb+32
 138  DCD1 32 ED E3     	LD	(FCB+32),A
 139  DCD4 11 CD E3     	LD	DE,FCB
 140  DCD7 C3 CB DC     	JP	OPEN
 141  DCDA              ;
 142  DCDA              ;   Routine to close a file. (DE) points to FCB.
 143  DCDA              ;
 144  DCDA 0E 10        CLOSE:	LD	C,16
 145  DCDC C3 C3 DC     	JP	ENTRY1
 146  DCDF              ;
 147  DCDF              ;   Routine to search for the first file with ambigueous name
 148  DCDF              ; (DE).
 149  DCDF              ;
 150  DCDF 0E 11        SRCHFST:LD	C,17
 151  DCE1 C3 C3 DC     	JP	ENTRY1
 152  DCE4              ;
 153  DCE4              ;   Search for the next ambigeous file name.
 154  DCE4              ;
 155  DCE4 0E 12        SRCHNXT:LD	C,18
 156  DCE6 C3 C3 DC     	JP	ENTRY1
 157  DCE9              ;
 158  DCE9              ;   Search for file at (FCB).
 159  DCE9              ;
 160  DCE9 11 CD E3     SRCHFCB:LD	DE,FCB
 161  DCEC C3 DF DC     	JP	SRCHFST
 162  DCEF              ;
 163  DCEF              ;   Routine to delete a file pointed to by (DE).
 164  DCEF              ;
 165  DCEF 0E 13        DELETE:	LD	C,19
 166  DCF1 C3 05 00     	JP	ENTRY
 167  DCF4              ;
 168  DCF4              ;   Routine to call the bdos and set the zero flag if a zero
 169  DCF4              ; status is returned.
 170  DCF4              ;
 171  DCF4 CD 05 00     ENTRY2:	CALL	ENTRY
 172  DCF7 B7           	OR	A		;set zero flag if appropriate.
 173  DCF8 C9           	RET
 174  DCF9              ;
 175  DCF9              ;   Routine to read the next record from a sequential file.
 176  DCF9              ; (DE) points to the FCB.
 177  DCF9              ;
 178  DCF9 0E 14        RDREC:	LD	C,20
 179  DCFB C3 F4 DC     	JP	ENTRY2
 180  DCFE              ;
 181  DCFE              ;   Routine to read file at (FCB).
 182  DCFE              ;
 183  DCFE 11 CD E3     READFCB:LD	DE,FCB
 184  DD01 C3 F9 DC     	JP	RDREC
 185  DD04              ;
 186  DD04              ;   Routine to write the next record of a sequential file.
 187  DD04              ; (DE) points to the FCB.
 188  DD04              ;
 189  DD04 0E 15        WRTREC:	LD	C,21
 190  DD06 C3 F4 DC     	JP	ENTRY2
 191  DD09              ;
 192  DD09              ;   Routine to create the file pointed to by (DE).
 193  DD09              ;
 194  DD09 0E 16        CREATE:	LD	C,22
 195  DD0B C3 C3 DC     	JP	ENTRY1
 196  DD0E              ;
 197  DD0E              ;   Routine to rename the file pointed to by (DE). Note that
 198  DD0E              ; the new name starts at (DE+16).
 199  DD0E              ;
 200  DD0E 0E 17        RENAM:	LD	C,23
 201  DD10 C3 05 00     	JP	ENTRY
 202  DD13              ;
 203  DD13              ;   Get the current user code.
 204  DD13              ;
 205  DD13 1E FF        GETUSR:	LD	E,0FFH
 206  DD15              ;
 207  DD15              ;   Routne to get or set the current user code.
 208  DD15              ; If (E) is FF then this is a GET, else it is a SET.
 209  DD15              ;
 210  DD15 0E 20        GETSETUC: LD	C,32
 211  DD17 C3 05 00     	JP	ENTRY
 212  DD1A              ;
 213  DD1A              ;   Routine to set the current drive byte at (TDRIVE).
 214  DD1A              ;
 215  DD1A CD 13 DD     SETCDRV:CALL	GETUSR		;get user number
 216  DD1D 87           	ADD	A,A		;and shift into the upper 4 bits.
 217  DD1E 87           	ADD	A,A
 218  DD1F 87           	ADD	A,A
 219  DD20 87           	ADD	A,A
 220  DD21 21 EF E3     	LD	HL,CDRIVE	;now add in the current drive number.
 221  DD24 B6           	OR	(HL)
 222  DD25 32 04 00     	LD	(TDRIVE),A	;and save.
 223  DD28 C9           	RET
 224  DD29              ;
 225  DD29              ;   Move currently active drive down to (TDRIVE).
 226  DD29              ;
 227  DD29 3A EF E3     MOVECD:	LD	A,(CDRIVE)
 228  DD2C 32 04 00     	LD	(TDRIVE),A
 229  DD2F C9           	RET
 230  DD30              ;
 231  DD30              ;   Routine to convert (A) into upper case ascii. Only letters
 232  DD30              ; are affected.
 233  DD30              ;
 234  DD30 FE 61        UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
 235  DD32 D8           	RET	C
 236  DD33 FE 7B        	CP	'{'
 237  DD35 D0           	RET	NC
 238  DD36 E6 5F        	AND	5FH		;convert it if found.
 239  DD38 C9           	RET
 240  DD39              ;
 241  DD39              ;   Routine to get a line of input. We must check to see if the
 242  DD39              ; user is in (BATCH) mode. If so, then read the input from file
 243  DD39              ; ($$$.SUB). At the end, reset to console input.
 244  DD39              ;
 245  DD39 3A AB E3     GETINP:	LD	A,(BATCH)	;if =0, then use console input.
 246  DD3C B7           	OR	A
 247  DD3D CA 96 DD     	JP	Z,GETINP1
 248  DD40              ;
 249  DD40              ;   Use the submit file ($$$.sub) which is prepared by a
 250  DD40              ; SUBMIT run. It must be on drive (A) and it will be deleted
 251  DD40              ; if and error occures (like eof).
 252  DD40              ;
 253  DD40 3A EF E3     	LD	A,(CDRIVE)	;select drive 0 if need be.
 254  DD43 B7           	OR	A
 255  DD44 3E 00        	LD	A,0		;always use drive A for submit.
 256  DD46 C4 BD DC     	CALL	NZ,DSKSEL	;select it if required.
 257  DD49 11 AC E3     	LD	DE,BATCHFCB
 258  DD4C CD CB DC     	CALL	OPEN		;look for it.
 259  DD4F CA 96 DD     	JP	Z,GETINP1	;if not there, use normal input.
 260  DD52 3A BB E3     	LD	A,(BATCHFCB+15)	;get last record number+1.
 261  DD55 3D           	DEC	A
 262  DD56 32 CC E3     	LD	(BATCHFCB+32),A
 263  DD59 11 AC E3     	LD	DE,BATCHFCB
 264  DD5C CD F9 DC     	CALL	RDREC		;read last record.
 265  DD5F C2 96 DD     	JP	NZ,GETINP1	;quit on end of file.
 266  DD62              ;
 267  DD62              ;   Move this record into input buffer.
 268  DD62              ;
 269  DD62 11 07 DC     	LD	DE,INBUFF+1
 270  DD65 21 80 00     	LD	HL,TBUFF	;data was read into buffer here.
 271  DD68 06 80        	LD	B,128		;all 128 characters may be used.
 272  DD6A CD 42 E0     	CALL	HL2DE		;(HL) to (DE), (B) bytes.
 273  DD6D 21 BA E3     	LD	HL,BATCHFCB+14
 274  DD70 36 00        	LD	(HL),0		;zero out the 's2' byte.
 275  DD72 23           	INC	HL		;and decrement the record count.
 276  DD73 35           	DEC	(HL)
 277  DD74 11 AC E3     	LD	DE,BATCHFCB	;close the batch file now.
 278  DD77 CD DA DC     	CALL	CLOSE
 279  DD7A CA 96 DD     	JP	Z,GETINP1	;quit on an error.
 280  DD7D 3A EF E3     	LD	A,(CDRIVE)	;re-select previous drive if need be.
 281  DD80 B7           	OR	A
 282  DD81 C4 BD DC     	CALL	NZ,DSKSEL	;don't do needless selects.
 283  DD84              ;
 284  DD84              ;   Print line just read on console.
 285  DD84              ;
 286  DD84 21 08 DC     	LD	HL,INBUFF+2
 287  DD87 CD AC DC     	CALL	PLINE2
 288  DD8A CD C2 DD     	CALL	CHKCON		;check console, quit on a key.
 289  DD8D CA A7 DD     	JP	Z,GETINP2	;jump if no key is pressed.
 290  DD90              ;
 291  DD90              ;   Terminate the submit job on any keyboard input. Delete this
 292  DD90              ; file such that it is not re-started and jump to normal keyboard
 293  DD90              ; input section.
 294  DD90              ;
 295  DD90 CD DD DD     	CALL	DELBATCH	;delete the batch file.
 296  DD93 C3 82 DF     	JP	CMMND1		;and restart command input.
 297  DD96              ;
 298  DD96              ;   Get here for normal keyboard input. Delete the submit file
 299  DD96              ; incase there was one.
 300  DD96              ;
 301  DD96 CD DD DD     GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
 302  DD99 CD 1A DD     	CALL	SETCDRV		;reset active disk.
 303  DD9C 0E 0A        	LD	C,10		;get line from console device.
 304  DD9E 11 06 DC     	LD	DE,INBUFF
 305  DDA1 CD 05 00     	CALL	ENTRY
 306  DDA4 CD 29 DD     	CALL	MOVECD		;reset current drive (again).
 307  DDA7              ;
 308  DDA7              ;   Convert input line to upper case.
 309  DDA7              ;
 310  DDA7 21 07 DC     GETINP2:LD	HL,INBUFF+1
 311  DDAA 46           	LD	B,(HL)		;(B)=character counter.
 312  DDAB 23           GETINP3:INC	HL
 313  DDAC 78           	LD	A,B		;end of the line?
 314  DDAD B7           	OR	A
 315  DDAE CA BA DD     	JP	Z,GETINP4
 316  DDB1 7E           	LD	A,(HL)		;convert to upper case.
 317  DDB2 CD 30 DD     	CALL	UPPER
 318  DDB5 77           	LD	(HL),A
 319  DDB6 05           	DEC	B		;adjust character count.
 320  DDB7 C3 AB DD     	JP	GETINP3
 321  DDBA 77           GETINP4:LD	(HL),A		;add trailing null.
 322  DDBB 21 08 DC     	LD	HL,INBUFF+2
 323  DDBE 22 88 DC     	LD	(INPOINT),HL	;reset input line pointer.
 324  DDC1 C9           	RET
 325  DDC2              ;
 326  DDC2              ;   Routine to check the console for a key pressed. The zero
 327  DDC2              ; flag is set is none, else the character is returned in (A).
 328  DDC2              ;
 329  DDC2 0E 0B        CHKCON:	LD	C,11		;check console.
 330  DDC4 CD 05 00     	CALL	ENTRY
 331  DDC7 B7           	OR	A
 332  DDC8 C8           	RET	Z		;return if nothing.
 333  DDC9 0E 01        	LD	C,1		;else get character.
 334  DDCB CD 05 00     	CALL	ENTRY
 335  DDCE B7           	OR	A		;clear zero flag and return.
 336  DDCF C9           	RET
 337  DDD0              ;
 338  DDD0              ;   Routine to get the currently active drive number.
 339  DDD0              ;
 340  DDD0 0E 19        GETDSK:	LD	C,25
 341  DDD2 C3 05 00     	JP	ENTRY
 342  DDD5              ;
 343  DDD5              ;   Set the stabdard dma address.
 344  DDD5              ;
 345  DDD5 11 80 00     STDDMA:	LD	DE,TBUFF
 346  DDD8              ;
 347  DDD8              ;   Routine to set the dma address to (DE).
 348  DDD8              ;
 349  DDD8 0E 1A        DMASET:	LD	C,26
 350  DDDA C3 05 00     	JP	ENTRY
 351  DDDD              ;
 352  DDDD              ;  Delete the batch file created by SUBMIT.
 353  DDDD              ;
 354  DDDD 21 AB E3     DELBATCH: LD	HL,BATCH	;is batch active?
 355  DDE0 7E           	LD	A,(HL)
 356  DDE1 B7           	OR	A
 357  DDE2 C8           	RET	Z
 358  DDE3 36 00        	LD	(HL),0		;yes, de-activate it.
 359  DDE5 AF           	XOR	A
 360  DDE6 CD BD DC     	CALL	DSKSEL		;select drive 0 for sure.
 361  DDE9 11 AC E3     	LD	DE,BATCHFCB	;and delete this file.
 362  DDEC CD EF DC     	CALL	DELETE
 363  DDEF 3A EF E3     	LD	A,(CDRIVE)	;reset current drive.
 364  DDF2 C3 BD DC     	JP	DSKSEL
 365  DDF5              ;
 366  DDF5              ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
 367  DDF5              ; the same or we halt....
 368  DDF5              ;
 369  DDF5 11 28 DF     VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
 370  DDF8 21 00 E4     	LD	HL,PATTRN2	;ditto, but how could they be different?
 371  DDFB 06 06        	LD	B,6		;6 bytes each.
 372  DDFD 1A           VERIFY1:LD	A,(DE)
 373  DDFE BE           	CP	(HL)
 374  DDFF C2 CF DF     	JP	NZ,HALT		;jump to halt routine.
 375  DE02 13           	INC	DE
 376  DE03 23           	INC	HL
 377  DE04 05           	DEC	B
 378  DE05 C2 FD DD     	JP	NZ,VERIFY1
 379  DE08 C9           	RET
 380  DE09              ;
 381  DE09              ;   Print back file name with a '?' to indicate a syntax error.
 382  DE09              ;
 383  DE09 CD 98 DC     SYNERR:	CALL	CRLF		;end current line.
 384  DE0C 2A 8A DC     	LD	HL,(NAMEPNT)	;this points to name in error.
 385  DE0F 7E           SYNERR1:LD	A,(HL)		;print it until a space or null is found.
 386  DE10 FE 20        	CP	' '
 387  DE12 CA 22 DE     	JP	Z,SYNERR2
 388  DE15 B7           	OR	A
 389  DE16 CA 22 DE     	JP	Z,SYNERR2
 390  DE19 E5           	PUSH	HL
 391  DE1A CD 8C DC     	CALL	PRINT
 392  DE1D E1           	POP	HL
 393  DE1E 23           	INC	HL
 394  DE1F C3 0F DE     	JP	SYNERR1
 395  DE22 3E 3F        SYNERR2:LD	A,'?'		;add trailing '?'.
 396  DE24 CD 8C DC     	CALL	PRINT
 397  DE27 CD 98 DC     	CALL	CRLF
 398  DE2A CD DD DD     	CALL	DELBATCH	;delete any batch file.
 399  DE2D C3 82 DF     	JP	CMMND1		;and restart from console input.
 400  DE30              ;
 401  DE30              ;   Check character at (DE) for legal command input. Note that the
 402  DE30              ; zero flag is set if the character is a delimiter.
 403  DE30              ;
 404  DE30 1A           CHECK:	LD	A,(DE)
 405  DE31 B7           	OR	A
 406  DE32 C8           	RET	Z
 407  DE33 FE 20        	CP	' '		;control characters are not legal here.
 408  DE35 DA 09 DE     	JP	C,SYNERR
 409  DE38 C8           	RET	Z		;check for valid delimiter.
 410  DE39 FE 3D        	CP	'='
 411  DE3B C8           	RET	Z
 412  DE3C FE 5F        	CP	'_'
 413  DE3E C8           	RET	Z
 414  DE3F FE 2E        	CP	'.'
 415  DE41 C8           	RET	Z
 416  DE42 FE 3A        	CP	':'
 417  DE44 C8           	RET	Z
 418  DE45 FE 3B        	CP	';'
 419  DE47 C8           	RET	Z
 420  DE48 FE 3C        	CP	'<'
 421  DE4A C8           	RET	Z
 422  DE4B FE 3E        	CP	'>'
 423  DE4D C8           	RET	Z
 424  DE4E C9           	RET
 425  DE4F              ;
 426  DE4F              ;   Get the next non-blank character from (DE).
 427  DE4F              ;
 428  DE4F 1A           NONBLANK: LD	A,(DE)
 429  DE50 B7           	OR	A		;string ends with a null.
 430  DE51 C8           	RET	Z
 431  DE52 FE 20        	CP	' '
 432  DE54 C0           	RET	NZ
 433  DE55 13           	INC	DE
 434  DE56 C3 4F DE     	JP	NONBLANK
 435  DE59              ;
 436  DE59              ;   Add (HL)=(HL)+(A)
 437  DE59              ;
 438  DE59 85           ADDHL:	ADD	A,L
 439  DE5A 6F           	LD	L,A
 440  DE5B D0           	RET	NC		;take care of any carry.
 441  DE5C 24           	INC	H
 442  DE5D C9           	RET
 443  DE5E              ;
 444  DE5E              ;   Convert the first name in (FCB).
 445  DE5E              ;
 446  DE5E 3E 00        CONVFST:LD	A,0
 447  DE60              ;
 448  DE60              ;   Format a file name (convert * to '?', etc.). On return,
 449  DE60              ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
 450  DE60              ; the position within the fcb for the name (either 0 or 16).
 451  DE60              ;
 452  DE60 21 CD E3     CONVERT:LD	HL,FCB
 453  DE63 CD 59 DE     	CALL	ADDHL
 454  DE66 E5           	PUSH	HL
 455  DE67 E5           	PUSH	HL
 456  DE68 AF           	XOR	A
 457  DE69 32 F0 E3     	LD	(CHGDRV),A	;initialize drive change flag.
 458  DE6C 2A 88 DC     	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
 459  DE6F EB           	EX	DE,HL
 460  DE70 CD 4F DE     	CALL	NONBLANK	;get next non-blank character.
 461  DE73 EB           	EX	DE,HL
 462  DE74 22 8A DC     	LD	(NAMEPNT),HL	;save pointer here for any error message.
 463  DE77 EB           	EX	DE,HL
 464  DE78 E1           	POP	HL
 465  DE79 1A           	LD	A,(DE)		;get first character.
 466  DE7A B7           	OR	A
 467  DE7B CA 89 DE     	JP	Z,CONVRT1
 468  DE7E DE 40        	SBC	A,'A'-1		;might be a drive name, convert to binary.
 469  DE80 47           	LD	B,A		;and save.
 470  DE81 13           	INC	DE		;check next character for a ':'.
 471  DE82 1A           	LD	A,(DE)
 472  DE83 FE 3A        	CP	':'
 473  DE85 CA 90 DE     	JP	Z,CONVRT2
 474  DE88 1B           	DEC	DE		;nope, move pointer back to the start of the line.
 475  DE89 3A EF E3     CONVRT1:LD	A,(CDRIVE)
 476  DE8C 77           	LD	(HL),A
 477  DE8D C3 96 DE     	JP	CONVRT3
 478  DE90 78           CONVRT2:LD	A,B
 479  DE91 32 F0 E3     	LD	(CHGDRV),A	;set change in drives flag.
 480  DE94 70           	LD	(HL),B
 481  DE95 13           	INC	DE
 482  DE96              ;
 483  DE96              ;   Convert the basic file name.
 484  DE96              ;
 485  DE96 06 08        CONVRT3:LD	B,08H
 486  DE98 CD 30 DE     CONVRT4:CALL	CHECK
 487  DE9B CA B9 DE     	JP	Z,CONVRT8
 488  DE9E 23           	INC	HL
 489  DE9F FE 2A        	CP	'*'		;note that an '*' will fill the remaining
 490  DEA1 C2 A9 DE     	JP	NZ,CONVRT5	;field with '?'.
 491  DEA4 36 3F        	LD	(HL),'?'
 492  DEA6 C3 AB DE     	JP	CONVRT6
 493  DEA9 77           CONVRT5:LD	(HL),A
 494  DEAA 13           	INC	DE
 495  DEAB 05           CONVRT6:DEC	B
 496  DEAC C2 98 DE     	JP	NZ,CONVRT4
 497  DEAF CD 30 DE     CONVRT7:CALL	CHECK		;get next delimiter.
 498  DEB2 CA C0 DE     	JP	Z,GETEXT
 499  DEB5 13           	INC	DE
 500  DEB6 C3 AF DE     	JP	CONVRT7
 501  DEB9 23           CONVRT8:INC	HL		;blank fill the file name.
 502  DEBA 36 20        	LD	(HL),' '
 503  DEBC 05           	DEC	B
 504  DEBD C2 B9 DE     	JP	NZ,CONVRT8
 505  DEC0              ;
 506  DEC0              ;   Get the extension and convert it.
 507  DEC0              ;
 508  DEC0 06 03        GETEXT:	LD	B,03H
 509  DEC2 FE 2E        	CP	'.'
 510  DEC4 C2 E9 DE     	JP	NZ,GETEXT5
 511  DEC7 13           	INC	DE
 512  DEC8 CD 30 DE     GETEXT1:CALL	CHECK
 513  DECB CA E9 DE     	JP	Z,GETEXT5
 514  DECE 23           	INC	HL
 515  DECF FE 2A        	CP	'*'
 516  DED1 C2 D9 DE     	JP	NZ,GETEXT2
 517  DED4 36 3F        	LD	(HL),'?'
 518  DED6 C3 DB DE     	JP	GETEXT3
 519  DED9 77           GETEXT2:LD	(HL),A
 520  DEDA 13           	INC	DE
 521  DEDB 05           GETEXT3:DEC	B
 522  DEDC C2 C8 DE     	JP	NZ,GETEXT1
 523  DEDF CD 30 DE     GETEXT4:CALL	CHECK
 524  DEE2 CA F0 DE     	JP	Z,GETEXT6
 525  DEE5 13           	INC	DE
 526  DEE6 C3 DF DE     	JP	GETEXT4
 527  DEE9 23           GETEXT5:INC	HL
 528  DEEA 36 20        	LD	(HL),' '
 529  DEEC 05           	DEC	B
 530  DEED C2 E9 DE     	JP	NZ,GETEXT5
 531  DEF0 06 03        GETEXT6:LD	B,3
 532  DEF2 23           GETEXT7:INC	HL
 533  DEF3 36 00        	LD	(HL),0
 534  DEF5 05           	DEC	B
 535  DEF6 C2 F2 DE     	JP	NZ,GETEXT7
 536  DEF9 EB           	EX	DE,HL
 537  DEFA 22 88 DC     	LD	(INPOINT),HL	;save input line pointer.
 538  DEFD E1           	POP	HL
 539  DEFE              ;
 540  DEFE              ;   Check to see if this is an ambigeous file name specification.
 541  DEFE              ; Set the (A) register to non zero if it is.
 542  DEFE              ;
 543  DEFE 01 0B 00     	LD	BC,11		;set name length.
 544  DF01 23           GETEXT8:INC	HL
 545  DF02 7E           	LD	A,(HL)
 546  DF03 FE 3F        	CP	'?'		;any question marks?
 547  DF05 C2 09 DF     	JP	NZ,GETEXT9
 548  DF08 04           	INC	B		;count them.
 549  DF09 0D           GETEXT9:DEC	C
 550  DF0A C2 01 DF     	JP	NZ,GETEXT8
 551  DF0D 78           	LD	A,B
 552  DF0E B7           	OR	A
 553  DF0F C9           	RET
 554  DF10              ;
 555  DF10              ;   CP/M command table. Note commands can be either 3 or 4 characters long.
 556  DF10              ;
 557  DF10              NUMCMDS EQU	6		;number of commands
 558  DF10 44 49 52 20  CMDTBL:	DEFB	'DIR '
 559  DF14 45 52 41 20  	DEFB	'ERA '
 560  DF18 54 59 50 45  	DEFB	'TYPE'
 561  DF1C 53 41 56 45  	DEFB	'SAVE'
 562  DF20 52 45 4E 20  	DEFB	'REN '
 563  DF24 55 53 45 52  	DEFB	'USER'
 564  DF28              ;
 565  DF28              ;   The following six bytes must agree with those at (PATTRN2)
 566  DF28              ; or cp/m will HALT. Why?
 567  DF28              ;
 568  DF28 00 16 00 00  PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
 568  DF2C 00 00
 569  DF2E              ;
 570  DF2E              ;   Search the command table for a match with what has just
 571  DF2E              ; been entered. If a match is found, then we jump to the
 572  DF2E              ; proper section. Else jump to (UNKNOWN).
 573  DF2E              ; On return, the (C) register is set to the command number
 574  DF2E              ; that matched (or NUMCMDS+1 if no match).
 575  DF2E              ;
 576  DF2E 21 10 DF     SEARCH:	LD	HL,CMDTBL
 577  DF31 0E 00        	LD	C,0
 578  DF33 79           SEARCH1:LD	A,C
 579  DF34 FE 06        	CP	NUMCMDS		;this commands exists.
 580  DF36 D0           	RET	NC
 581  DF37 11 CE E3     	LD	DE,FCB+1	;check this one.
 582  DF3A 06 04        	LD	B,4		;max command length.
 583  DF3C 1A           SEARCH2:LD	A,(DE)
 584  DF3D BE           	CP	(HL)
 585  DF3E C2 4F DF     	JP	NZ,SEARCH3	;not a match.
 586  DF41 13           	INC	DE
 587  DF42 23           	INC	HL
 588  DF43 05           	DEC	B
 589  DF44 C2 3C DF     	JP	NZ,SEARCH2
 590  DF47 1A           	LD	A,(DE)		;allow a 3 character command to match.
 591  DF48 FE 20        	CP	' '
 592  DF4A C2 54 DF     	JP	NZ,SEARCH4
 593  DF4D 79           	LD	A,C		;set return register for this command.
 594  DF4E C9           	RET
 595  DF4F 23           SEARCH3:INC	HL
 596  DF50 05           	DEC	B
 597  DF51 C2 4F DF     	JP	NZ,SEARCH3
 598  DF54 0C           SEARCH4:INC	C
 599  DF55 C3 33 DF     	JP	SEARCH1
 600  DF58              ;
 601  DF58              ;   Set the input buffer to empty and then start the command
 602  DF58              ; processor (ccp).
 603  DF58              ;
 604  DF58 AF           CLEARBUF: XOR	A
 605  DF59 32 07 DC     	LD	(INBUFF+1),A	;second byte is actual length.
 606  DF5C              ;
 607  DF5C              ;**************************************************************
 608  DF5C              ;*
 609  DF5C              ;*
 610  DF5C              ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
 611  DF5C              ;*
 612  DF5C              ;**************************************************************
 613  DF5C              ;*
 614  DF5C 31 AB E3     COMMAND:LD	SP,CCPSTACK	;setup stack area.
 615  DF5F C5           	PUSH	BC		;note that (C) should be equal to:
 616  DF60 79           	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
 617  DF61 1F           	RRA			;and 'dddd' is the drive number.
 618  DF62 1F           	RRA
 619  DF63 1F           	RRA
 620  DF64 1F           	RRA
 621  DF65 E6 0F        	AND	0FH		;isolate the user number.
 622  DF67 5F           	LD	E,A
 623  DF68 CD 15 DD     	CALL	GETSETUC	;and set it.
 624  DF6B CD B8 DC     	CALL	RESDSK		;reset the disk system.
 625  DF6E 32 AB E3     	LD	(BATCH),A	;clear batch mode flag.
 626  DF71 C1           	POP	BC
 627  DF72 79           	LD	A,C
 628  DF73 E6 0F        	AND	0FH		;isolate the drive number.
 629  DF75 32 EF E3     	LD	(CDRIVE),A	;and save.
 630  DF78 CD BD DC     	CALL	DSKSEL		;...and select.
 631  DF7B 3A 07 DC     	LD	A,(INBUFF+1)
 632  DF7E B7           	OR	A		;anything in input buffer already?
 633  DF7F C2 98 DF     	JP	NZ,CMMND2	;yes, we just process it.
 634  DF82              ;
 635  DF82              ;   Entry point to get a command line from the console.
 636  DF82              ;
 637  DF82 31 AB E3     CMMND1:	LD	SP,CCPSTACK	;set stack straight.
 638  DF85 CD 98 DC     	CALL	CRLF		;start a new line on the screen.
 639  DF88 CD D0 DD     	CALL	GETDSK		;get current drive.
 640  DF8B C6 61        	ADD	A,'a'
 641  DF8D CD 8C DC     	CALL	PRINT		;print current drive.
 642  DF90 3E 3E        	LD	A,'>'
 643  DF92 CD 8C DC     	CALL	PRINT		;and add prompt.
 644  DF95 CD 39 DD     	CALL	GETINP		;get line from user.
 645  DF98              ;
 646  DF98              ;   Process command line here.
 647  DF98              ;
 648  DF98 11 80 00     CMMND2:	LD	DE,TBUFF
 649  DF9B CD D8 DD     	CALL	DMASET		;set standard dma address.
 650  DF9E CD D0 DD     	CALL	GETDSK
 651  DFA1 32 EF E3     	LD	(CDRIVE),A	;set current drive.
 652  DFA4 CD 5E DE     	CALL	CONVFST		;convert name typed in.
 653  DFA7 C4 09 DE     	CALL	NZ,SYNERR	;wild cards are not allowed.
 654  DFAA 3A F0 E3     	LD	A,(CHGDRV)	;if a change in drives was indicated,
 655  DFAD B7           	OR	A		;then treat this as an unknown command
 656  DFAE C2 A5 E2     	JP	NZ,UNKNOWN	;which gets executed.
 657  DFB1 CD 2E DF     	CALL	SEARCH		;else search command table for a match.
 658  DFB4              ;
 659  DFB4              ;   Note that an unknown command returns
 660  DFB4              ; with (A) pointing to the last address
 661  DFB4              ; in our table which is (UNKNOWN).
 662  DFB4              ;
 663  DFB4 21 C1 DF     	LD	HL,CMDADR	;now, look thru our address table for command (A).
 664  DFB7 5F           	LD	E,A		;set (DE) to command number.
 665  DFB8 16 00        	LD	D,0
 666  DFBA 19           	ADD	HL,DE
 667  DFBB 19           	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
 668  DFBC 7E           	LD	A,(HL)		;now pick out this address.
 669  DFBD 23           	INC	HL
 670  DFBE 66           	LD	H,(HL)
 671  DFBF 6F           	LD	L,A
 672  DFC0 E9           	JP	(HL)		;now execute it.
 673  DFC1              ;
 674  DFC1              ;   CP/M command address table.
 675  DFC1              ;
 676  DFC1 77 E0 1F E1  CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
 676  DFC5 5D E1 AD E1
 677  DFC9 10 E2 8E E2  	DEFW	RENAME,USER,UNKNOWN
 677  DFCD A5 E2
 678  DFCF              ;
 679  DFCF              ;   Halt the system. Reason for this is unknown at present.
 680  DFCF              ;
 681  DFCF 21 F3 76     HALT:	LD	HL,76F3H	;'DI HLT' instructions.
 682  DFD2 22 00 DC     	LD	(CBASE),HL
 683  DFD5 21 00 DC     	LD	HL,CBASE
 684  DFD8 E9           	JP	(HL)
 685  DFD9              ;
 686  DFD9              ;   Read error while TYPEing a file.
 687  DFD9              ;
 688  DFD9 01 DF DF     RDERROR:LD	BC,RDERR
 689  DFDC C3 A7 DC     	JP	PLINE
 690  DFDF 52 65 61 64  RDERR:	DEFB	'Read error',0
 690  DFE3 20 65 72 72
 690  DFE7 6F 72 00
 691  DFEA              ;
 692  DFEA              ;   Required file was not located.
 693  DFEA              ;
 694  DFEA 01 F0 DF     NONE:	LD	BC,NOFILE
 695  DFED C3 A7 DC     	JP	PLINE
 696  DFF0 4E 6F 20 66  NOFILE:	DEFB	'No file',0
 696  DFF4 69 6C 65 00
 697  DFF8              ;
 698  DFF8              ;   Decode a command of the form 'A>filename number{ filename}.
 699  DFF8              ; Note that a drive specifier is not allowed on the first file
 700  DFF8              ; name. On return, the number is in register (A). Any error
 701  DFF8              ; causes 'filename?' to be printed and the command is aborted.
 702  DFF8              ;
 703  DFF8 CD 5E DE     DECODE:	CALL	CONVFST		;convert filename.
 704  DFFB 3A F0 E3     	LD	A,(CHGDRV)	;do not allow a drive to be specified.
 705  DFFE B7           	OR	A
 706  DFFF C2 09 DE     	JP	NZ,SYNERR
 707  E002 21 CE E3     	LD	HL,FCB+1	;convert number now.
 708  E005 01 0B 00     	LD	BC,11		;(B)=sum register, (C)=max digit count.
 709  E008 7E           DECODE1:LD	A,(HL)
 710  E009 FE 20        	CP	' '		;a space terminates the numeral.
 711  E00B CA 33 E0     	JP	Z,DECODE3
 712  E00E 23           	INC	HL
 713  E00F D6 30        	SUB	'0'		;make binary from ascii.
 714  E011 FE 0A        	CP	10		;legal digit?
 715  E013 D2 09 DE     	JP	NC,SYNERR
 716  E016 57           	LD	D,A		;yes, save it in (D).
 717  E017 78           	LD	A,B		;compute (B)=(B)*10 and check for overflow.
 718  E018 E6 E0        	AND	0E0H
 719  E01A C2 09 DE     	JP	NZ,SYNERR
 720  E01D 78           	LD	A,B
 721  E01E 07           	RLCA
 722  E01F 07           	RLCA
 723  E020 07           	RLCA			;(A)=(B)*8
 724  E021 80           	ADD	A,B		;.......*9
 725  E022 DA 09 DE     	JP	C,SYNERR
 726  E025 80           	ADD	A,B		;.......*10
 727  E026 DA 09 DE     	JP	C,SYNERR
 728  E029 82           	ADD	A,D		;add in new digit now.
 729  E02A DA 09 DE     DECODE2:JP	C,SYNERR
 730  E02D 47           	LD	B,A		;and save result.
 731  E02E 0D           	DEC	C		;only look at 11 digits.
 732  E02F C2 08 E0     	JP	NZ,DECODE1
 733  E032 C9           	RET
 734  E033 7E           DECODE3:LD	A,(HL)		;spaces must follow (why?).
 735  E034 FE 20        	CP	' '
 736  E036 C2 09 DE     	JP	NZ,SYNERR
 737  E039 23           	INC	HL
 738  E03A 0D           DECODE4:DEC	C
 739  E03B C2 33 E0     	JP	NZ,DECODE3
 740  E03E 78           	LD	A,B		;set (A)=the numeric value entered.
 741  E03F C9           	RET
 742  E040              ;
 743  E040              ;   Move 3 bytes from (HL) to (DE). Note that there is only
 744  E040              ; one reference to this at (A2D5h).
 745  E040              ;
 746  E040 06 03        MOVE3:	LD	B,3
 747  E042              ;
 748  E042              ;   Move (B) bytes from (HL) to (DE).
 749  E042              ;
 750  E042 7E           HL2DE:	LD	A,(HL)
 751  E043 12           	LD	(DE),A
 752  E044 23           	INC	HL
 753  E045 13           	INC	DE
 754  E046 05           	DEC	B
 755  E047 C2 42 E0     	JP	NZ,HL2DE
 756  E04A C9           	RET
 757  E04B              ;
 758  E04B              ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
 759  E04B              ;
 760  E04B 21 80 00     EXTRACT:LD	HL,TBUFF
 761  E04E 81           	ADD	A,C
 762  E04F CD 59 DE     	CALL	ADDHL
 763  E052 7E           	LD	A,(HL)
 764  E053 C9           	RET
 765  E054              ;
 766  E054              ;  Check drive specified. If it means a change, then the new
 767  E054              ; drive will be selected. In any case, the drive byte of the
 768  E054              ; fcb will be set to null (means use current drive).
 769  E054              ;
 770  E054 AF           DSELECT:XOR	A		;null out first byte of fcb.
 771  E055 32 CD E3     	LD	(FCB),A
 772  E058 3A F0 E3     	LD	A,(CHGDRV)	;a drive change indicated?
 773  E05B B7           	OR	A
 774  E05C C8           	RET	Z
 775  E05D 3D           	DEC	A		;yes, is it the same as the current drive?
 776  E05E 21 EF E3     	LD	HL,CDRIVE
 777  E061 BE           	CP	(HL)
 778  E062 C8           	RET	Z
 779  E063 C3 BD DC     	JP	DSKSEL		;no. Select it then.
 780  E066              ;
 781  E066              ;   Check the drive selection and reset it to the previous
 782  E066              ; drive if it was changed for the preceeding command.
 783  E066              ;
 784  E066 3A F0 E3     RESETDR:LD	A,(CHGDRV)	;drive change indicated?
 785  E069 B7           	OR	A
 786  E06A C8           	RET	Z
 787  E06B 3D           	DEC	A		;yes, was it a different drive?
 788  E06C 21 EF E3     	LD	HL,CDRIVE
 789  E06F BE           	CP	(HL)
 790  E070 C8           	RET	Z
 791  E071 3A EF E3     	LD	A,(CDRIVE)	;yes, re-select our old drive.
 792  E074 C3 BD DC     	JP	DSKSEL
 793  E077              ;
 794  E077              ;**************************************************************
 795  E077              ;*
 796  E077              ;*           D I R E C T O R Y   C O M M A N D
 797  E077              ;*
 798  E077              ;**************************************************************
 799  E077              ;
 800  E077 CD 5E DE     DIRECT:	CALL	CONVFST		;convert file name.
 801  E07A CD 54 E0     	CALL	DSELECT		;select indicated drive.
 802  E07D 21 CE E3     	LD	HL,FCB+1	;was any file indicated?
 803  E080 7E           	LD	A,(HL)
 804  E081 FE 20        	CP	' '
 805  E083 C2 8F E0     	JP	NZ,DIRECT2
 806  E086 06 0B        	LD	B,11		;no. Fill field with '?' - same as *.*.
 807  E088 36 3F        DIRECT1:LD	(HL),'?'
 808  E08A 23           	INC	HL
 809  E08B 05           	DEC	B
 810  E08C C2 88 E0     	JP	NZ,DIRECT1
 811  E08F 1E 00        DIRECT2:LD	E,0		;set initial cursor position.
 812  E091 D5           	PUSH	DE
 813  E092 CD E9 DC     	CALL	SRCHFCB		;get first file name.
 814  E095 CC EA DF     	CALL	Z,NONE		;none found at all?
 815  E098 CA 1B E1     DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
 816  E09B 3A EE E3     	LD	A,(RTNCODE)	;get file's position in segment (0-3).
 817  E09E 0F           	RRCA
 818  E09F 0F           	RRCA
 819  E0A0 0F           	RRCA
 820  E0A1 E6 60        	AND	60H		;(A)=position*32
 821  E0A3 4F           	LD	C,A
 822  E0A4 3E 0A        	LD	A,10
 823  E0A6 CD 4B E0     	CALL	EXTRACT		;extract the tenth entry in fcb.
 824  E0A9 17           	RLA			;check system file status bit.
 825  E0AA DA 0F E1     	JP	C,DIRECT8	;we don't list them.
 826  E0AD D1           	POP	DE
 827  E0AE 7B           	LD	A,E		;bump name count.
 828  E0AF 1C           	INC	E
 829  E0B0 D5           	PUSH	DE
 830  E0B1 E6 03        	AND	03H		;at end of line?
 831  E0B3 F5           	PUSH	AF
 832  E0B4 C2 CC E0     	JP	NZ,DIRECT4
 833  E0B7 CD 98 DC     	CALL	CRLF		;yes, end this line and start another.
 834  E0BA C5           	PUSH	BC
 835  E0BB CD D0 DD     	CALL	GETDSK		;start line with ('A:').
 836  E0BE C1           	POP	BC
 837  E0BF C6 41        	ADD	A,'A'
 838  E0C1 CD 92 DC     	CALL	PRINTB
 839  E0C4 3E 3A        	LD	A,':'
 840  E0C6 CD 92 DC     	CALL	PRINTB
 841  E0C9 C3 D4 E0     	JP	DIRECT5
 842  E0CC CD A2 DC     DIRECT4:CALL	SPACE		;add seperator between file names.
 843  E0CF 3E 3A        	LD	A,':'
 844  E0D1 CD 92 DC     	CALL	PRINTB
 845  E0D4 CD A2 DC     DIRECT5:CALL	SPACE
 846  E0D7 06 01        	LD	B,1		;'extract' each file name character at a time.
 847  E0D9 78           DIRECT6:LD	A,B
 848  E0DA CD 4B E0     	CALL	EXTRACT
 849  E0DD E6 7F        	AND	7FH		;strip bit 7 (status bit).
 850  E0DF FE 20        	CP	' '		;are we at the end of the name?
 851  E0E1 C2 F9 E0     	JP	NZ,DRECT65
 852  E0E4 F1           	POP	AF		;yes, don't print spaces at the end of a line.
 853  E0E5 F5           	PUSH	AF
 854  E0E6 FE 03        	CP	3
 855  E0E8 C2 F7 E0     	JP	NZ,DRECT63
 856  E0EB 3E 09        	LD	A,9		;first check for no extension.
 857  E0ED CD 4B E0     	CALL	EXTRACT
 858  E0F0 E6 7F        	AND	7FH
 859  E0F2 FE 20        	CP	' '
 860  E0F4 CA 0E E1     	JP	Z,DIRECT7	;don't print spaces.
 861  E0F7 3E 20        DRECT63:LD	A,' '		;else print them.
 862  E0F9 CD 92 DC     DRECT65:CALL	PRINTB
 863  E0FC 04           	INC	B		;bump to next character psoition.
 864  E0FD 78           	LD	A,B
 865  E0FE FE 0C        	CP	12		;end of the name?
 866  E100 D2 0E E1     	JP	NC,DIRECT7
 867  E103 FE 09        	CP	9		;nope, starting extension?
 868  E105 C2 D9 E0     	JP	NZ,DIRECT6
 869  E108 CD A2 DC     	CALL	SPACE		;yes, add seperating space.
 870  E10B C3 D9 E0     	JP	DIRECT6
 871  E10E F1           DIRECT7:POP	AF		;get the next file name.
 872  E10F CD C2 DD     DIRECT8:CALL	CHKCON		;first check console, quit on anything.
 873  E112 C2 1B E1     	JP	NZ,DIRECT9
 874  E115 CD E4 DC     	CALL	SRCHNXT		;get next name.
 875  E118 C3 98 E0     	JP	DIRECT3		;and continue with our list.
 876  E11B D1           DIRECT9:POP	DE		;restore the stack and return to command level.
 877  E11C C3 86 E3     	JP	GETBACK
 878  E11F              ;
 879  E11F              ;**************************************************************
 880  E11F              ;*
 881  E11F              ;*                E R A S E   C O M M A N D
 882  E11F              ;*
 883  E11F              ;**************************************************************
 884  E11F              ;
 885  E11F CD 5E DE     ERASE:	CALL	CONVFST		;convert file name.
 886  E122 FE 0B        	CP	11		;was '*.*' entered?
 887  E124 C2 42 E1     	JP	NZ,ERASE1
 888  E127 01 52 E1     	LD	BC,YESNO	;yes, ask for confirmation.
 889  E12A CD A7 DC     	CALL	PLINE
 890  E12D CD 39 DD     	CALL	GETINP
 891  E130 21 07 DC     	LD	HL,INBUFF+1
 892  E133 35           	DEC	(HL)		;must be exactly 'y'.
 893  E134 C2 82 DF     	JP	NZ,CMMND1
 894  E137 23           	INC	HL
 895  E138 7E           	LD	A,(HL)
 896  E139 FE 59        	CP	'Y'
 897  E13B C2 82 DF     	JP	NZ,CMMND1
 898  E13E 23           	INC	HL
 899  E13F 22 88 DC     	LD	(INPOINT),HL	;save input line pointer.
 900  E142 CD 54 E0     ERASE1:	CALL	DSELECT		;select desired disk.
 901  E145 11 CD E3     	LD	DE,FCB
 902  E148 CD EF DC     	CALL	DELETE		;delete the file.
 903  E14B 3C           	INC	A
 904  E14C CC EA DF     	CALL	Z,NONE		;not there?
 905  E14F C3 86 E3     	JP	GETBACK		;return to command level now.
 906  E152 41 6C 6C 20  YESNO:	DEFB	'All (y/n)?',0
 906  E156 28 79 2F 6E
 906  E15A 29 3F 00
 907  E15D              ;
 908  E15D              ;**************************************************************
 909  E15D              ;*
 910  E15D              ;*            T Y P E   C O M M A N D
 911  E15D              ;*
 912  E15D              ;**************************************************************
 913  E15D              ;
 914  E15D CD 5E DE     TYPE:	CALL	CONVFST		;convert file name.
 915  E160 C2 09 DE     	JP	NZ,SYNERR	;wild cards not allowed.
 916  E163 CD 54 E0     	CALL	DSELECT		;select indicated drive.
 917  E166 CD D0 DC     	CALL	OPENFCB		;open the file.
 918  E169 CA A7 E1     	JP	Z,TYPE5		;not there?
 919  E16C CD 98 DC     	CALL	CRLF		;ok, start a new line on the screen.
 920  E16F 21 F1 E3     	LD	HL,NBYTES	;initialize byte counter.
 921  E172 36 FF        	LD	(HL),0FFH	;set to read first sector.
 922  E174 21 F1 E3     TYPE1:	LD	HL,NBYTES
 923  E177 7E           TYPE2:	LD	A,(HL)		;have we written the entire sector?
 924  E178 FE 80        	CP	128
 925  E17A DA 87 E1     	JP	C,TYPE3
 926  E17D E5           	PUSH	HL		;yes, read in the next one.
 927  E17E CD FE DC     	CALL	READFCB
 928  E181 E1           	POP	HL
 929  E182 C2 A0 E1     	JP	NZ,TYPE4	;end or error?
 930  E185 AF           	XOR	A		;ok, clear byte counter.
 931  E186 77           	LD	(HL),A
 932  E187 34           TYPE3:	INC	(HL)		;count this byte.
 933  E188 21 80 00     	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
 934  E18B CD 59 DE     	CALL	ADDHL
 935  E18E 7E           	LD	A,(HL)
 936  E18F FE 1A        	CP	CNTRLZ		;end of file mark?
 937  E191 CA 86 E3     	JP	Z,GETBACK
 938  E194 CD 8C DC     	CALL	PRINT		;no, print it.
 939  E197 CD C2 DD     	CALL	CHKCON		;check console, quit if anything ready.
 940  E19A C2 86 E3     	JP	NZ,GETBACK
 941  E19D C3 74 E1     	JP	TYPE1
 942  E1A0              ;
 943  E1A0              ;   Get here on an end of file or read error.
 944  E1A0              ;
 945  E1A0 3D           TYPE4:	DEC	A		;read error?
 946  E1A1 CA 86 E3     	JP	Z,GETBACK
 947  E1A4 CD D9 DF     	CALL	RDERROR		;yes, print message.
 948  E1A7 CD 66 E0     TYPE5:	CALL	RESETDR		;and reset proper drive
 949  E1AA C3 09 DE     	JP	SYNERR		;now print file name with problem.
 950  E1AD              ;
 951  E1AD              ;**************************************************************
 952  E1AD              ;*
 953  E1AD              ;*            S A V E   C O M M A N D
 954  E1AD              ;*
 955  E1AD              ;**************************************************************
 956  E1AD              ;
 957  E1AD CD F8 DF     SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
 958  E1B0 F5           	PUSH	AF		;save number of pages to write.
 959  E1B1 CD 5E DE     	CALL	CONVFST		;convert file name.
 960  E1B4 C2 09 DE     	JP	NZ,SYNERR	;wild cards not allowed.
 961  E1B7 CD 54 E0     	CALL	DSELECT		;select specified drive.
 962  E1BA 11 CD E3     	LD	DE,FCB		;now delete this file.
 963  E1BD D5           	PUSH	DE
 964  E1BE CD EF DC     	CALL	DELETE
 965  E1C1 D1           	POP	DE
 966  E1C2 CD 09 DD     	CALL	CREATE		;and create it again.
 967  E1C5 CA FB E1     	JP	Z,SAVE3		;can't create?
 968  E1C8 AF           	XOR	A		;clear record number byte.
 969  E1C9 32 ED E3     	LD	(FCB+32),A
 970  E1CC F1           	POP	AF		;convert pages to sectors.
 971  E1CD 6F           	LD	L,A
 972  E1CE 26 00        	LD	H,0
 973  E1D0 29           	ADD	HL,HL		;(HL)=number of sectors to write.
 974  E1D1 11 00 01     	LD	DE,TBASE	;and we start from here.
 975  E1D4 7C           SAVE1:	LD	A,H		;done yet?
 976  E1D5 B5           	OR	L
 977  E1D6 CA F1 E1     	JP	Z,SAVE2
 978  E1D9 2B           	DEC	HL		;nope, count this and compute the start
 979  E1DA E5           	PUSH	HL		;of the next 128 byte sector.
 980  E1DB 21 80 00     	LD	HL,128
 981  E1DE 19           	ADD	HL,DE
 982  E1DF E5           	PUSH	HL		;save it and set the transfer address.
 983  E1E0 CD D8 DD     	CALL	DMASET
 984  E1E3 11 CD E3     	LD	DE,FCB		;write out this sector now.
 985  E1E6 CD 04 DD     	CALL	WRTREC
 986  E1E9 D1           	POP	DE		;reset (DE) to the start of the last sector.
 987  E1EA E1           	POP	HL		;restore sector count.
 988  E1EB C2 FB E1     	JP	NZ,SAVE3	;write error?
 989  E1EE C3 D4 E1     	JP	SAVE1
 990  E1F1              ;
 991  E1F1              ;   Get here after writing all of the file.
 992  E1F1              ;
 993  E1F1 11 CD E3     SAVE2:	LD	DE,FCB		;now close the file.
 994  E1F4 CD DA DC     	CALL	CLOSE
 995  E1F7 3C           	INC	A		;did it close ok?
 996  E1F8 C2 01 E2     	JP	NZ,SAVE4
 997  E1FB              ;
 998  E1FB              ;   Print out error message (no space).
 999  E1FB              ;
1000  E1FB 01 07 E2     SAVE3:	LD	BC,NOSPACE
1001  E1FE CD A7 DC     	CALL	PLINE
1002  E201 CD D5 DD     SAVE4:	CALL	STDDMA		;reset the standard dma address.
1003  E204 C3 86 E3     	JP	GETBACK
1004  E207 4E 6F 20 73  NOSPACE:DEFB	'No space',0
1004  E20B 70 61 63 65
1004  E20F 00
1005  E210              ;
1006  E210              ;**************************************************************
1007  E210              ;*
1008  E210              ;*           R E N A M E   C O M M A N D
1009  E210              ;*
1010  E210              ;**************************************************************
1011  E210              ;
1012  E210 CD 5E DE     RENAME:	CALL	CONVFST		;convert first file name.
1013  E213 C2 09 DE     	JP	NZ,SYNERR	;wild cards not allowed.
1014  E216 3A F0 E3     	LD	A,(CHGDRV)	;remember any change in drives specified.
1015  E219 F5           	PUSH	AF
1016  E21A CD 54 E0     	CALL	DSELECT		;and select this drive.
1017  E21D CD E9 DC     	CALL	SRCHFCB		;is this file present?
1018  E220 C2 79 E2     	JP	NZ,RENAME6	;yes, print error message.
1019  E223 21 CD E3     	LD	HL,FCB		;yes, move this name into second slot.
1020  E226 11 DD E3     	LD	DE,FCB+16
1021  E229 06 10        	LD	B,16
1022  E22B CD 42 E0     	CALL	HL2DE
1023  E22E 2A 88 DC     	LD	HL,(INPOINT)	;get input pointer.
1024  E231 EB           	EX	DE,HL
1025  E232 CD 4F DE     	CALL	NONBLANK	;get next non blank character.
1026  E235 FE 3D        	CP	'='		;only allow an '=' or '_' seperator.
1027  E237 CA 3F E2     	JP	Z,RENAME1
1028  E23A FE 5F        	CP	'_'
1029  E23C C2 73 E2     	JP	NZ,RENAME5
1030  E23F EB           RENAME1:EX	DE,HL
1031  E240 23           	INC	HL		;ok, skip seperator.
1032  E241 22 88 DC     	LD	(INPOINT),HL	;save input line pointer.
1033  E244 CD 5E DE     	CALL	CONVFST		;convert this second file name now.
1034  E247 C2 73 E2     	JP	NZ,RENAME5	;again, no wild cards.
1035  E24A F1           	POP	AF		;if a drive was specified, then it
1036  E24B 47           	LD	B,A		;must be the same as before.
1037  E24C 21 F0 E3     	LD	HL,CHGDRV
1038  E24F 7E           	LD	A,(HL)
1039  E250 B7           	OR	A
1040  E251 CA 59 E2     	JP	Z,RENAME2
1041  E254 B8           	CP	B
1042  E255 70           	LD	(HL),B
1043  E256 C2 73 E2     	JP	NZ,RENAME5	;they were different, error.
1044  E259 70           RENAME2:LD	(HL),B		;	reset as per the first file specification.
1045  E25A AF           	XOR	A
1046  E25B 32 CD E3     	LD	(FCB),A		;clear the drive byte of the fcb.
1047  E25E CD E9 DC     RENAME3:CALL	SRCHFCB		;and go look for second file.
1048  E261 CA 6D E2     	JP	Z,RENAME4	;doesn't exist?
1049  E264 11 CD E3     	LD	DE,FCB
1050  E267 CD 0E DD     	CALL	RENAM		;ok, rename the file.
1051  E26A C3 86 E3     	JP	GETBACK
1052  E26D              ;
1053  E26D              ;   Process rename errors here.
1054  E26D              ;
1055  E26D CD EA DF     RENAME4:CALL	NONE		;file not there.
1056  E270 C3 86 E3     	JP	GETBACK
1057  E273 CD 66 E0     RENAME5:CALL	RESETDR		;bad command format.
1058  E276 C3 09 DE     	JP	SYNERR
1059  E279 01 82 E2     RENAME6:LD	BC,EXISTS	;destination file already exists.
1060  E27C CD A7 DC     	CALL	PLINE
1061  E27F C3 86 E3     	JP	GETBACK
1062  E282 46 69 6C 65  EXISTS:	DEFB	'File exists',0
1062  E286 20 65 78 69
1062  E28A 73 74 73 00
1063  E28E              ;
1064  E28E              ;**************************************************************
1065  E28E              ;*
1066  E28E              ;*             U S E R   C O M M A N D
1067  E28E              ;*
1068  E28E              ;**************************************************************
1069  E28E              ;
1070  E28E CD F8 DF     USER:	CALL	DECODE		;get numeric value following command.
1071  E291 FE 10        	CP	16		;legal user number?
1072  E293 D2 09 DE     	JP	NC,SYNERR
1073  E296 5F           	LD	E,A		;yes but is there anything else?
1074  E297 3A CE E3     	LD	A,(FCB+1)
1075  E29A FE 20        	CP	' '
1076  E29C CA 09 DE     	JP	Z,SYNERR	;yes, that is not allowed.
1077  E29F CD 15 DD     	CALL	GETSETUC	;ok, set user code.
1078  E2A2 C3 89 E3     	JP	GETBACK1
1079  E2A5              ;
1080  E2A5              ;**************************************************************
1081  E2A5              ;*
1082  E2A5              ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1083  E2A5              ;*
1084  E2A5              ;**************************************************************
1085  E2A5              ;
1086  E2A5 CD F5 DD     UNKNOWN:CALL	VERIFY		;check for valid system (why?).
1087  E2A8 3A CE E3     	LD	A,(FCB+1)	;anything to execute?
1088  E2AB FE 20        	CP	' '
1089  E2AD C2 C4 E2     	JP	NZ,UNKWN1
1090  E2B0 3A F0 E3     	LD	A,(CHGDRV)	;nope, only a drive change?
1091  E2B3 B7           	OR	A
1092  E2B4 CA 89 E3     	JP	Z,GETBACK1	;neither???
1093  E2B7 3D           	DEC	A
1094  E2B8 32 EF E3     	LD	(CDRIVE),A	;ok, store new drive.
1095  E2BB CD 29 DD     	CALL	MOVECD		;set (TDRIVE) also.
1096  E2BE CD BD DC     	CALL	DSKSEL		;and select this drive.
1097  E2C1 C3 89 E3     	JP	GETBACK1	;then return.
1098  E2C4              ;
1099  E2C4              ;   Here a file name was typed. Prepare to execute it.
1100  E2C4              ;
1101  E2C4 11 D6 E3     UNKWN1:	LD	DE,FCB+9	;an extension specified?
1102  E2C7 1A           	LD	A,(DE)
1103  E2C8 FE 20        	CP	' '
1104  E2CA C2 09 DE     	JP	NZ,SYNERR	;yes, not allowed.
1105  E2CD D5           UNKWN2:	PUSH	DE
1106  E2CE CD 54 E0     	CALL	DSELECT		;select specified drive.
1107  E2D1 D1           	POP	DE
1108  E2D2 21 83 E3     	LD	HL,COMFILE	;set the extension to 'COM'.
1109  E2D5 CD 40 E0     	CALL	MOVE3
1110  E2D8 CD D0 DC     	CALL	OPENFCB		;and open this file.
1111  E2DB CA 6B E3     	JP	Z,UNKWN9	;not present?
1112  E2DE              ;
1113  E2DE              ;   Load in the program.
1114  E2DE              ;
1115  E2DE 21 00 01     	LD	HL,TBASE	;store the program starting here.
1116  E2E1 E5           UNKWN3:	PUSH	HL
1117  E2E2 EB           	EX	DE,HL
1118  E2E3 CD D8 DD     	CALL	DMASET		;set transfer address.
1119  E2E6 11 CD E3     	LD	DE,FCB		;and read the next record.
1120  E2E9 CD F9 DC     	CALL	RDREC
1121  E2EC C2 01 E3     	JP	NZ,UNKWN4	;end of file or read error?
1122  E2EF E1           	POP	HL		;nope, bump pointer for next sector.
1123  E2F0 11 80 00     	LD	DE,128
1124  E2F3 19           	ADD	HL,DE
1125  E2F4 11 00 DC     	LD	DE,CBASE	;enough room for the whole file?
1126  E2F7 7D           	LD	A,L
1127  E2F8 93           	SUB	E
1128  E2F9 7C           	LD	A,H
1129  E2FA 9A           	SBC	A,D
1130  E2FB D2 71 E3     	JP	NC,UNKWN0	;no, it can't fit.
1131  E2FE C3 E1 E2     	JP	UNKWN3
1132  E301              ;
1133  E301              ;   Get here after finished reading.
1134  E301              ;
1135  E301 E1           UNKWN4:	POP	HL
1136  E302 3D           	DEC	A		;normal end of file?
1137  E303 C2 71 E3     	JP	NZ,UNKWN0
1138  E306 CD 66 E0     	CALL	RESETDR		;yes, reset previous drive.
1139  E309 CD 5E DE     	CALL	CONVFST		;convert the first file name that follows
1140  E30C 21 F0 E3     	LD	HL,CHGDRV	;command name.
1141  E30F E5           	PUSH	HL
1142  E310 7E           	LD	A,(HL)		;set drive code in default fcb.
1143  E311 32 CD E3     	LD	(FCB),A
1144  E314 3E 10        	LD	A,16		;put second name 16 bytes later.
1145  E316 CD 60 DE     	CALL	CONVERT		;convert second file name.
1146  E319 E1           	POP	HL
1147  E31A 7E           	LD	A,(HL)		;and set the drive for this second file.
1148  E31B 32 DD E3     	LD	(FCB+16),A
1149  E31E AF           	XOR	A		;clear record byte in fcb.
1150  E31F 32 ED E3     	LD	(FCB+32),A
1151  E322 11 5C 00     	LD	DE,TFCB		;move it into place at(005Ch).
1152  E325 21 CD E3     	LD	HL,FCB
1153  E328 06 21        	LD	B,33
1154  E32A CD 42 E0     	CALL	HL2DE
1155  E32D 21 08 DC     	LD	HL,INBUFF+2	;now move the remainder of the input
1156  E330 7E           UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1157  E331 B7           	OR	A		;or a null.
1158  E332 CA 3E E3     	JP	Z,UNKWN6
1159  E335 FE 20        	CP	' '
1160  E337 CA 3E E3     	JP	Z,UNKWN6
1161  E33A 23           	INC	HL
1162  E33B C3 30 E3     	JP	UNKWN5
1163  E33E              ;
1164  E33E              ;   Do the line move now. It ends in a null byte.
1165  E33E              ;
1166  E33E 06 00        UNKWN6:	LD	B,0		;keep a character count.
1167  E340 11 81 00     	LD	DE,TBUFF+1	;data gets put here.
1168  E343 7E           UNKWN7:	LD	A,(HL)		;move it now.
1169  E344 12           	LD	(DE),A
1170  E345 B7           	OR	A
1171  E346 CA 4F E3     	JP	Z,UNKWN8
1172  E349 04           	INC	B
1173  E34A 23           	INC	HL
1174  E34B 13           	INC	DE
1175  E34C C3 43 E3     	JP	UNKWN7
1176  E34F 78           UNKWN8:	LD	A,B		;now store the character count.
1177  E350 32 80 00     	LD	(TBUFF),A
1178  E353 CD 98 DC     	CALL	CRLF		;clean up the screen.
1179  E356 CD D5 DD     	CALL	STDDMA		;set standard transfer address.
1180  E359 CD 1A DD     	CALL	SETCDRV		;reset current drive.
1181  E35C CD 00 01     	CALL	TBASE		;and execute the program.
1182  E35F              ;
1183  E35F              ;   Transiant programs return here (or reboot).
1184  E35F              ;
1185  E35F 31 AB E3     	LD	SP,BATCH	;set stack first off.
1186  E362 CD 29 DD     	CALL	MOVECD		;move current drive into place (TDRIVE).
1187  E365 CD BD DC     	CALL	DSKSEL		;and reselect it.
1188  E368 C3 82 DF     	JP	CMMND1		;back to comand mode.
1189  E36B              ;
1190  E36B              ;   Get here if some error occured.
1191  E36B              ;
1192  E36B CD 66 E0     UNKWN9:	CALL	RESETDR		;inproper format.
1193  E36E C3 09 DE     	JP	SYNERR
1194  E371 01 7A E3     UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
1195  E374 CD A7 DC     	CALL	PLINE
1196  E377 C3 86 E3     	JP	GETBACK
1197  E37A 42 61 64 20  BADLOAD:DEFB	'Bad load',0
1197  E37E 6C 6F 61 64
1197  E382 00
1198  E383 43 4F 4D     COMFILE:DEFB	'COM'		;command file extension.
1199  E386              ;
1200  E386              ;   Get here to return to command level. We will reset the
1201  E386              ; previous active drive and then either return to command
1202  E386              ; level directly or print error message and then return.
1203  E386              ;
1204  E386 CD 66 E0     GETBACK:CALL	RESETDR		;reset previous drive.
1205  E389 CD 5E DE     GETBACK1: CALL	CONVFST		;convert first name in (FCB).
1206  E38C 3A CE E3     	LD	A,(FCB+1)	;if this was just a drive change request,
1207  E38F D6 20        	SUB	' '		;make sure it was valid.
1208  E391 21 F0 E3     	LD	HL,CHGDRV
1209  E394 B6           	OR	(HL)
1210  E395 C2 09 DE     	JP	NZ,SYNERR
1211  E398 C3 82 DF     	JP	CMMND1		;ok, return to command level.
1212  E39B              ;
1213  E39B              ;   ccp stack area.
1214  E39B              ;
1215  E39B 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1215  E39F 00 00 00 00
1215  E3A3 00 00 00 00
1215  E3A7 00 00 00 00
1216  E3AB              CCPSTACK EQU	$	;end of ccp stack area.
1217  E3AB              ;
1218  E3AB              ;   Batch (or SUBMIT) processing information storage.
1219  E3AB              ;
1220  E3AB 00           BATCH:	DEFB	0		;batch mode flag (0=not active).
1221  E3AC 00 24 24 24  BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1221  E3B0 20 20 20 20
1221  E3B4 20 53 55 42
1221  E3B8 00 00 00 00
1221  E3BC 00 00 00 00
1221  E3C0 00 00 00 00
1221  E3C4 00 00 00 00
1221  E3C8 00 00 00 00
1221  E3CC 00
1222  E3CD              ;
1223  E3CD              ;   File control block setup by the CCP.
1224  E3CD              ;
1225  E3CD 00 20 20 20  FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1225  E3D1 20 20 20 20
1225  E3D5 20 20 20 20
1225  E3D9 00 00 00 00
1225  E3DD 00 20 20 20
1225  E3E1 20 20 20 20
1225  E3E5 20 20 20 20
1225  E3E9 00 00 00 00
1225  E3ED 00
1226  E3EE 00           RTNCODE:DEFB	0		;status returned from bdos call.
1227  E3EF 00           CDRIVE:	DEFB	0		;currently active drive.
1228  E3F0 00           CHGDRV:	DEFB	0		;change in drives flag (0=no change).
1229  E3F1 00 00        NBYTES:	DEFW	0		;byte counter used by TYPE.
1230  E3F3              ;
1231  E3F3              ;   Room for expansion?
1232  E3F3              ;
1233  E3F3 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
1233  E3F7 00 00 00 00
1233  E3FB 00 00 00 00
1233  E3FF 00
1234  E400              ;
1235  E400              ;   Note that the following six bytes must match those at
1236  E400              ; (PATTRN1) or cp/m will HALT. Why?
1237  E400              ;
1238  E400 00 16 00 00  PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
1238  E404 00 00
1239  E406              ;
1240  E406              ;**************************************************************
1241  E406              ;*
1242  E406              ;*                    B D O S   E N T R Y
1243  E406              ;*
1244  E406              ;**************************************************************
1245  E406              ;
1246  E406 C3 11 E4     FBASE:	JP	FBASE1
1247  E409              ;
1248  E409              ;   Bdos error table.
1249  E409              ;
1250  E409 99 E4        BADSCTR:DEFW	ERROR1		;bad sector on read or write.
1251  E40B A5 E4        BADSLCT:DEFW	ERROR2		;bad disk select.
1252  E40D AB E4        RODISK:	DEFW	ERROR3		;disk is read only.
1253  E40F B1 E4        ROFILE:	DEFW	ERROR4		;file is read only.
1254  E411              ;
1255  E411              ;   Entry into bdos. (DE) or (E) are the parameters passed. The
1256  E411              ; function number desired is in register (C).
1257  E411              ;
1258  E411 EB           FBASE1:	EX	DE,HL		;save the (DE) parameters.
1259  E412 22 43 E7     	LD	(PARAMS),HL
1260  E415 EB           	EX	DE,HL
1261  E416 7B           	LD	A,E		;and save register (E) in particular.
1262  E417 32 D6 F1     	LD	(EPARAM),A
1263  E41A 21 00 00     	LD	HL,0
1264  E41D 22 45 E7     	LD	(STATUS),HL	;clear return status.
1265  E420 39           	ADD	HL,SP
1266  E421 22 0F E7     	LD	(USRSTACK),HL	;save users stack pointer.
1267  E424 31 41 E7     	LD	SP,STKAREA	;and set our own.
1268  E427 AF           	XOR	A		;clear auto select storage space.
1269  E428 32 E0 F1     	LD	(AUTOFLAG),A
1270  E42B 32 DE F1     	LD	(AUTO),A
1271  E42E 21 74 F1     	LD	HL,GOBACK	;set return address.
1272  E431 E5           	PUSH	HL
1273  E432 79           	LD	A,C		;get function number.
1274  E433 FE 29        	CP	NFUNCTS		;valid function number?
1275  E435 D0           	RET	NC
1276  E436 4B           	LD	C,E		;keep single register function here.
1277  E437 21 47 E4     	LD	HL,FUNCTNS	;now look thru the function table.
1278  E43A 5F           	LD	E,A
1279  E43B 16 00        	LD	D,0		;(DE)=function number.
1280  E43D 19           	ADD	HL,DE
1281  E43E 19           	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
1282  E43F 5E           	LD	E,(HL)
1283  E440 23           	INC	HL
1284  E441 56           	LD	D,(HL)		;now (DE)=address for this function.
1285  E442 2A 43 E7     	LD	HL,(PARAMS)	;retrieve parameters.
1286  E445 EB           	EX	DE,HL		;now (DE) has the original parameters.
1287  E446 E9           	JP	(HL)		;execute desired function.
1288  E447              ;
1289  E447              ;   BDOS function jump table.
1290  E447              ;
1291  E447              NFUNCTS EQU	41		;number of functions in followin table.
1292  E447              ;
1293  E447 03 F2 C8 E6  FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1293  E44B 90 E5 CE E6
1293  E44F 12 F2 0F F2
1293  E453 D4 E6 ED E6
1294  E457 F3 E6 F8 E6  	DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1294  E45B E1 E5 FE E6
1294  E45F 7E F0 83 F0
1294  E463 45 F0 9C F0
1295  E467 A5 F0 AB F0  	DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1295  E46B C8 F0 D7 F0
1295  E46F E0 F0 E6 F0
1295  E473 EC F0
1296  E475 F5 F0 FE F0  	DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1296  E479 04 F1 0A F1
1296  E47D 11 F1 2C E9
1296  E481 17 F1 1D F1
1297  E485 26 F1 2D F1  	DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1297  E489 41 F1 47 F1
1297  E48D 4D F1 0E F0
1297  E491 53 F1 04 E7
1298  E495 04 E7 9B F1  	DEFW	RTN,WTSPECL
1299  E499              ;
1300  E499              ;   Bdos error message section.
1301  E499              ;
1302  E499 21 CA E4     ERROR1:	LD	HL,BADSEC	;bad sector message.
1303  E49C CD E5 E4     	CALL	PRTERR		;print it and get a 1 char responce.
1304  E49F FE 03        	CP	CNTRLC		;re-boot request (control-c)?
1305  E4A1 CA 00 00     	JP	Z,0		;yes.
1306  E4A4 C9           	RET			;no, return to retry i/o function.
1307  E4A5              ;
1308  E4A5 21 D5 E4     ERROR2:	LD	HL,BADSEL	;bad drive selected.
1309  E4A8 C3 B4 E4     	JP	ERROR5
1310  E4AB              ;
1311  E4AB 21 E1 E4     ERROR3:	LD	HL,DISKRO	;disk is read only.
1312  E4AE C3 B4 E4     	JP	ERROR5
1313  E4B1              ;
1314  E4B1 21 DC E4     ERROR4:	LD	HL,FILERO	;file is read only.
1315  E4B4              ;
1316  E4B4 CD E5 E4     ERROR5:	CALL	PRTERR
1317  E4B7 C3 00 00     	JP	0		;always reboot on these errors.
1318  E4BA              ;
1319  E4BA 42 64 6F 73  BDOSERR:DEFB	'Bdos Err On '
1319  E4BE 20 45 72 72
1319  E4C2 20 4F 6E 20
1320  E4C6 20 3A 20 24  BDOSDRV:DEFB	' : $'
1321  E4CA 42 61 64 20  BADSEC:	DEFB	'Bad Sector$'
1321  E4CE 53 65 63 74
1321  E4D2 6F 72 24
1322  E4D5 53 65 6C 65  BADSEL:	DEFB	'Select$'
1322  E4D9 63 74 24
1323  E4DC 46 69 6C 65  FILERO:	DEFB	'File '
1323  E4E0 20
1324  E4E1 52 2F 4F 24  DISKRO:	DEFB	'R/O$'
1325  E4E5              ;
1326  E4E5              ;   Print bdos error message.
1327  E4E5              ;
1328  E4E5 E5           PRTERR:	PUSH	HL		;save second message pointer.
1329  E4E6 CD C9 E5     	CALL	OUTCRLF		;send (cr)(lf).
1330  E4E9 3A 42 E7     	LD	A,(ACTIVE)	;get active drive.
1331  E4EC C6 41        	ADD	A,'A'		;make ascii.
1332  E4EE 32 C6 E4     	LD	(BDOSDRV),A	;and put in message.
1333  E4F1 01 BA E4     	LD	BC,BDOSERR	;and print it.
1334  E4F4 CD D3 E5     	CALL	PRTMESG
1335  E4F7 C1           	POP	BC		;print second message line now.
1336  E4F8 CD D3 E5     	CALL	PRTMESG
1337  E4FB              ;
1338  E4FB              ;   Get an input character. We will check our 1 character
1339  E4FB              ; buffer first. This may be set by the console status routine.
1340  E4FB              ;
1341  E4FB 21 0E E7     GETCHAR:LD	HL,CHARBUF	;check character buffer.
1342  E4FE 7E           	LD	A,(HL)		;anything present already?
1343  E4FF 36 00        	LD	(HL),0		;...either case clear it.
1344  E501 B7           	OR	A
1345  E502 C0           	RET	NZ		;yes, use it.
1346  E503 C3 09 F2     	JP	CONIN		;nope, go get a character responce.
1347  E506              ;
1348  E506              ;   Input and echo a character.
1349  E506              ;
1350  E506 CD FB E4     GETECHO:CALL	GETCHAR		;input a character.
1351  E509 CD 14 E5     	CALL	CHKCHAR		;carriage control?
1352  E50C D8           	RET	C		;no, a regular control char so don't echo.
1353  E50D F5           	PUSH	AF		;ok, save character now.
1354  E50E 4F           	LD	C,A
1355  E50F CD 90 E5     	CALL	OUTCON		;and echo it.
1356  E512 F1           	POP	AF		;get character and return.
1357  E513 C9           	RET
1358  E514              ;
1359  E514              ;   Check character in (A). Set the zero flag on a carriage
1360  E514              ; control character and the carry flag on any other control
1361  E514              ; character.
1362  E514              ;
1363  E514 FE 0D        CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
1364  E516 C8           	RET	Z		;or a tab.
1365  E517 FE 0A        	CP	LF
1366  E519 C8           	RET	Z
1367  E51A FE 09        	CP	TAB
1368  E51C C8           	RET	Z
1369  E51D FE 08        	CP	BS
1370  E51F C8           	RET	Z
1371  E520 FE 20        	CP	' '		;other control char? Set carry flag.
1372  E522 C9           	RET
1373  E523              ;
1374  E523              ;   Check the console during output. Halt on a control-s, then
1375  E523              ; reboot on a control-c. If anything else is ready, clear the
1376  E523              ; zero flag and return (the calling routine may want to do
1377  E523              ; something).
1378  E523              ;
1379  E523 3A 0E E7     CKCONSOL: LD	A,(CHARBUF)	;check buffer.
1380  E526 B7           	OR	A		;if anything, just return without checking.
1381  E527 C2 45 E5     	JP	NZ,CKCON2
1382  E52A CD 06 F2     	CALL	CONST		;nothing in buffer. Check console.
1383  E52D E6 01        	AND	01H		;look at bit 0.
1384  E52F C8           	RET	Z		;return if nothing.
1385  E530 CD 09 F2     	CALL	CONIN		;ok, get it.
1386  E533 FE 13        	CP	CNTRLS		;if not control-s, return with zero cleared.
1387  E535 C2 42 E5     	JP	NZ,CKCON1
1388  E538 CD 09 F2     	CALL	CONIN		;halt processing until another char
1389  E53B FE 03        	CP	CNTRLC		;is typed. Control-c?
1390  E53D CA 00 00     	JP	Z,0		;yes, reboot now.
1391  E540 AF           	XOR	A		;no, just pretend nothing was ever ready.
1392  E541 C9           	RET
1393  E542 32 0E E7     CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
1394  E545 3E 01        CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
1395  E547 C9           	RET
1396  E548              ;
1397  E548              ;   Output (C) to the screen. If the printer flip-flop flag
1398  E548              ; is set, we will send character to printer also. The console
1399  E548              ; will be checked in the process.
1400  E548              ;
1401  E548 3A 0A E7     OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
1402  E54B B7           	OR	A		;anything and we won't generate output.
1403  E54C C2 62 E5     	JP	NZ,OUTCHR1
1404  E54F C5           	PUSH	BC
1405  E550 CD 23 E5     	CALL	CKCONSOL	;check console (we don't care whats there).
1406  E553 C1           	POP	BC
1407  E554 C5           	PUSH	BC
1408  E555 CD 0C F2     	CALL	CONOUT		;output (C) to the screen.
1409  E558 C1           	POP	BC
1410  E559 C5           	PUSH	BC
1411  E55A 3A 0D E7     	LD	A,(PRTFLAG)	;check printer flip-flop flag.
1412  E55D B7           	OR	A
1413  E55E C4 0F F2     	CALL	NZ,LIST		;print it also if non-zero.
1414  E561 C1           	POP	BC
1415  E562 79           OUTCHR1:LD	A,C		;update cursors position.
1416  E563 21 0C E7     	LD	HL,CURPOS
1417  E566 FE 7F        	CP	DEL		;rubouts don't do anything here.
1418  E568 C8           	RET	Z
1419  E569 34           	INC	(HL)		;bump line pointer.
1420  E56A FE 20        	CP	' '		;and return if a normal character.
1421  E56C D0           	RET	NC
1422  E56D 35           	DEC	(HL)		;restore and check for the start of the line.
1423  E56E 7E           	LD	A,(HL)
1424  E56F B7           	OR	A
1425  E570 C8           	RET	Z		;ingnore control characters at the start of the line.
1426  E571 79           	LD	A,C
1427  E572 FE 08        	CP	BS		;is it a backspace?
1428  E574 C2 79 E5     	JP	NZ,OUTCHR2
1429  E577 35           	DEC	(HL)		;yes, backup pointer.
1430  E578 C9           	RET
1431  E579 FE 0A        OUTCHR2:CP	LF		;is it a line feed?
1432  E57B C0           	RET	NZ		;ignore anything else.
1433  E57C 36 00        	LD	(HL),0		;reset pointer to start of line.
1434  E57E C9           	RET
1435  E57F              ;
1436  E57F              ;   Output (A) to the screen. If it is a control character
1437  E57F              ; (other than carriage control), use ^x format.
1438  E57F              ;
1439  E57F 79           SHOWIT:	LD	A,C
1440  E580 CD 14 E5     	CALL	CHKCHAR		;check character.
1441  E583 D2 90 E5     	JP	NC,OUTCON	;not a control, use normal output.
1442  E586 F5           	PUSH	AF
1443  E587 0E 5E        	LD	C,'^'		;for a control character, preceed it with '^'.
1444  E589 CD 48 E5     	CALL	OUTCHAR
1445  E58C F1           	POP	AF
1446  E58D F6 40        	OR	'@'		;and then use the letter equivelant.
1447  E58F 4F           	LD	C,A
1448  E590              ;
1449  E590              ;   Function to output (C) to the console device and expand tabs
1450  E590              ; if necessary.
1451  E590              ;
1452  E590 79           OUTCON:	LD	A,C
1453  E591 FE 09        	CP	TAB		;is it a tab?
1454  E593 C2 48 E5     	JP	NZ,OUTCHAR	;use regular output.
1455  E596 0E 20        OUTCON1:LD	C,' '		;yes it is, use spaces instead.
1456  E598 CD 48 E5     	CALL	OUTCHAR
1457  E59B 3A 0C E7     	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
1458  E59E
1459  E59E E6 07        	AND	07H		;position.
1460  E5A0 C2 96 E5     	JP	NZ,OUTCON1
1461  E5A3 C9           	RET
1462  E5A4              ;
1463  E5A4              ;   Echo a backspace character. Erase the prevoius character
1464  E5A4              ; on the screen.
1465  E5A4              ;
1466  E5A4 CD AC E5     BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
1467  E5A7 0E 20        	LD	C,' '		;then blank that character.
1468  E5A9 CD 0C F2     	CALL	CONOUT
1469  E5AC 0E 08        BACKUP1:LD	C,BS		;then back space once more.
1470  E5AE C3 0C F2     	JP	CONOUT
1471  E5B1              ;
1472  E5B1              ;   Signal a deleted line. Print a '#' at the end and start
1473  E5B1              ; over.
1474  E5B1              ;
1475  E5B1 0E 23        NEWLINE:LD	C,'#'
1476  E5B3 CD 48 E5     	CALL	OUTCHAR		;print this.
1477  E5B6 CD C9 E5     	CALL	OUTCRLF		;start new line.
1478  E5B9 3A 0C E7     NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
1479  E5BC 21 0B E7     	LD	HL,STARTING
1480  E5BF BE           	CP	(HL)
1481  E5C0 D0           	RET	NC		;there yet?
1482  E5C1 0E 20        	LD	C,' '
1483  E5C3 CD 48 E5     	CALL	OUTCHAR		;nope, keep going.
1484  E5C6 C3 B9 E5     	JP	NEWLN1
1485  E5C9              ;
1486  E5C9              ;   Output a (cr) (lf) to the console device (screen).
1487  E5C9              ;
1488  E5C9 0E 0D        OUTCRLF:LD	C,CR
1489  E5CB CD 48 E5     	CALL	OUTCHAR
1490  E5CE 0E 0A        	LD	C,LF
1491  E5D0 C3 48 E5     	JP	OUTCHAR
1492  E5D3              ;
1493  E5D3              ;   Print message pointed to by (BC). It will end with a '$'.
1494  E5D3              ;
1495  E5D3 0A           PRTMESG:LD	A,(BC)		;check for terminating character.
1496  E5D4 FE 24        	CP	'$'
1497  E5D6 C8           	RET	Z
1498  E5D7 03           	INC	BC
1499  E5D8 C5           	PUSH	BC		;otherwise, bump pointer and print it.
1500  E5D9 4F           	LD	C,A
1501  E5DA CD 90 E5     	CALL	OUTCON
1502  E5DD C1           	POP	BC
1503  E5DE C3 D3 E5     	JP	PRTMESG
1504  E5E1              ;
1505  E5E1              ;   Function to execute a buffered read.
1506  E5E1              ;
1507  E5E1 3A 0C E7     RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
1508  E5E4 32 0B E7     	LD	(STARTING),A
1509  E5E7 2A 43 E7     	LD	HL,(PARAMS)	;get the maximum buffer space.
1510  E5EA 4E           	LD	C,(HL)
1511  E5EB 23           	INC	HL		;point to first available space.
1512  E5EC E5           	PUSH	HL		;and save.
1513  E5ED 06 00        	LD	B,0		;keep a character count.
1514  E5EF C5           RDBUF1:	PUSH	BC
1515  E5F0 E5           	PUSH	HL
1516  E5F1 CD FB E4     RDBUF2:	CALL	GETCHAR		;get the next input character.
1517  E5F4 E6 7F        	AND	7FH		;strip bit 7.
1518  E5F6 E1           	POP	HL		;reset registers.
1519  E5F7 C1           	POP	BC
1520  E5F8 FE 0D        	CP	CR		;en of the line?
1521  E5FA CA C1 E6     	JP	Z,RDBUF17
1522  E5FD FE 0A        	CP	LF
1523  E5FF CA C1 E6     	JP	Z,RDBUF17
1524  E602 FE 08        	CP	BS		;how about a backspace?
1525  E604 C2 16 E6     	JP	NZ,RDBUF3
1526  E607 78           	LD	A,B		;yes, but ignore at the beginning of the line.
1527  E608 B7           	OR	A
1528  E609 CA EF E5     	JP	Z,RDBUF1
1529  E60C 05           	DEC	B		;ok, update counter.
1530  E60D 3A 0C E7     	LD	A,(CURPOS)	;if we backspace to the start of the line,
1531  E610 32 0A E7     	LD	(OUTFLAG),A	;treat as a cancel (control-x).
1532  E613 C3 70 E6     	JP	RDBUF10
1533  E616 FE 7F        RDBUF3:	CP	DEL		;user typed a rubout?
1534  E618 C2 26 E6     	JP	NZ,RDBUF4
1535  E61B 78           	LD	A,B		;ignore at the start of the line.
1536  E61C B7           	OR	A
1537  E61D CA EF E5     	JP	Z,RDBUF1
1538  E620 7E           	LD	A,(HL)		;ok, echo the prevoius character.
1539  E621 05           	DEC	B		;and reset pointers (counters).
1540  E622 2B           	DEC	HL
1541  E623 C3 A9 E6     	JP	RDBUF15
1542  E626 FE 05        RDBUF4:	CP	CNTRLE		;physical end of line?
1543  E628 C2 37 E6     	JP	NZ,RDBUF5
1544  E62B C5           	PUSH	BC		;yes, do it.
1545  E62C E5           	PUSH	HL
1546  E62D CD C9 E5     	CALL	OUTCRLF
1547  E630 AF           	XOR	A		;and update starting position.
1548  E631 32 0B E7     	LD	(STARTING),A
1549  E634 C3 F1 E5     	JP	RDBUF2
1550  E637 FE 10        RDBUF5:	CP	CNTRLP		;control-p?
1551  E639 C2 48 E6     	JP	NZ,RDBUF6
1552  E63C E5           	PUSH	HL		;yes, flip the print flag filp-flop byte.
1553  E63D 21 0D E7     	LD	HL,PRTFLAG
1554  E640 3E 01        	LD	A,1		;PRTFLAG=1-PRTFLAG
1555  E642 96           	SUB	(HL)
1556  E643 77           	LD	(HL),A
1557  E644 E1           	POP	HL
1558  E645 C3 EF E5     	JP	RDBUF1
1559  E648 FE 18        RDBUF6:	CP	CNTRLX		;control-x (cancel)?
1560  E64A C2 5F E6     	JP	NZ,RDBUF8
1561  E64D E1           	POP	HL
1562  E64E 3A 0B E7     RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
1563  E651 21 0C E7     	LD	HL,CURPOS
1564  E654 BE           	CP	(HL)
1565  E655 D2 E1 E5     	JP	NC,RDBUFF	;done yet?
1566  E658 35           	DEC	(HL)		;no, decrement pointer and output back up one space.
1567  E659 CD A4 E5     	CALL	BACKUP
1568  E65C C3 4E E6     	JP	RDBUF7
1569  E65F FE 15        RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
1570  E661 C2 6B E6     	JP	NZ,RDBUF9
1571  E664 CD B1 E5     	CALL	NEWLINE		;start a new line.
1572  E667 E1           	POP	HL
1573  E668 C3 E1 E5     	JP	RDBUFF
1574  E66B FE 12        RDBUF9:	CP	CNTRLR		;control-r?
1575  E66D C2 A6 E6     	JP	NZ,RDBUF14
1576  E670 C5           RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
1577  E671 CD B1 E5     	CALL	NEWLINE
1578  E674 C1           	POP	BC
1579  E675 E1           	POP	HL
1580  E676 E5           	PUSH	HL
1581  E677 C5           	PUSH	BC
1582  E678 78           RDBUF11:LD	A,B		;done whole line yet?
1583  E679 B7           	OR	A
1584  E67A CA 8A E6     	JP	Z,RDBUF12
1585  E67D 23           	INC	HL		;nope, get next character.
1586  E67E 4E           	LD	C,(HL)
1587  E67F 05           	DEC	B		;count it.
1588  E680 C5           	PUSH	BC
1589  E681 E5           	PUSH	HL
1590  E682 CD 7F E5     	CALL	SHOWIT		;and display it.
1591  E685 E1           	POP	HL
1592  E686 C1           	POP	BC
1593  E687 C3 78 E6     	JP	RDBUF11
1594  E68A E5           RDBUF12:PUSH	HL		;done with line. If we were displaying
1595  E68B 3A 0A E7     	LD	A,(OUTFLAG)	;then update cursor position.
1596  E68E B7           	OR	A
1597  E68F CA F1 E5     	JP	Z,RDBUF2
1598  E692 21 0C E7     	LD	HL,CURPOS	;because this line is shorter, we must
1599  E695 96           	SUB	(HL)		;back up the cursor (not the screen however)
1600  E696 32 0A E7     	LD	(OUTFLAG),A	;some number of positions.
1601  E699 CD A4 E5     RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
1602  E69C 21 0A E7     	LD	HL,OUTFLAG	;zero, the screen will not be changed.
1603  E69F 35           	DEC	(HL)
1604  E6A0 C2 99 E6     	JP	NZ,RDBUF13
1605  E6A3 C3 F1 E5     	JP	RDBUF2		;now just get the next character.
1606  E6A6              ;
1607  E6A6              ;   Just a normal character, put this in our buffer and echo.
1608  E6A6              ;
1609  E6A6 23           RDBUF14:INC	HL
1610  E6A7 77           	LD	(HL),A		;store character.
1611  E6A8 04           	INC	B		;and count it.
1612  E6A9 C5           RDBUF15:PUSH	BC
1613  E6AA E5           	PUSH	HL
1614  E6AB 4F           	LD	C,A		;echo it now.
1615  E6AC CD 7F E5     	CALL	SHOWIT
1616  E6AF E1           	POP	HL
1617  E6B0 C1           	POP	BC
1618  E6B1 7E           	LD	A,(HL)		;was it an abort request?
1619  E6B2 FE 03        	CP	CNTRLC		;control-c abort?
1620  E6B4 78           	LD	A,B
1621  E6B5 C2 BD E6     	JP	NZ,RDBUF16
1622  E6B8 FE 01        	CP	1		;only if at start of line.
1623  E6BA CA 00 00     	JP	Z,0
1624  E6BD B9           RDBUF16:CP	C		;nope, have we filled the buffer?
1625  E6BE DA EF E5     	JP	C,RDBUF1
1626  E6C1 E1           RDBUF17:POP	HL		;yes end the line and return.
1627  E6C2 70           	LD	(HL),B
1628  E6C3 0E 0D        	LD	C,CR
1629  E6C5 C3 48 E5     	JP	OUTCHAR		;output (cr) and return.
1630  E6C8              ;
1631  E6C8              ;   Function to get a character from the console device.
1632  E6C8              ;
1633  E6C8 CD 06 E5     GETCON:	CALL	GETECHO		;get and echo.
1634  E6CB C3 01 E7     	JP	SETSTAT		;save status and return.
1635  E6CE              ;
1636  E6CE              ;   Function to get a character from the tape reader device.
1637  E6CE              ;
1638  E6CE CD 15 F2     GETRDR:	CALL	READER		;get a character from reader, set status and return.
1639  E6D1 C3 01 E7     	JP	SETSTAT
1640  E6D4              ;
1641  E6D4              ;  Function to perform direct console i/o. If (C) contains (FF)
1642  E6D4              ; then this is an input request. If (C) contains (FE) then
1643  E6D4              ; this is a status request. Otherwise we are to output (C).
1644  E6D4              ;
1645  E6D4 79           DIRCIO:	LD	A,C		;test for (FF).
1646  E6D5 3C           	INC	A
1647  E6D6 CA E0 E6     	JP	Z,DIRC1
1648  E6D9 3C           	INC	A		;test for (FE).
1649  E6DA CA 06 F2     	JP	Z,CONST
1650  E6DD C3 0C F2     	JP	CONOUT		;just output (C).
1651  E6E0 CD 06 F2     DIRC1:	CALL	CONST		;this is an input request.
1652  E6E3 B7           	OR	A
1653  E6E4 CA 91 F1     	JP	Z,GOBACK1	;not ready? Just return (directly).
1654  E6E7 CD 09 F2     	CALL	CONIN		;yes, get character.
1655  E6EA C3 01 E7     	JP	SETSTAT		;set status and return.
1656  E6ED              ;
1657  E6ED              ;   Function to return the i/o byte.
1658  E6ED              ;
CPM22.asm(1659): warning: Accessing low memory address 0x0003, is it ok?: LD	A,(IOBYTE)
1659  E6ED 3A 03 00     GETIOB:	LD	A,(IOBYTE)
1660  E6F0 C3 01 E7     	JP	SETSTAT
1661  E6F3              ;
1662  E6F3              ;   Function to set the i/o byte.
1663  E6F3              ;
1664  E6F3 21 03 00     SETIOB:	LD	HL,IOBYTE
1665  E6F6 71           	LD	(HL),C
1666  E6F7 C9           	RET
1667  E6F8              ;
1668  E6F8              ;   Function to print the character string pointed to by (DE)
1669  E6F8              ; on the console device. The string ends with a '$'.
1670  E6F8              ;
1671  E6F8 EB           PRTSTR:	EX	DE,HL
1672  E6F9 4D           	LD	C,L
1673  E6FA 44           	LD	B,H		;now (BC) points to it.
1674  E6FB C3 D3 E5     	JP	PRTMESG
1675  E6FE              ;
1676  E6FE              ;   Function to interigate the console device.
1677  E6FE              ;
1678  E6FE CD 23 E5     GETCSTS:CALL	CKCONSOL
1679  E701              ;
1680  E701              ;   Get here to set the status and return to the cleanup
1681  E701              ; section. Then back to the user.
1682  E701              ;
1683  E701 32 45 E7     SETSTAT:LD	(STATUS),A
1684  E704 C9           RTN:	RET
1685  E705              ;
1686  E705              ;   Set the status to 1 (read or write error code).
1687  E705              ;
1688  E705 3E 01        IOERR1:	LD	A,1
1689  E707 C3 01 E7     	JP	SETSTAT
1690  E70A              ;
1691  E70A 00           OUTFLAG:DEFB	0		;output flag (non zero means no output).
1692  E70B 02           STARTING: DEFB	2		;starting position for cursor.
1693  E70C 00           CURPOS:	DEFB	0		;cursor position (0=start of line).
1694  E70D 00           PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
1695  E70E 00           CHARBUF:DEFB	0		;single input character buffer.
1696  E70F              ;
1697  E70F              ;   Stack area for BDOS calls.
1698  E70F              ;
1699  E70F 00 00        USRSTACK: DEFW	0		;save users stack pointer here.
1700  E711              ;
1701  E711 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1701  E715 00 00 00 00
1701  E719 00 00 00 00
1701  E71D 00 00 00 00
1701  E721 00 00 00 00
1701  E725 00 00 00 00
1702  E729 00 00 00 00  	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1702  E72D 00 00 00 00
1702  E731 00 00 00 00
1702  E735 00 00 00 00
1702  E739 00 00 00 00
1702  E73D 00 00 00 00
1703  E741              STKAREA EQU	$		;end of stack area.
1704  E741              ;
1705  E741 00           USERNO:	DEFB	0		;current user number.
1706  E742 00           ACTIVE:	DEFB	0		;currently active drive.
1707  E743 00 00        PARAMS:	DEFW	0		;save (DE) parameters here on entry.
1708  E745 00 00        STATUS:	DEFW	0		;status returned from bdos function.
1709  E747              ;
1710  E747              ;   Select error occured, jump to error routine.
1711  E747              ;
1712  E747 21 0B E4     SLCTERR:LD	HL,BADSLCT
1713  E74A              ;
1714  E74A              ;   Jump to (HL) indirectly.
1715  E74A              ;
1716  E74A 5E           JUMPHL:	LD	E,(HL)
1717  E74B 23           	INC	HL
1718  E74C 56           	LD	D,(HL)		;now (DE) contain the desired address.
1719  E74D EB           	EX	DE,HL
1720  E74E E9           	JP	(HL)
1721  E74F              ;
1722  E74F              ;   Block move. (DE) to (HL), (C) bytes total.
1723  E74F              ;
1724  E74F 0C           DE2HL:	INC	C		;is count down to zero?
1725  E750 0D           DE2HL1:	DEC	C
1726  E751 C8           	RET	Z		;yes, we are done.
1727  E752 1A           	LD	A,(DE)		;no, move one more byte.
1728  E753 77           	LD	(HL),A
1729  E754 13           	INC	DE
1730  E755 23           	INC	HL
1731  E756 C3 50 E7     	JP	DE2HL1		;and repeat.
1732  E759              ;
1733  E759              ;   Select the desired drive.
1734  E759              ;
1735  E759 3A 42 E7     SELECT:	LD	A,(ACTIVE)	;get active disk.
1736  E75C 4F           	LD	C,A
1737  E75D CD 1B F2     	CALL	SELDSK		;select it.
1738  E760 7C           	LD	A,H		;valid drive?
1739  E761 B5           	OR	L		;valid drive?
1740  E762 C8           	RET	Z		;return if not.
1741  E763              ;
1742  E763              ;   Here, the BIOS returned the address of the parameter block
1743  E763              ; in (HL). We will extract the necessary pointers and save them.
1744  E763              ;
1745  E763 5E           	LD	E,(HL)		;yes, get address of translation table into (DE).
1746  E764 23           	INC	HL
1747  E765 56           	LD	D,(HL)
1748  E766 23           	INC	HL
1749  E767 22 B3 F1     	LD	(SCRATCH1),HL	;save pointers to scratch areas.
1750  E76A 23           	INC	HL
1751  E76B 23           	INC	HL
1752  E76C 22 B5 F1     	LD	(SCRATCH2),HL	;ditto.
1753  E76F 23           	INC	HL
1754  E770 23           	INC	HL
1755  E771 22 B7 F1     	LD	(SCRATCH3),HL	;ditto.
1756  E774 23           	INC	HL
1757  E775 23           	INC	HL
1758  E776 EB           	EX	DE,HL		;now save the translation table address.
1759  E777 22 D0 F1     	LD	(XLATE),HL
1760  E77A 21 B9 F1     	LD	HL,DIRBUF	;put the next 8 bytes here.
1761  E77D 0E 08        	LD	C,8		;they consist of the directory buffer
1762  E77F CD 4F E7     	CALL	DE2HL		;pointer, parameter block pointer,
1763  E782 2A BB F1     	LD	HL,(DISKPB)	;check and allocation vectors.
1764  E785 EB           	EX	DE,HL
1765  E786 21 C1 F1     	LD	HL,SECTORS	;move parameter block into our ram.
1766  E789 0E 0F        	LD	C,15		;it is 15 bytes long.
1767  E78B CD 4F E7     	CALL	DE2HL
1768  E78E 2A C6 F1     	LD	HL,(DSKSIZE)	;check disk size.
1769  E791 7C           	LD	A,H		;more than 256 blocks on this?
1770  E792 21 DD F1     	LD	HL,BIGDISK
1771  E795 36 FF        	LD	(HL),0FFH	;set to samll.
1772  E797 B7           	OR	A
1773  E798 CA 9D E7     	JP	Z,SELECT1
1774  E79B 36 00        	LD	(HL),0		;wrong, set to large.
1775  E79D 3E FF        SELECT1:LD	A,0FFH		;clear the zero flag.
1776  E79F B7           	OR	A
1777  E7A0 C9           	RET
1778  E7A1              ;
1779  E7A1              ;   Routine to home the disk track head and clear pointers.
1780  E7A1              ;
1781  E7A1 CD 18 F2     HOMEDRV:CALL	HOME		;home the head.
1782  E7A4 AF           	XOR	A
1783  E7A5 2A B5 F1     	LD	HL,(SCRATCH2)	;set our track pointer also.
1784  E7A8 77           	LD	(HL),A
1785  E7A9 23           	INC	HL
1786  E7AA 77           	LD	(HL),A
1787  E7AB 2A B7 F1     	LD	HL,(SCRATCH3)	;and our sector pointer.
1788  E7AE 77           	LD	(HL),A
1789  E7AF 23           	INC	HL
1790  E7B0 77           	LD	(HL),A
1791  E7B1 C9           	RET
1792  E7B2              ;
1793  E7B2              ;   Do the actual disk read and check the error return status.
1794  E7B2              ;
1795  E7B2 CD 27 F2     DOREAD:	CALL	READ
1796  E7B5 C3 BB E7     	JP	IORET
1797  E7B8              ;
1798  E7B8              ;   Do the actual disk write and handle any bios error.
1799  E7B8              ;
1800  E7B8 CD 2A F2     DOWRITE:CALL	WRITE
1801  E7BB B7           IORET:	OR	A
1802  E7BC C8           	RET	Z		;return unless an error occured.
1803  E7BD 21 09 E4     	LD	HL,BADSCTR	;bad read/write on this sector.
1804  E7C0 C3 4A E7     	JP	JUMPHL
1805  E7C3              ;
1806  E7C3              ;   Routine to select the track and sector that the desired
1807  E7C3              ; block number falls in.
1808  E7C3              ;
1809  E7C3 2A EA F1     TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
1810  E7C6 0E 02        	LD	C,2		;in directory and compute sector #.
1811  E7C8 CD EA E8     	CALL	SHIFTR		;sector #=file-position/4.
1812  E7CB 22 E5 F1     	LD	(BLKNMBR),HL	;save this as the block number of interest.
1813  E7CE 22 EC F1     	LD	(CKSUMTBL),HL	;what's it doing here too?
1814  E7D1              ;
1815  E7D1              ;   if the sector number has already been set (BLKNMBR), enter
1816  E7D1              ; at this point.
1817  E7D1              ;
1818  E7D1 21 E5 F1     TRKSEC1:LD	HL,BLKNMBR
1819  E7D4 4E           	LD	C,(HL)		;move sector number into (BC).
1820  E7D5 23           	INC	HL
1821  E7D6 46           	LD	B,(HL)
1822  E7D7 2A B7 F1     	LD	HL,(SCRATCH3)	;get current sector number and
1823  E7DA 5E           	LD	E,(HL)		;move this into (DE).
1824  E7DB 23           	INC	HL
1825  E7DC 56           	LD	D,(HL)
1826  E7DD 2A B5 F1     	LD	HL,(SCRATCH2)	;get current track number.
1827  E7E0 7E           	LD	A,(HL)		;and this into (HL).
1828  E7E1 23           	INC	HL
1829  E7E2 66           	LD	H,(HL)
1830  E7E3 6F           	LD	L,A
1831  E7E4 79           TRKSEC2:LD	A,C		;is desired sector before current one?
1832  E7E5 93           	SUB	E
1833  E7E6 78           	LD	A,B
1834  E7E7 9A           	SBC	A,D
1835  E7E8 D2 FA E7     	JP	NC,TRKSEC3
1836  E7EB E5           	PUSH	HL		;yes, decrement sectors by one track.
1837  E7EC 2A C1 F1     	LD	HL,(SECTORS)	;get sectors per track.
1838  E7EF 7B           	LD	A,E
1839  E7F0 95           	SUB	L
1840  E7F1 5F           	LD	E,A
1841  E7F2 7A           	LD	A,D
1842  E7F3 9C           	SBC	A,H
1843  E7F4 57           	LD	D,A		;now we have backed up one full track.
1844  E7F5 E1           	POP	HL
1845  E7F6 2B           	DEC	HL		;adjust track counter.
1846  E7F7 C3 E4 E7     	JP	TRKSEC2
1847  E7FA E5           TRKSEC3:PUSH	HL		;desired sector is after current one.
1848  E7FB 2A C1 F1     	LD	HL,(SECTORS)	;get sectors per track.
1849  E7FE 19           	ADD	HL,DE		;bump sector pointer to next track.
1850  E7FF DA 0F E8     	JP	C,TRKSEC4
1851  E802 79           	LD	A,C		;is desired sector now before current one?
1852  E803 95           	SUB	L
1853  E804 78           	LD	A,B
1854  E805 9C           	SBC	A,H
1855  E806 DA 0F E8     	JP	C,TRKSEC4
1856  E809 EB           	EX	DE,HL		;not yes, increment track counter
1857  E80A E1           	POP	HL		;and continue until it is.
1858  E80B 23           	INC	HL
1859  E80C C3 FA E7     	JP	TRKSEC3
1860  E80F              ;
1861  E80F              ;   here we have determined the track number that contains the
1862  E80F              ; desired sector.
1863  E80F              ;
1864  E80F E1           TRKSEC4:POP	HL		;get track number (HL).
1865  E810 C5           	PUSH	BC
1866  E811 D5           	PUSH	DE
1867  E812 E5           	PUSH	HL
1868  E813 EB           	EX	DE,HL
1869  E814 2A CE F1     	LD	HL,(OFFSET)	;adjust for first track offset.
1870  E817 19           	ADD	HL,DE
1871  E818 44           	LD	B,H
1872  E819 4D           	LD	C,L
1873  E81A CD 1E F2     	CALL	SETTRK		;select this track.
1874  E81D D1           	POP	DE		;reset current track pointer.
1875  E81E 2A B5 F1     	LD	HL,(SCRATCH2)
1876  E821 73           	LD	(HL),E
1877  E822 23           	INC	HL
1878  E823 72           	LD	(HL),D
1879  E824 D1           	POP	DE
1880  E825 2A B7 F1     	LD	HL,(SCRATCH3)	;reset the first sector on this track.
1881  E828 73           	LD	(HL),E
1882  E829 23           	INC	HL
1883  E82A 72           	LD	(HL),D
1884  E82B C1           	POP	BC
1885  E82C 79           	LD	A,C		;now subtract the desired one.
1886  E82D 93           	SUB	E		;to make it relative (1-# sectors/track).
1887  E82E 4F           	LD	C,A
1888  E82F 78           	LD	A,B
1889  E830 9A           	SBC	A,D
1890  E831 47           	LD	B,A
1891  E832 2A D0 F1     	LD	HL,(XLATE)	;translate this sector according to this table.
1892  E835 EB           	EX	DE,HL
1893  E836 CD 30 F2     	CALL	SECTRN		;let the bios translate it.
1894  E839 4D           	LD	C,L
1895  E83A 44           	LD	B,H
1896  E83B C3 21 F2     	JP	SETSEC		;and select it.
1897  E83E              ;
1898  E83E              ;   Compute block number from record number (SAVNREC) and
1899  E83E              ; extent number (SAVEXT).
1900  E83E              ;
1901  E83E 21 C3 F1     GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
1902  E841 4E           	LD	C,(HL)		;note that this is base 2 log of ratio.
1903  E842 3A E3 F1     	LD	A,(SAVNREC)	;get record number.
1904  E845 B7           GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
1905  E846 1F           	RRA
1906  E847 0D           	DEC	C
1907  E848 C2 45 E8     	JP	NZ,GETBLK1
1908  E84B 47           	LD	B,A		;save result in (B).
1909  E84C 3E 08        	LD	A,8
1910  E84E 96           	SUB	(HL)
1911  E84F 4F           	LD	C,A		;compute (C)=8-BLKSHFT.
1912  E850 3A E2 F1     	LD	A,(SAVEXT)
1913  E853 0D           GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
1914  E854 CA 5C E8     	JP	Z,GETBLK3
1915  E857 B7           	OR	A
1916  E858 17           	RLA
1917  E859 C3 53 E8     	JP	GETBLK2
1918  E85C 80           GETBLK3:ADD	A,B
1919  E85D C9           	RET
1920  E85E              ;
1921  E85E              ;   Routine to extract the (BC) block byte from the fcb pointed
1922  E85E              ; to by (PARAMS). If this is a big-disk, then these are 16 bit
1923  E85E              ; block numbers, else they are 8 bit numbers.
1924  E85E              ; Number is returned in (HL).
1925  E85E              ;
1926  E85E 2A 43 E7     EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
1927  E861 11 10 00     	LD	DE,16		;block numbers start 16 bytes into fcb.
1928  E864 19           	ADD	HL,DE
1929  E865 09           	ADD	HL,BC
1930  E866 3A DD F1     	LD	A,(BIGDISK)	;are we using a big-disk?
1931  E869 B7           	OR	A
1932  E86A CA 71 E8     	JP	Z,EXTBLK1
1933  E86D 6E           	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
1934  E86E 26 00        	LD	H,0
1935  E870 C9           	RET
1936  E871 09           EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
1937  E872 5E           	LD	E,(HL)
1938  E873 23           	INC	HL
1939  E874 56           	LD	D,(HL)
1940  E875 EB           	EX	DE,HL		;return in (HL).
1941  E876 C9           	RET
1942  E877              ;
1943  E877              ;   Compute block number.
1944  E877              ;
1945  E877 CD 3E E8     COMBLK:	CALL	GETBLOCK
1946  E87A 4F           	LD	C,A
1947  E87B 06 00        	LD	B,0
1948  E87D CD 5E E8     	CALL	EXTBLK
1949  E880 22 E5 F1     	LD	(BLKNMBR),HL
1950  E883 C9           	RET
1951  E884              ;
1952  E884              ;   Check for a zero block number (unused).
1953  E884              ;
1954  E884 2A E5 F1     CHKBLK:	LD	HL,(BLKNMBR)
1955  E887 7D           	LD	A,L		;is it zero?
1956  E888 B4           	OR	H
1957  E889 C9           	RET
1958  E88A              ;
1959  E88A              ;   Adjust physical block (BLKNMBR) and convert to logical
1960  E88A              ; sector (LOGSECT). This is the starting sector of this block.
1961  E88A              ; The actual sector of interest is then added to this and the
1962  E88A              ; resulting sector number is stored back in (BLKNMBR). This
1963  E88A              ; will still have to be adjusted for the track number.
1964  E88A              ;
1965  E88A 3A C3 F1     LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
1966  E88D 2A E5 F1     	LD	HL,(BLKNMBR)	;get physical sector desired.
1967  E890 29           LOGICL1:ADD	HL,HL		;compute logical sector number.
1968  E891 3D           	DEC	A		;note logical sectors are 128 bytes long.
1969  E892 C2 90 E8     	JP	NZ,LOGICL1
1970  E895 22 E7 F1     	LD	(LOGSECT),HL	;save logical sector.
1971  E898 3A C4 F1     	LD	A,(BLKMASK)	;get block mask.
1972  E89B 4F           	LD	C,A
1973  E89C 3A E3 F1     	LD	A,(SAVNREC)	;get next sector to access.
1974  E89F A1           	AND	C		;extract the relative position within physical block.
1975  E8A0 B5           	OR	L		;and add it too logical sector.
1976  E8A1 6F           	LD	L,A
1977  E8A2 22 E5 F1     	LD	(BLKNMBR),HL	;and store.
1978  E8A5 C9           	RET
1979  E8A6              ;
1980  E8A6              ;   Set (HL) to point to extent byte in fcb.
1981  E8A6              ;
1982  E8A6 2A 43 E7     SETEXT:	LD	HL,(PARAMS)
1983  E8A9 11 0C 00     	LD	DE,12		;it is the twelth byte.
1984  E8AC 19           	ADD	HL,DE
1985  E8AD C9           	RET
1986  E8AE              ;
1987  E8AE              ;   Set (HL) to point to record count byte in fcb and (DE) to
1988  E8AE              ; next record number byte.
1989  E8AE              ;
1990  E8AE 2A 43 E7     SETHLDE:LD	HL,(PARAMS)
1991  E8B1 11 0F 00     	LD	DE,15		;record count byte (#15).
1992  E8B4 19           	ADD	HL,DE
1993  E8B5 EB           	EX	DE,HL
1994  E8B6 21 11 00     	LD	HL,17		;next record number (#32).
1995  E8B9 19           	ADD	HL,DE
1996  E8BA C9           	RET
1997  E8BB              ;
1998  E8BB              ;   Save current file data from fcb.
1999  E8BB              ;
2000  E8BB CD AE E8     STRDATA:CALL	SETHLDE
2001  E8BE 7E           	LD	A,(HL)		;get and store record count byte.
2002  E8BF 32 E3 F1     	LD	(SAVNREC),A
2003  E8C2 EB           	EX	DE,HL
2004  E8C3 7E           	LD	A,(HL)		;get and store next record number byte.
2005  E8C4 32 E1 F1     	LD	(SAVNXT),A
2006  E8C7 CD A6 E8     	CALL	SETEXT		;point to extent byte.
2007  E8CA 3A C5 F1     	LD	A,(EXTMASK)	;get extent mask.
2008  E8CD A6           	AND	(HL)
2009  E8CE 32 E2 F1     	LD	(SAVEXT),A	;and save extent here.
2010  E8D1 C9           	RET
2011  E8D2              ;
2012  E8D2              ;   Set the next record to access. If (MODE) is set to 2, then
2013  E8D2              ; the last record byte (SAVNREC) has the correct number to access.
2014  E8D2              ; For sequential access, (MODE) will be equal to 1.
2015  E8D2              ;
2016  E8D2 CD AE E8     SETNREC:CALL	SETHLDE
2017  E8D5 3A D5 F1     	LD	A,(MODE)	;get sequential flag (=1).
2018  E8D8 FE 02        	CP	2		;a 2 indicates that no adder is needed.
2019  E8DA C2 DE E8     	JP	NZ,STNREC1
2020  E8DD AF           	XOR	A		;clear adder (random access?).
2021  E8DE 4F           STNREC1:LD	C,A
2022  E8DF 3A E3 F1     	LD	A,(SAVNREC)	;get last record number.
2023  E8E2 81           	ADD	A,C		;increment record count.
2024  E8E3 77           	LD	(HL),A		;and set fcb's next record byte.
2025  E8E4 EB           	EX	DE,HL
2026  E8E5 3A E1 F1     	LD	A,(SAVNXT)	;get next record byte from storage.
2027  E8E8 77           	LD	(HL),A		;and put this into fcb as number of records used.
2028  E8E9 C9           	RET
2029  E8EA              ;
2030  E8EA              ;   Shift (HL) right (C) bits.
2031  E8EA              ;
2032  E8EA 0C           SHIFTR:	INC	C
2033  E8EB 0D           SHIFTR1:DEC	C
2034  E8EC C8           	RET	Z
2035  E8ED 7C           	LD	A,H
2036  E8EE B7           	OR	A
2037  E8EF 1F           	RRA
2038  E8F0 67           	LD	H,A
2039  E8F1 7D           	LD	A,L
2040  E8F2 1F           	RRA
2041  E8F3 6F           	LD	L,A
2042  E8F4 C3 EB E8     	JP	SHIFTR1
2043  E8F7
2044  E8F7              ;
2045  E8F7              ;   Compute the check-sum for the directory buffer. Return
2046  E8F7              ; integer sum in (A).
2047  E8F7              ;
2048  E8F7 0E 80        CHECKSUM: LD	C,128		;length of buffer.
2049  E8F9 2A B9 F1     	LD	HL,(DIRBUF)	;get its location.
2050  E8FC AF           	XOR	A		;clear summation byte.
2051  E8FD 86           CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
2052  E8FE 23           	INC	HL
2053  E8FF 0D           	DEC	C
2054  E900 C2 FD E8     	JP	NZ,CHKSUM1
2055  E903 C9           	RET
2056  E904              ;
2057  E904              ;   Shift (HL) left (C) bits.
2058  E904              ;
2059  E904 0C           SHIFTL:	INC	C
2060  E905 0D           SHIFTL1:DEC	C
2061  E906 C8           	RET	Z
2062  E907 29           	ADD	HL,HL		;shift left 1 bit.
2063  E908 C3 05 E9     	JP	SHIFTL1
2064  E90B              ;
2065  E90B              ;   Routine to set a bit in a 16 bit value contained in (BC).
2066  E90B              ; The bit set depends on the current drive selection.
2067  E90B              ;
2068  E90B C5           SETBIT:	PUSH	BC		;save 16 bit word.
2069  E90C 3A 42 E7     	LD	A,(ACTIVE)	;get active drive.
2070  E90F 4F           	LD	C,A
2071  E910 21 01 00     	LD	HL,1
2072  E913 CD 04 E9     	CALL	SHIFTL		;shift bit 0 into place.
2073  E916 C1           	POP	BC		;now 'or' this with the original word.
2074  E917 79           	LD	A,C
2075  E918 B5           	OR	L
2076  E919 6F           	LD	L,A		;low byte done, do high byte.
2077  E91A 78           	LD	A,B
2078  E91B B4           	OR	H
2079  E91C 67           	LD	H,A
2080  E91D C9           	RET
2081  E91E              ;
2082  E91E              ;   Extract the write protect status bit for the current drive.
2083  E91E              ; The result is returned in (A), bit 0.
2084  E91E              ;
2085  E91E 2A AD F1     GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
2086  E921 3A 42 E7     	LD	A,(ACTIVE)	;which drive is current?
2087  E924 4F           	LD	C,A
2088  E925 CD EA E8     	CALL	SHIFTR		;shift status such that bit 0 is the
2089  E928 7D           	LD	A,L		;one of interest for this drive.
2090  E929 E6 01        	AND	01H		;and isolate it.
2091  E92B C9           	RET
2092  E92C              ;
2093  E92C              ;   Function to write protect the current disk.
2094  E92C              ;
2095  E92C 21 AD F1     WRTPRTD:LD	HL,WRTPRT	;point to status word.
2096  E92F 4E           	LD	C,(HL)		;set (BC) equal to the status.
2097  E930 23           	INC	HL
2098  E931 46           	LD	B,(HL)
2099  E932 CD 0B E9     	CALL	SETBIT		;and set this bit according to current drive.
2100  E935 22 AD F1     	LD	(WRTPRT),HL	;then save.
2101  E938 2A C8 F1     	LD	HL,(DIRSIZE)	;now save directory size limit.
2102  E93B 23           	INC	HL		;remember the last one.
2103  E93C EB           	EX	DE,HL
2104  E93D 2A B3 F1     	LD	HL,(SCRATCH1)	;and store it here.
2105  E940 73           	LD	(HL),E		;put low byte.
2106  E941 23           	INC	HL
2107  E942 72           	LD	(HL),D		;then high byte.
2108  E943 C9           	RET
2109  E944              ;
2110  E944              ;   Check for a read only file.
2111  E944              ;
2112  E944 CD 5E E9     CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2113  E947 11 09 00     CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
2114  E94A 19           	ADD	HL,DE
2115  E94B 7E           	LD	A,(HL)
2116  E94C 17           	RLA
2117  E94D D0           	RET	NC		;return if ok.
2118  E94E 21 0F E4     	LD	HL,ROFILE	;else, print error message and terminate.
2119  E951 C3 4A E7     	JP	JUMPHL
2120  E954              ;
2121  E954              ;   Check the write protect status of the active disk.
2122  E954              ;
2123  E954 CD 1E E9     CHKWPRT:CALL	GETWPRT
2124  E957 C8           	RET	Z		;return if ok.
2125  E958 21 0D E4     	LD	HL,RODISK	;else print message and terminate.
2126  E95B C3 4A E7     	JP	JUMPHL
2127  E95E              ;
2128  E95E              ;   Routine to set (HL) pointing to the proper entry in the
2129  E95E              ; directory buffer.
2130  E95E              ;
2131  E95E 2A B9 F1     FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
2132  E961 3A E9 F1     	LD	A,(FCBPOS)	;relative position of file.
2133  E964              ;
2134  E964              ;   Routine to add (A) to (HL).
2135  E964              ;
2136  E964 85           ADDA2HL:ADD	A,L
2137  E965 6F           	LD	L,A
2138  E966 D0           	RET	NC
2139  E967 24           	INC	H		;take care of any carry.
2140  E968 C9           	RET
2141  E969              ;
2142  E969              ;   Routine to get the 's2' byte from the fcb supplied in
2143  E969              ; the initial parameter specification.
2144  E969              ;
2145  E969 2A 43 E7     GETS2:	LD	HL,(PARAMS)	;get address of fcb.
2146  E96C 11 0E 00     	LD	DE,14		;relative position of 's2'.
2147  E96F 19           	ADD	HL,DE
2148  E970 7E           	LD	A,(HL)		;extract this byte.
2149  E971 C9           	RET
2150  E972              ;
2151  E972              ;   Clear the 's2' byte in the fcb.
2152  E972              ;
2153  E972 CD 69 E9     CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
2154  E975 36 00        	LD	(HL),0		;now clear it.
2155  E977 C9           	RET
2156  E978              ;
2157  E978              ;   Set bit 7 in the 's2' byte of the fcb.
2158  E978              ;
2159  E978 CD 69 E9     SETS2B7:CALL	GETS2		;get the byte.
2160  E97B F6 80        	OR	80H		;and set bit 7.
2161  E97D 77           	LD	(HL),A		;then store.
2162  E97E C9           	RET
2163  E97F              ;
2164  E97F              ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2165  E97F              ; the difference. This checks to see if there are more file
2166  E97F              ; names in the directory. We are at (FILEPOS) and there are
2167  E97F              ; (SCRATCH1) of them to check.
2168  E97F              ;
2169  E97F 2A EA F1     MOREFLS:LD	HL,(FILEPOS)	;we are here.
2170  E982 EB           	EX	DE,HL
2171  E983 2A B3 F1     	LD	HL,(SCRATCH1)	;and don't go past here.
2172  E986 7B           	LD	A,E		;compute difference but don't keep.
2173  E987 96           	SUB	(HL)
2174  E988 23           	INC	HL
2175  E989 7A           	LD	A,D
2176  E98A 9E           	SBC	A,(hl)		;set carry if no more names.
2177  E98B C9           	RET
2178  E98C              ;
2179  E98C              ;   Call this routine to prevent (SCRATCH1) from being greater
2180  E98C              ; than (FILEPOS).
2181  E98C              ;
2182  E98C CD 7F E9     CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
2183  E98F D8           	RET	C
2184  E990 13           	INC	DE		;yes, reset it to (FILEPOS).
2185  E991 72           	LD	(HL),D
2186  E992 2B           	DEC	HL
2187  E993 73           	LD	(HL),E
2188  E994 C9           	RET
2189  E995              ;
2190  E995              ;   Compute (HL)=(DE)-(HL)
2191  E995              ;
2192  E995 7B           SUBHL:	LD	A,E		;compute difference.
2193  E996 95           	SUB	L
2194  E997 6F           	LD	L,A		;store low byte.
2195  E998 7A           	LD	A,D
2196  E999 9C           	SBC	A,H
2197  E99A 67           	LD	H,A		;and then high byte.
2198  E99B C9           	RET
2199  E99C              ;
2200  E99C              ;   Set the directory checksum byte.
2201  E99C              ;
2202  E99C 0E FF        SETDIR:	LD	C,0FFH
2203  E99E              ;
2204  E99E              ;   Routine to set or compare the directory checksum byte. If
2205  E99E              ; (C)=0ffh, then this will set the checksum byte. Else the byte
2206  E99E              ; will be checked. If the check fails (the disk has been changed),
2207  E99E              ; then this disk will be write protected.
2208  E99E              ;
2209  E99E 2A EC F1     CHECKDIR: LD	HL,(CKSUMTBL)
2210  E9A1 EB           	EX	DE,HL
2211  E9A2 2A CC F1     	LD	HL,(ALLOC1)
2212  E9A5 CD 95 E9     	CALL	SUBHL
2213  E9A8 D0           	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2214  E9A9 C5           	PUSH	BC
2215  E9AA CD F7 E8     	CALL	CHECKSUM	;else compute checksum.
2216  E9AD 2A BD F1     	LD	HL,(CHKVECT)	;get address of checksum table.
2217  E9B0 EB           	EX	DE,HL
2218  E9B1 2A EC F1     	LD	HL,(CKSUMTBL)
2219  E9B4 19           	ADD	HL,DE		;set (HL) to point to byte for this drive.
2220  E9B5 C1           	POP	BC
2221  E9B6 0C           	INC	C		;set or check ?
2222  E9B7 CA C4 E9     	JP	Z,CHKDIR1
2223  E9BA BE           	CP	(HL)		;check them.
2224  E9BB C8           	RET	Z		;return if they are the same.
2225  E9BC CD 7F E9     	CALL	MOREFLS		;not the same, do we care?
2226  E9BF D0           	RET	NC
2227  E9C0 CD 2C E9     	CALL	WRTPRTD		;yes, mark this as write protected.
2228  E9C3 C9           	RET
2229  E9C4 77           CHKDIR1:LD	(HL),A		;just set the byte.
2230  E9C5 C9           	RET
2231  E9C6              ;
2232  E9C6              ;   Do a write to the directory of the current disk.
2233  E9C6              ;
2234  E9C6 CD 9C E9     DIRWRITE: CALL	SETDIR		;set checksum byte.
2235  E9C9 CD E0 E9     	CALL	DIRDMA		;set directory dma address.
2236  E9CC 0E 01        	LD	C,1		;tell the bios to actually write.
2237  E9CE CD B8 E7     	CALL	DOWRITE		;then do the write.
2238  E9D1 C3 DA E9     	JP	DEFDMA
2239  E9D4              ;
2240  E9D4              ;   Read from the directory.
2241  E9D4              ;
2242  E9D4 CD E0 E9     DIRREAD:CALL	DIRDMA		;set the directory dma address.
2243  E9D7 CD B2 E7     	CALL	DOREAD		;and read it.
2244  E9DA              ;
2245  E9DA              ;   Routine to set the dma address to the users choice.
2246  E9DA              ;
2247  E9DA 21 B1 F1     DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
2248  E9DD C3 E3 E9     	JP	DIRDMA1
2249  E9E0              ;
2250  E9E0              ;   Routine to set the dma address for directory work.
2251  E9E0              ;
2252  E9E0 21 B9 F1     DIRDMA:	LD	HL,DIRBUF
2253  E9E3              ;
2254  E9E3              ;   Set the dma address. On entry, (HL) points to
2255  E9E3              ; word containing the desired dma address.
2256  E9E3              ;
2257  E9E3 4E           DIRDMA1:LD	C,(HL)
2258  E9E4 23           	INC	HL
2259  E9E5 46           	LD	B,(HL)		;setup (BC) and go to the bios to set it.
2260  E9E6 C3 24 F2     	JP	SETDMA
2261  E9E9              ;
2262  E9E9              ;   Move the directory buffer into user's dma space.
2263  E9E9              ;
2264  E9E9 2A B9 F1     MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
2265  E9EC EB           	EX	DE,HL
2266  E9ED 2A B1 F1     	LD	HL,(USERDMA)	; put it here.
2267  E9F0 0E 80        	LD	C,128		;this is its length.
2268  E9F2 C3 4F E7     	JP	DE2HL		;move it now and return.
2269  E9F5              ;
2270  E9F5              ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2271  E9F5              ;
2272  E9F5 21 EA F1     CKFILPOS: LD	HL,FILEPOS
2273  E9F8 7E           	LD	A,(HL)
2274  E9F9 23           	INC	HL
2275  E9FA BE           	CP	(HL)		;are both bytes the same?
2276  E9FB C0           	RET	NZ
2277  E9FC 3C           	INC	A		;yes, but are they each 0ffh?
2278  E9FD C9           	RET
2279  E9FE              ;
2280  E9FE              ;   Set location (FILEPOS) to 0ffffh.
2281  E9FE              ;
2282  E9FE 21 FF FF     STFILPOS: LD	HL,0FFFFH
2283  EA01 22 EA F1     	LD	(FILEPOS),HL
2284  EA04 C9           	RET
2285  EA05              ;
2286  EA05              ;   Move on to the next file position within the current
2287  EA05              ; directory buffer. If no more exist, set pointer to 0ffffh
2288  EA05              ; and the calling routine will check for this. Enter with (C)
2289  EA05              ; equal to 0ffh to cause the checksum byte to be set, else we
2290  EA05              ; will check this disk and set write protect if checksums are
2291  EA05              ; not the same (applies only if another directory sector must
2292  EA05              ; be read).
2293  EA05              ;
2294  EA05 2A C8 F1     NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
2295  EA08 EB           	EX	DE,HL
2296  EA09 2A EA F1     	LD	HL,(FILEPOS)	;get current count.
2297  EA0C 23           	INC	HL		;go on to the next one.
2298  EA0D 22 EA F1     	LD	(FILEPOS),HL
2299  EA10 CD 95 E9     	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2300  EA13 D2 19 EA     	JP	NC,NXENT1	;is there more room left?
2301  EA16 C3 FE E9     	JP	STFILPOS	;no. Set this flag and return.
2302  EA19 3A EA F1     NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
2303  EA1C E6 03        	AND	03H		;only look within this sector (only 4 entries fit).
2304  EA1E 06 05        	LD	B,5		;convert to relative position (32 bytes each).
2305  EA20 87           NXENT2:	ADD	A,A		;note that this is not efficient code.
2306  EA21 05           	DEC	B		;5 'ADD A's would be better.
2307  EA22 C2 20 EA     	JP	NZ,NXENT2
2308  EA25 32 E9 F1     	LD	(FCBPOS),A	;save it as position of fcb.
2309  EA28 B7           	OR	A
2310  EA29 C0           	RET	NZ		;return if we are within buffer.
2311  EA2A C5           	PUSH	BC
2312  EA2B CD C3 E7     	CALL	TRKSEC		;we need the next directory sector.
2313  EA2E CD D4 E9     	CALL	DIRREAD
2314  EA31 C1           	POP	BC
2315  EA32 C3 9E E9     	JP	CHECKDIR
2316  EA35              ;
2317  EA35              ;   Routine to to get a bit from the disk space allocation
2318  EA35              ; map. It is returned in (A), bit position 0. On entry to here,
2319  EA35              ; set (BC) to the block number on the disk to check.
2320  EA35              ; On return, (D) will contain the original bit position for
2321  EA35              ; this block number and (HL) will point to the address for it.
2322  EA35              ;
2323  EA35 79           CKBITMAP: LD	A,C		;determine bit number of interest.
2324  EA36 E6 07        	AND	07H		;compute (D)=(E)=(C and 7)+1.
2325  EA38 3C           	INC	A
2326  EA39 5F           	LD	E,A		;save particular bit number.
2327  EA3A 57           	LD	D,A
2328  EA3B              ;
2329  EA3B              ;   compute (BC)=(BC)/8.
2330  EA3B              ;
2331  EA3B 79           	LD	A,C
2332  EA3C 0F           	RRCA			;now shift right 3 bits.
2333  EA3D 0F           	RRCA
2334  EA3E 0F           	RRCA
2335  EA3F E6 1F        	AND	1FH		;and clear bits 7,6,5.
2336  EA41 4F           	LD	C,A
2337  EA42 78           	LD	A,B
2338  EA43 87           	ADD	A,A		;now shift (B) into bits 7,6,5.
2339  EA44 87           	ADD	A,A
2340  EA45 87           	ADD	A,A
2341  EA46 87           	ADD	A,A
2342  EA47 87           	ADD	A,A
2343  EA48 B1           	OR	C		;and add in (C).
2344  EA49 4F           	LD	C,A		;ok, (C) ha been completed.
2345  EA4A 78           	LD	A,B		;is there a better way of doing this?
2346  EA4B 0F           	RRCA
2347  EA4C 0F           	RRCA
2348  EA4D 0F           	RRCA
2349  EA4E E6 1F        	AND	1FH
2350  EA50 47           	LD	B,A		;and now (B) is completed.
2351  EA51              ;
2352  EA51              ;   use this as an offset into the disk space allocation
2353  EA51              ; table.
2354  EA51              ;
2355  EA51 2A BF F1     	LD	HL,(ALOCVECT)
2356  EA54 09           	ADD	HL,BC
2357  EA55 7E           	LD	A,(HL)		;now get correct byte.
2358  EA56 07           CKBMAP1:RLCA			;get correct bit into position 0.
2359  EA57 1D           	DEC	E
2360  EA58 C2 56 EA     	JP	NZ,CKBMAP1
2361  EA5B C9           	RET
2362  EA5C              ;
2363  EA5C              ;   Set or clear the bit map such that block number (BC) will be marked
2364  EA5C              ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2365  EA5C              ; 1 then it will be set (don't use anyother values).
2366  EA5C              ;
2367  EA5C D5           STBITMAP: PUSH	DE
2368  EA5D CD 35 EA     	CALL	CKBITMAP	;get the byte of interest.
2369  EA60 E6 FE        	AND	0FEH		;clear the affected bit.
2370  EA62 C1           	POP	BC
2371  EA63 B1           	OR	C		;and now set it acording to (C).
2372  EA64              ;
2373  EA64              ;  entry to restore the original bit position and then store
2374  EA64              ; in table. (A) contains the value, (D) contains the bit
2375  EA64              ; position (1-8), and (HL) points to the address within the
2376  EA64              ; space allocation table for this byte.
2377  EA64              ;
2378  EA64 0F           STBMAP1:RRCA			;restore original bit position.
2379  EA65 15           	DEC	D
2380  EA66 C2 64 EA     	JP	NZ,STBMAP1
2381  EA69 77           	LD	(HL),A		;and stor byte in table.
2382  EA6A C9           	RET
2383  EA6B              ;
2384  EA6B              ;   Set/clear space used bits in allocation map for this file.
2385  EA6B              ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2386  EA6B              ;
2387  EA6B CD 5E E9     SETFILE:CALL	FCB2HL		;get address of fcb
2388  EA6E 11 10 00     	LD	DE,16
2389  EA71 19           	ADD	HL,DE		;get to block number bytes.
2390  EA72 C5           	PUSH	BC
2391  EA73 0E 11        	LD	C,17		;check all 17 bytes (max) of table.
2392  EA75 D1           SETFL1:	POP	DE
2393  EA76 0D           	DEC	C		;done all bytes yet?
2394  EA77 C8           	RET	Z
2395  EA78 D5           	PUSH	DE
2396  EA79 3A DD F1     	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2397  EA7C B7           	OR	A
2398  EA7D CA 88 EA     	JP	Z,SETFL2
2399  EA80 C5           	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
2400  EA81 E5           	PUSH	HL
2401  EA82 4E           	LD	C,(HL)		;get low byte from table, always
2402  EA83 06 00        	LD	B,0		;set high byte to zero.
2403  EA85 C3 8E EA     	JP	SETFL3
2404  EA88 0D           SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
2405  EA89 C5           	PUSH	BC
2406  EA8A 4E           	LD	C,(HL)		;now get both the low and high bytes.
2407  EA8B 23           	INC	HL
2408  EA8C 46           	LD	B,(HL)
2409  EA8D E5           	PUSH	HL
2410  EA8E 79           SETFL3:	LD	A,C		;block used?
2411  EA8F B0           	OR	B
2412  EA90 CA 9D EA     	JP	Z,SETFL4
2413  EA93 2A C6 F1     	LD	HL,(DSKSIZE)	;is this block number within the
2414  EA96 7D           	LD	A,L		;space on the disk?
2415  EA97 91           	SUB	C
2416  EA98 7C           	LD	A,H
2417  EA99 98           	SBC	A,B
2418  EA9A D4 5C EA     	CALL	NC,STBITMAP	;yes, set the proper bit.
2419  EA9D E1           SETFL4:	POP	HL		;point to next block number in fcb.
2420  EA9E 23           	INC	HL
2421  EA9F C1           	POP	BC
2422  EAA0 C3 75 EA     	JP	SETFL1
2423  EAA3              ;
2424  EAA3              ;   Construct the space used allocation bit map for the active
2425  EAA3              ; drive. If a file name starts with '$' and it is under the
2426  EAA3              ; current user number, then (STATUS) is set to minus 1. Otherwise
2427  EAA3              ; it is not set at all.
2428  EAA3              ;
2429  EAA3 2A C6 F1     BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
2430  EAA6 0E 03        	LD	C,3
2431  EAA8 CD EA E8     	CALL	SHIFTR		;(HL)=(HL)/8.
2432  EAAB 23           	INC	HL		;at lease 1 byte.
2433  EAAC 44           	LD	B,H
2434  EAAD 4D           	LD	C,L		;set (BC) to the allocation table length.
2435  EAAE              ;
2436  EAAE              ;   Initialize the bitmap for this drive. Right now, the first
2437  EAAE              ; two bytes are specified by the disk parameter block. However
2438  EAAE              ; a patch could be entered here if it were necessary to setup
2439  EAAE              ; this table in a special mannor. For example, the bios could
2440  EAAE              ; determine locations of 'bad blocks' and set them as already
2441  EAAE              ; 'used' in the map.
2442  EAAE              ;
2443  EAAE 2A BF F1     	LD	HL,(ALOCVECT)	;now zero out the table now.
2444  EAB1 36 00        BITMAP1:LD	(HL),0
2445  EAB3 23           	INC	HL
2446  EAB4 0B           	DEC	BC
2447  EAB5 78           	LD	A,B
2448  EAB6 B1           	OR	C
2449  EAB7 C2 B1 EA     	JP	NZ,BITMAP1
2450  EABA 2A CA F1     	LD	HL,(ALLOC0)	;get initial space used by directory.
2451  EABD EB           	EX	DE,HL
2452  EABE 2A BF F1     	LD	HL,(ALOCVECT)	;and put this into map.
2453  EAC1 73           	LD	(HL),E
2454  EAC2 23           	INC	HL
2455  EAC3 72           	LD	(HL),D
2456  EAC4              ;
2457  EAC4              ;   End of initialization portion.
2458  EAC4              ;
2459  EAC4 CD A1 E7     	CALL	HOMEDRV		;now home the drive.
2460  EAC7 2A B3 F1     	LD	HL,(SCRATCH1)
2461  EACA 36 03        	LD	(HL),3		;force next directory request to read
2462  EACC 23           	INC	HL		;in a sector.
2463  EACD 36 00        	LD	(HL),0
2464  EACF CD FE E9     	CALL	STFILPOS	;clear initial file position also.
2465  EAD2 0E FF        BITMAP2:LD	C,0FFH		;read next file name in directory
2466  EAD4 CD 05 EA     	CALL	NXENTRY		;and set checksum byte.
2467  EAD7 CD F5 E9     	CALL	CKFILPOS	;is there another file?
2468  EADA C8           	RET	Z
2469  EADB CD 5E E9     	CALL	FCB2HL		;yes, get its address.
2470  EADE 3E E5        	LD	A,0E5H
2471  EAE0 BE           	CP	(HL)		;empty file entry?
2472  EAE1 CA D2 EA     	JP	Z,BITMAP2
2473  EAE4 3A 41 E7     	LD	A,(USERNO)	;no, correct user number?
2474  EAE7 BE           	CP	(HL)
2475  EAE8 C2 F6 EA     	JP	NZ,BITMAP3
2476  EAEB 23           	INC	HL
2477  EAEC 7E           	LD	A,(HL)		;yes, does name start with a '$'?
2478  EAED D6 24        	SUB	'$'
2479  EAEF C2 F6 EA     	JP	NZ,BITMAP3
2480  EAF2 3D           	DEC	A		;yes, set atatus to minus one.
2481  EAF3 32 45 E7     	LD	(STATUS),A
2482  EAF6 0E 01        BITMAP3:LD	C,1		;now set this file's space as used in bit map.
2483  EAF8 CD 6B EA     	CALL	SETFILE
2484  EAFB CD 8C E9     	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2485  EAFE C3 D2 EA     	JP	BITMAP2
2486  EB01              ;
2487  EB01              ;   Set the status (STATUS) and return.
2488  EB01              ;
2489  EB01 3A D4 F1     STSTATUS: LD	A,(FNDSTAT)
2490  EB04 C3 01 E7     	JP	SETSTAT
2491  EB07              ;
2492  EB07              ;   Check extents in (A) and (C). Set the zero flag if they
2493  EB07              ; are the same. The number of 16k chunks of disk space that
2494  EB07              ; the directory extent covers is expressad is (EXTMASK+1).
2495  EB07              ; No registers are modified.
2496  EB07              ;
2497  EB07 C5           SAMEXT:	PUSH	BC
2498  EB08 F5           	PUSH	AF
2499  EB09 3A C5 F1     	LD	A,(EXTMASK)	;get extent mask and use it to
2500  EB0C 2F           	CPL			;to compare both extent numbers.
2501  EB0D 47           	LD	B,A		;save resulting mask here.
2502  EB0E 79           	LD	A,C		;mask first extent and save in (C).
2503  EB0F A0           	AND	B
2504  EB10 4F           	LD	C,A
2505  EB11 F1           	POP	AF		;now mask second extent and compare
2506  EB12 A0           	AND	B		;with the first one.
2507  EB13 91           	SUB	C
2508  EB14 E6 1F        	AND	1FH		;(* only check buts 0-4 *)
2509  EB16 C1           	POP	BC		;the zero flag is set if they are the same.
2510  EB17 C9           	RET			;restore (BC) and return.
2511  EB18              ;
2512  EB18              ;   Search for the first occurence of a file name. On entry,
2513  EB18              ; register (C) should contain the number of bytes of the fcb
2514  EB18              ; that must match.
2515  EB18              ;
2516  EB18 3E FF        FINDFST:LD	A,0FFH
2517  EB1A 32 D4 F1     	LD	(FNDSTAT),A
2518  EB1D 21 D8 F1     	LD	HL,COUNTER	;save character count.
2519  EB20 71           	LD	(HL),C
2520  EB21 2A 43 E7     	LD	HL,(PARAMS)	;get filename to match.
2521  EB24 22 D9 F1     	LD	(SAVEFCB),HL	;and save.
2522  EB27 CD FE E9     	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
2523  EB2A CD A1 E7     	CALL	HOMEDRV		;home the drive.
2524  EB2D              ;
2525  EB2D              ;   Entry to locate the next occurence of a filename within the
2526  EB2D              ; directory. The disk is not expected to have been changed. If
2527  EB2D              ; it was, then it will be write protected.
2528  EB2D              ;
2529  EB2D 0E 00        FINDNXT:LD	C,0		;write protect the disk if changed.
2530  EB2F CD 05 EA     	CALL	NXENTRY		;get next filename entry in directory.
2531  EB32 CD F5 E9     	CALL	CKFILPOS	;is file position = 0ffffh?
2532  EB35 CA 94 EB     	JP	Z,FNDNXT6	;yes, exit now then.
2533  EB38 2A D9 F1     	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
2534  EB3B EB           	EX	DE,HL
2535  EB3C 1A           	LD	A,(DE)
2536  EB3D FE E5        	CP	0E5H		;empty directory entry?
2537  EB3F CA 4A EB     	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
2538  EB42 D5           	PUSH	DE
2539  EB43 CD 7F E9     	CALL	MOREFLS		;more files in directory?
2540  EB46 D1           	POP	DE
2541  EB47 D2 94 EB     	JP	NC,FNDNXT6	;no more. Exit now.
2542  EB4A CD 5E E9     FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
2543  EB4D 3A D8 F1     	LD	A,(COUNTER)	;get number of bytes (characters) to check.
2544  EB50 4F           	LD	C,A
2545  EB51 06 00        	LD	B,0		;initialize byte position counter.
2546  EB53 79           FNDNXT2:LD	A,C		;are we done with the compare?
2547  EB54 B7           	OR	A
2548  EB55 CA 83 EB     	JP	Z,FNDNXT5
2549  EB58 1A           	LD	A,(DE)		;no, check next byte.
2550  EB59 FE 3F        	CP	'?'		;don't care about this character?
2551  EB5B CA 7C EB     	JP	Z,FNDNXT4
2552  EB5E 78           	LD	A,B		;get bytes position in fcb.
2553  EB5F FE 0D        	CP	13		;don't care about the thirteenth byte either.
2554  EB61 CA 7C EB     	JP	Z,FNDNXT4
2555  EB64 FE 0C        	CP	12		;extent byte?
2556  EB66 1A           	LD	A,(DE)
2557  EB67 CA 73 EB     	JP	Z,FNDNXT3
2558  EB6A 96           	SUB	(HL)		;otherwise compare characters.
2559  EB6B E6 7F        	AND	7FH
2560  EB6D C2 2D EB     	JP	NZ,FINDNXT	;not the same, check next entry.
2561  EB70 C3 7C EB     	JP	FNDNXT4		;so far so good, keep checking.
2562  EB73 C5           FNDNXT3:PUSH	BC		;check the extent byte here.
2563  EB74 4E           	LD	C,(HL)
2564  EB75 CD 07 EB     	CALL	SAMEXT
2565  EB78 C1           	POP	BC
2566  EB79 C2 2D EB     	JP	NZ,FINDNXT	;not the same, look some more.
2567  EB7C              ;
2568  EB7C              ;   So far the names compare. Bump pointers to the next byte
2569  EB7C              ; and continue until all (C) characters have been checked.
2570  EB7C              ;
2571  EB7C 13           FNDNXT4:INC	DE		;bump pointers.
2572  EB7D 23           	INC	HL
2573  EB7E 04           	INC	B
2574  EB7F 0D           	DEC	C		;adjust character counter.
2575  EB80 C3 53 EB     	JP	FNDNXT2
2576  EB83 3A EA F1     FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
2577  EB86 E6 03        	AND	03H
2578  EB88 32 45 E7     	LD	(STATUS),A
2579  EB8B 21 D4 F1     	LD	HL,FNDSTAT
2580  EB8E 7E           	LD	A,(HL)
2581  EB8F 17           	RLA
2582  EB90 D0           	RET	NC
2583  EB91 AF           	XOR	A
2584  EB92 77           	LD	(HL),A
2585  EB93 C9           	RET
2586  EB94              ;
2587  EB94              ;   Filename was not found. Set appropriate status.
2588  EB94              ;
2589  EB94 CD FE E9     FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
2590  EB97 3E FF        	LD	A,0FFH		;say not located.
2591  EB99 C3 01 E7     	JP	SETSTAT
2592  EB9C              ;
2593  EB9C              ;   Erase files from the directory. Only the first byte of the
2594  EB9C              ; fcb will be affected. It is set to (E5).
2595  EB9C              ;
2596  EB9C CD 54 E9     ERAFILE:CALL	CHKWPRT		;is disk write protected?
2597  EB9F 0E 0C        	LD	C,12		;only compare file names.
2598  EBA1 CD 18 EB     	CALL	FINDFST		;get first file name.
2599  EBA4 CD F5 E9     ERAFIL1:CALL	CKFILPOS	;any found?
2600  EBA7 C8           	RET	Z		;nope, we must be done.
2601  EBA8 CD 44 E9     	CALL	CHKROFL		;is file read only?
2602  EBAB CD 5E E9     	CALL	FCB2HL		;nope, get address of fcb and
2603  EBAE 36 E5        	LD	(HL),0E5H	;set first byte to 'empty'.
2604  EBB0 0E 00        	LD	C,0		;clear the space from the bit map.
2605  EBB2 CD 6B EA     	CALL	SETFILE
2606  EBB5 CD C6 E9     	CALL	DIRWRITE	;now write the directory sector back out.
2607  EBB8 CD 2D EB     	CALL	FINDNXT		;find the next file name.
2608  EBBB C3 A4 EB     	JP	ERAFIL1		;and repeat process.
2609  EBBE              ;
2610  EBBE              ;   Look through the space allocation map (bit map) for the
2611  EBBE              ; next available block. Start searching at block number (BC-1).
2612  EBBE              ; The search procedure is to look for an empty block that is
2613  EBBE              ; before the starting block. If not empty, look at a later
2614  EBBE              ; block number. In this way, we return the closest empty block
2615  EBBE              ; on either side of the 'target' block number. This will speed
2616  EBBE              ; access on random devices. For serial devices, this should be
2617  EBBE              ; changed to look in the forward direction first and then start
2618  EBBE              ; at the front and search some more.
2619  EBBE              ;
2620  EBBE              ;   On return, (DE)= block number that is empty and (HL) =0
2621  EBBE              ; if no empry block was found.
2622  EBBE              ;
2623  EBBE 50           FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
2624  EBBF 59           	LD	E,C
2625  EBC0              ;
2626  EBC0              ;   Look before target block. Registers (BC) are used as the lower
2627  EBC0              ; pointer and (DE) as the upper pointer.
2628  EBC0              ;
2629  EBC0 79           FNDSPA1:LD	A,C		;is block 0 specified?
2630  EBC1 B0           	OR	B
2631  EBC2 CA D1 EB     	JP	Z,FNDSPA2
2632  EBC5 0B           	DEC	BC		;nope, check previous block.
2633  EBC6 D5           	PUSH	DE
2634  EBC7 C5           	PUSH	BC
2635  EBC8 CD 35 EA     	CALL	CKBITMAP
2636  EBCB 1F           	RRA			;is this block empty?
2637  EBCC D2 EC EB     	JP	NC,FNDSPA3	;yes. use this.
2638  EBCF              ;
2639  EBCF              ;   Note that the above logic gets the first block that it finds
2640  EBCF              ; that is empty. Thus a file could be written 'backward' making
2641  EBCF              ; it very slow to access. This could be changed to look for the
2642  EBCF              ; first empty block and then continue until the start of this
2643  EBCF              ; empty space is located and then used that starting block.
2644  EBCF              ; This should help speed up access to some files especially on
2645  EBCF              ; a well used disk with lots of fairly small 'holes'.
2646  EBCF              ;
2647  EBCF C1           	POP	BC		;nope, check some more.
2648  EBD0 D1           	POP	DE
2649  EBD1              ;
2650  EBD1              ;   Now look after target block.
2651  EBD1              ;
2652  EBD1 2A C6 F1     FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
2653  EBD4 7B           	LD	A,E
2654  EBD5 95           	SUB	L
2655  EBD6 7A           	LD	A,D
2656  EBD7 9C           	SBC	A,H
2657  EBD8 D2 F4 EB     	JP	NC,FNDSPA4
2658  EBDB 13           	INC	DE		;yes, move on to next one.
2659  EBDC C5           	PUSH	BC
2660  EBDD D5           	PUSH	DE
2661  EBDE 42           	LD	B,D
2662  EBDF 4B           	LD	C,E
2663  EBE0 CD 35 EA     	CALL	CKBITMAP	;check it.
2664  EBE3 1F           	RRA			;empty?
2665  EBE4 D2 EC EB     	JP	NC,FNDSPA3
2666  EBE7 D1           	POP	DE		;nope, continue searching.
2667  EBE8 C1           	POP	BC
2668  EBE9 C3 C0 EB     	JP	FNDSPA1
2669  EBEC              ;
2670  EBEC              ;   Empty block found. Set it as used and return with (HL)
2671  EBEC              ; pointing to it (true?).
2672  EBEC              ;
2673  EBEC 17           FNDSPA3:RLA			;reset byte.
2674  EBED 3C           	INC	A		;and set bit 0.
2675  EBEE CD 64 EA     	CALL	STBMAP1		;update bit map.
2676  EBF1 E1           	POP	HL		;set return registers.
2677  EBF2 D1           	POP	DE
2678  EBF3 C9           	RET
2679  EBF4              ;
2680  EBF4              ;   Free block was not found. If (BC) is not zero, then we have
2681  EBF4              ; not checked all of the disk space.
2682  EBF4              ;
2683  EBF4 79           FNDSPA4:LD	A,C
2684  EBF5 B0           	OR	B
2685  EBF6 C2 C0 EB     	JP	NZ,FNDSPA1
2686  EBF9 21 00 00     	LD	HL,0		;set 'not found' status.
2687  EBFC C9           	RET
2688  EBFD              ;
2689  EBFD              ;   Move a complete fcb entry into the directory and write it.
2690  EBFD              ;
2691  EBFD 0E 00        FCBSET:	LD	C,0
2692  EBFF 1E 20        	LD	E,32		;length of each entry.
2693  EC01              ;
2694  EC01              ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2695  EC01              ; fcb in directory starting at relative byte (C). This updated
2696  EC01              ; directory buffer is then written to the disk.
2697  EC01              ;
2698  EC01 D5           UPDATE:	PUSH	DE
2699  EC02 06 00        	LD	B,0		;set (BC) to relative byte position.
2700  EC04 2A 43 E7     	LD	HL,(PARAMS)	;get address of fcb.
2701  EC07 09           	ADD	HL,BC		;compute starting byte.
2702  EC08 EB           	EX	DE,HL
2703  EC09 CD 5E E9     	CALL	FCB2HL		;get address of fcb to update in directory.
2704  EC0C C1           	POP	BC		;set (C) to number of bytes to change.
2705  EC0D CD 4F E7     	CALL	DE2HL
2706  EC10 CD C3 E7     UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
2707  EC13 C3 C6 E9     	JP	DIRWRITE	;then write this sector out.
2708  EC16              ;
2709  EC16              ;   Routine to change the name of all files on the disk with a
2710  EC16              ; specified name. The fcb contains the current name as the
2711  EC16              ; first 12 characters and the new name 16 bytes into the fcb.
2712  EC16              ;
2713  EC16 CD 54 E9     CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
2714  EC19 0E 0C        	LD	C,12		;match first 12 bytes of fcb only.
2715  EC1B CD 18 EB     	CALL	FINDFST		;get first name.
2716  EC1E 2A 43 E7     	LD	HL,(PARAMS)	;get address of fcb.
2717  EC21 7E           	LD	A,(HL)		;get user number.
2718  EC22 11 10 00     	LD	DE,16		;move over to desired name.
2719  EC25 19           	ADD	HL,DE
2720  EC26 77           	LD	(HL),A		;keep same user number.
2721  EC27 CD F5 E9     CHGNAM1:CALL	CKFILPOS	;any matching file found?
2722  EC2A C8           	RET	Z		;no, we must be done.
2723  EC2B CD 44 E9     	CALL	CHKROFL		;check for read only file.
2724  EC2E 0E 10        	LD	C,16		;start 16 bytes into fcb.
2725  EC30 1E 0C        	LD	E,12		;and update the first 12 bytes of directory.
2726  EC32 CD 01 EC     	CALL	UPDATE
2727  EC35 CD 2D EB     	CALL	FINDNXT		;get te next file name.
2728  EC38 C3 27 EC     	JP	CHGNAM1		;and continue.
2729  EC3B              ;
2730  EC3B              ;   Update a files attributes. The procedure is to search for
2731  EC3B              ; every file with the same name as shown in fcb (ignoring bit 7)
2732  EC3B              ; and then to update it (which includes bit 7). No other changes
2733  EC3B              ; are made.
2734  EC3B              ;
2735  EC3B 0E 0C        SAVEATTR: LD	C,12		;match first 12 bytes.
2736  EC3D CD 18 EB     	CALL	FINDFST		;look for first filename.
2737  EC40 CD F5 E9     SAVATR1:CALL	CKFILPOS	;was one found?
2738  EC43 C8           	RET	Z		;nope, we must be done.
2739  EC44 0E 00        	LD	C,0		;yes, update the first 12 bytes now.
2740  EC46 1E 0C        	LD	E,12
2741  EC48 CD 01 EC     	CALL	UPDATE		;update filename and write directory.
2742  EC4B CD 2D EB     	CALL	FINDNXT		;and get the next file.
2743  EC4E C3 40 EC     	JP	SAVATR1		;then continue until done.
2744  EC51              ;
2745  EC51              ;  Open a file (name specified in fcb).
2746  EC51              ;
2747  EC51 0E 0F        OPENIT:	LD	C,15		;compare the first 15 bytes.
2748  EC53 CD 18 EB     	CALL	FINDFST		;get the first one in directory.
2749  EC56 CD F5 E9     	CALL	CKFILPOS	;any at all?
2750  EC59 C8           	RET	Z
2751  EC5A CD A6 E8     OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
2752  EC5D 7E           	LD	A,(HL)		;and get it.
2753  EC5E F5           	PUSH	AF		;save it and address.
2754  EC5F E5           	PUSH	HL
2755  EC60 CD 5E E9     	CALL	FCB2HL		;point to fcb in directory.
2756  EC63 EB           	EX	DE,HL
2757  EC64 2A 43 E7     	LD	HL,(PARAMS)	;this is the users copy.
2758  EC67 0E 20        	LD	C,32		;move it into users space.
2759  EC69 D5           	PUSH	DE
2760  EC6A CD 4F E7     	CALL	DE2HL
2761  EC6D CD 78 E9     	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
2762  EC70 D1           	POP	DE		;now get the extent byte from this fcb.
2763  EC71 21 0C 00     	LD	HL,12
2764  EC74 19           	ADD	HL,DE
2765  EC75 4E           	LD	C,(HL)		;into (C).
2766  EC76 21 0F 00     	LD	HL,15		;now get the record count byte into (B).
2767  EC79 19           	ADD	HL,DE
2768  EC7A 46           	LD	B,(HL)
2769  EC7B E1           	POP	HL		;keep the same extent as the user had originally.
2770  EC7C F1           	POP	AF
2771  EC7D 77           	LD	(HL),A
2772  EC7E 79           	LD	A,C		;is it the same as in the directory fcb?
2773  EC7F BE           	CP	(HL)
2774  EC80 78           	LD	A,B		;if yes, then use the same record count.
2775  EC81 CA 8B EC     	JP	Z,OPENIT2
2776  EC84 3E 00        	LD	A,0		;if the user specified an extent greater than
2777  EC86 DA 8B EC     	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
2778  EC89 3E 80        	LD	A,128		;otherwise set to maximum.
2779  EC8B 2A 43 E7     OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
2780  EC8E 11 0F 00     	LD	DE,15
2781  EC91 19           	ADD	HL,DE		;compute relative position.
2782  EC92 77           	LD	(HL),A		;and set the record count.
2783  EC93 C9           	RET
2784  EC94              ;
2785  EC94              ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2786  EC94              ; point to a zero value (16 bit).
2787  EC94              ;   Return with zero flag set it (DE) was moved. Registers (DE)
2788  EC94              ; and (HL) are not changed. However (A) is.
2789  EC94              ;
2790  EC94 7E           MOVEWORD: LD	A,(HL)		;check for a zero word.
2791  EC95 23           	INC	HL
2792  EC96 B6           	OR	(HL)		;both bytes zero?
2793  EC97 2B           	DEC	HL
2794  EC98 C0           	RET	NZ		;nope, just return.
2795  EC99 1A           	LD	A,(DE)		;yes, move two bytes from (DE) into
2796  EC9A 77           	LD	(HL),A		;this zero space.
2797  EC9B 13           	INC	DE
2798  EC9C 23           	INC	HL
2799  EC9D 1A           	LD	A,(DE)
2800  EC9E 77           	LD	(HL),A
2801  EC9F 1B           	DEC	DE		;don't disturb these registers.
2802  ECA0 2B           	DEC	HL
2803  ECA1 C9           	RET
2804  ECA2              ;
2805  ECA2              ;   Get here to close a file specified by (fcb).
2806  ECA2              ;
2807  ECA2 AF           CLOSEIT:XOR	A		;clear status and file position bytes.
2808  ECA3 32 45 E7     	LD	(STATUS),A
2809  ECA6 32 EA F1     	LD	(FILEPOS),A
2810  ECA9 32 EB F1     	LD	(FILEPOS+1),A
2811  ECAC CD 1E E9     	CALL	GETWPRT		;get write protect bit for this drive.
2812  ECAF C0           	RET	NZ		;just return if it is set.
2813  ECB0 CD 69 E9     	CALL	GETS2		;else get the 's2' byte.
2814  ECB3 E6 80        	AND	80H		;and look at bit 7 (file unmodified?).
2815  ECB5 C0           	RET	NZ		;just return if set.
2816  ECB6 0E 0F        	LD	C,15		;else look up this file in directory.
2817  ECB8 CD 18 EB     	CALL	FINDFST
2818  ECBB CD F5 E9     	CALL	CKFILPOS	;was it found?
2819  ECBE C8           	RET	Z		;just return if not.
2820  ECBF 01 10 00     	LD	BC,16		;set (HL) pointing to records used section.
2821  ECC2 CD 5E E9     	CALL	FCB2HL
2822  ECC5 09           	ADD	HL,BC
2823  ECC6 EB           	EX	DE,HL
2824  ECC7 2A 43 E7     	LD	HL,(PARAMS)	;do the same for users specified fcb.
2825  ECCA 09           	ADD	HL,BC
2826  ECCB 0E 10        	LD	C,16		;this many bytes are present in this extent.
2827  ECCD 3A DD F1     CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
2828  ECD0 B7           	OR	A
2829  ECD1 CA E8 EC     	JP	Z,CLOSEIT4
2830  ECD4 7E           	LD	A,(HL)		;just 8 bit. Get one from users fcb.
2831  ECD5 B7           	OR	A
2832  ECD6 1A           	LD	A,(DE)		;now get one from directory fcb.
2833  ECD7 C2 DB EC     	JP	NZ,CLOSEIT2
2834  ECDA 77           	LD	(HL),A		;users byte was zero. Update from directory.
2835  ECDB B7           CLOSEIT2: OR	A
2836  ECDC C2 E1 EC     	JP	NZ,CLOSEIT3
2837  ECDF 7E           	LD	A,(HL)		;directories byte was zero, update from users fcb.
2838  ECE0 12           	LD	(DE),A
2839  ECE1 BE           CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
2840  ECE2 C2 1F ED     	JP	NZ,CLOSEIT7	;then close error if they are not the same.
2841  ECE5 C3 FD EC     	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
2842  ECE8 CD 94 EC     CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
2843  ECEB EB           	EX	DE,HL
2844  ECEC CD 94 EC     	CALL	MOVEWORD	;update directories fcb if it is zero.
2845  ECEF EB           	EX	DE,HL
2846  ECF0 1A           	LD	A,(DE)		;if these two values are no different,
2847  ECF1 BE           	CP	(HL)		;then a close error occured.
2848  ECF2 C2 1F ED     	JP	NZ,CLOSEIT7
2849  ECF5 13           	INC	DE		;check second byte.
2850  ECF6 23           	INC	HL
2851  ECF7 1A           	LD	A,(DE)
2852  ECF8 BE           	CP	(HL)
2853  ECF9 C2 1F ED     	JP	NZ,CLOSEIT7
2854  ECFC 0D           	DEC	C		;remember 16 bit values.
2855  ECFD 13           CLOSEIT5: INC	DE		;bump to next item in table.
2856  ECFE 23           	INC	HL
2857  ECFF 0D           	DEC	C		;there are 16 entries only.
2858  ED00 C2 CD EC     	JP	NZ,CLOSEIT1	;continue if more to do.
2859  ED03 01 EC FF     	LD	BC,0FFECH	;backup 20 places (extent byte).
2860  ED06 09           	ADD	HL,BC
2861  ED07 EB           	EX	DE,HL
2862  ED08 09           	ADD	HL,BC
2863  ED09 1A           	LD	A,(DE)
2864  ED0A BE           	CP	(HL)		;directory's extent already greater than the
2865  ED0B DA 17 ED     	JP	C,CLOSEIT6	;users extent?
2866  ED0E 77           	LD	(HL),A		;no, update directory extent.
2867  ED0F 01 03 00     	LD	BC,3		;and update the record count byte in
2868  ED12 09           	ADD	HL,BC		;directories fcb.
2869  ED13 EB           	EX	DE,HL
2870  ED14 09           	ADD	HL,BC
2871  ED15 7E           	LD	A,(HL)		;get from user.
2872  ED16 12           	LD	(DE),A		;and put in directory.
2873  ED17 3E FF        CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
2874  ED19 32 D2 F1     	LD	(CLOSEFLG),A
2875  ED1C C3 10 EC     	JP	UPDATE1		;update the directory now.
2876  ED1F 21 45 E7     CLOSEIT7: LD	HL,STATUS	;set return status and then return.
2877  ED22 35           	DEC	(HL)
2878  ED23 C9           	RET
2879  ED24              ;
2880  ED24              ;   Routine to get the next empty space in the directory. It
2881  ED24              ; will then be cleared for use.
2882  ED24              ;
2883  ED24 CD 54 E9     GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
2884  ED27 2A 43 E7     	LD	HL,(PARAMS)	;save current parameters (fcb).
2885  ED2A E5           	PUSH	HL
2886  ED2B 21 AC F1     	LD	HL,EMPTYFCB	;use special one for empty space.
2887  ED2E 22 43 E7     	LD	(PARAMS),HL
2888  ED31 0E 01        	LD	C,1		;search for first empty spot in directory.
2889  ED33 CD 18 EB     	CALL	FINDFST		;(* only check first byte *)
2890  ED36 CD F5 E9     	CALL	CKFILPOS	;none?
2891  ED39 E1           	POP	HL
2892  ED3A 22 43 E7     	LD	(PARAMS),HL	;restore original fcb address.
2893  ED3D C8           	RET	Z		;return if no more space.
2894  ED3E EB           	EX	DE,HL
2895  ED3F 21 0F 00     	LD	HL,15		;point to number of records for this file.
2896  ED42 19           	ADD	HL,DE
2897  ED43 0E 11        	LD	C,17		;and clear all of this space.
2898  ED45 AF           	XOR	A
2899  ED46 77           GETMT1:	LD	(HL),A
2900  ED47 23           	INC	HL
2901  ED48 0D           	DEC	C
2902  ED49 C2 46 ED     	JP	NZ,GETMT1
2903  ED4C 21 0D 00     	LD	HL,13		;clear the 's1' byte also.
2904  ED4F 19           	ADD	HL,DE
2905  ED50 77           	LD	(HL),A
2906  ED51 CD 8C E9     	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
2907  ED54 CD FD EB     	CALL	FCBSET		;write out this fcb entry to directory.
2908  ED57 C3 78 E9     	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
2909  ED5A              ;
2910  ED5A              ;   Routine to close the current extent and open the next one
2911  ED5A              ; for reading.
2912  ED5A              ;
2913  ED5A AF           GETNEXT:XOR	A
2914  ED5B 32 D2 F1     	LD	(CLOSEFLG),A	;clear close flag.
2915  ED5E CD A2 EC     	CALL	CLOSEIT		;close this extent.
2916  ED61 CD F5 E9     	CALL	CKFILPOS
2917  ED64 C8           	RET	Z		;not there???
2918  ED65 2A 43 E7     	LD	HL,(PARAMS)	;get extent byte.
2919  ED68 01 0C 00     	LD	BC,12
2920  ED6B 09           	ADD	HL,BC
2921  ED6C 7E           	LD	A,(HL)		;and increment it.
2922  ED6D 3C           	INC	A
2923  ED6E E6 1F        	AND	1FH		;keep within range 0-31.
2924  ED70 77           	LD	(HL),A
2925  ED71 CA 83 ED     	JP	Z,GTNEXT1	;overflow?
2926  ED74 47           	LD	B,A		;mask extent byte.
2927  ED75 3A C5 F1     	LD	A,(EXTMASK)
2928  ED78 A0           	AND	B
2929  ED79 21 D2 F1     	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
2930  ED7C A6           	AND	(HL)
2931  ED7D CA 8E ED     	JP	Z,GTNEXT2	;if zero, we must read in next extent.
2932  ED80 C3 AC ED     	JP	GTNEXT3		;else, it is already in memory.
2933  ED83 01 02 00     GTNEXT1:LD	BC,2		;Point to the 's2' byte.
2934  ED86 09           	ADD	HL,BC
2935  ED87 34           	INC	(HL)		;and bump it.
2936  ED88 7E           	LD	A,(HL)		;too many extents?
2937  ED89 E6 0F        	AND	0FH
2938  ED8B CA B6 ED     	JP	Z,GTNEXT5	;yes, set error code.
2939  ED8E              ;
2940  ED8E              ;   Get here to open the next extent.
2941  ED8E              ;
2942  ED8E 0E 0F        GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
2943  ED90 CD 18 EB     	CALL	FINDFST		;find the first one.
2944  ED93 CD F5 E9     	CALL	CKFILPOS	;none available?
2945  ED96 C2 AC ED     	JP	NZ,GTNEXT3
2946  ED99 3A D3 F1     	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
2947  ED9C 3C           	INC	A		;0ffh means reading (so not possible).
2948  ED9D CA B6 ED     	JP	Z,GTNEXT5	;or an error.
2949  EDA0 CD 24 ED     	CALL	GETEMPTY	;we are writing, get an empty entry.
2950  EDA3 CD F5 E9     	CALL	CKFILPOS	;none?
2951  EDA6 CA B6 ED     	JP	Z,GTNEXT5	;error if true.
2952  EDA9 C3 AF ED     	JP	GTNEXT4		;else we are almost done.
2953  EDAC CD 5A EC     GTNEXT3:CALL	OPENIT1		;open this extent.
2954  EDAF CD BB E8     GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
2955  EDB2 AF           	XOR	A		;clear status and return.
2956  EDB3 C3 01 E7     	JP	SETSTAT
2957  EDB6              ;
2958  EDB6              ;   Error in extending the file. Too many extents were needed
2959  EDB6              ; or not enough space on the disk.
2960  EDB6              ;
2961  EDB6 CD 05 E7     GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
2962  EDB9 C3 78 E9     	JP	SETS2B7		;so this is not written on a close.
2963  EDBC              ;
2964  EDBC              ;   Read a sequential file.
2965  EDBC              ;
2966  EDBC 3E 01        RDSEQ:	LD	A,1		;set sequential access mode.
2967  EDBE 32 D5 F1     	LD	(MODE),A
2968  EDC1 3E FF        RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
2969  EDC3 32 D3 F1     	LD	(RDWRTFLG),A
2970  EDC6 CD BB E8     	CALL	STRDATA		;put rec# and ext# into fcb.
2971  EDC9 3A E3 F1     	LD	A,(SAVNREC)	;get next record to read.
2972  EDCC 21 E1 F1     	LD	HL,SAVNXT	;get number of records in extent.
2973  EDCF BE           	CP	(HL)		;within this extent?
2974  EDD0 DA E6 ED     	JP	C,RDSEQ2
2975  EDD3 FE 80        	CP	128		;no. Is this extent fully used?
2976  EDD5 C2 FB ED     	JP	NZ,RDSEQ3	;no. End-of-file.
2977  EDD8 CD 5A ED     	CALL	GETNEXT		;yes, open the next one.
2978  EDDB AF           	XOR	A		;reset next record to read.
2979  EDDC 32 E3 F1     	LD	(SAVNREC),A
2980  EDDF 3A 45 E7     	LD	A,(STATUS)	;check on open, successful?
2981  EDE2 B7           	OR	A
2982  EDE3 C2 FB ED     	JP	NZ,RDSEQ3	;no, error.
2983  EDE6 CD 77 E8     RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
2984  EDE9 CD 84 E8     	CALL	CHKBLK		;check it. Within bounds?
2985  EDEC CA FB ED     	JP	Z,RDSEQ3	;no, error.
2986  EDEF CD 8A E8     	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
2987  EDF2 CD D1 E7     	CALL	TRKSEC1		;set the track and sector for this block #.
2988  EDF5 CD B2 E7     	CALL	DOREAD		;and read it.
2989  EDF8 C3 D2 E8     	JP	SETNREC		;and set the next record to be accessed.
2990  EDFB              ;
2991  EDFB              ;   Read error occured. Set status and return.
2992  EDFB              ;
2993  EDFB C3 05 E7     RDSEQ3:	JP	IOERR1
2994  EDFE              ;
2995  EDFE              ;   Write the next sequential record.
2996  EDFE              ;
2997  EDFE 3E 01        WTSEQ:	LD	A,1		;set sequential access mode.
2998  EE00 32 D5 F1     	LD	(MODE),A
2999  EE03 3E 00        WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
3000  EE05 32 D3 F1     	LD	(RDWRTFLG),A
3001  EE08 CD 54 E9     	CALL	CHKWPRT		;check write protect status.
3002  EE0B 2A 43 E7     	LD	HL,(PARAMS)
3003  EE0E CD 47 E9     	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3004  EE11 CD BB E8     	CALL	STRDATA		;put updated data into fcb.
3005  EE14 3A E3 F1     	LD	A,(SAVNREC)	;get record number to write.
3006  EE17 FE 80        	CP	128		;within range?
3007  EE19 D2 05 E7     	JP	NC,IOERR1	;no, error(?).
3008  EE1C CD 77 E8     	CALL	COMBLK		;compute block number.
3009  EE1F CD 84 E8     	CALL	CHKBLK		;check number.
3010  EE22 0E 00        	LD	C,0		;is there one to write to?
3011  EE24 C2 6E EE     	JP	NZ,WTSEQ6	;yes, go do it.
3012  EE27 CD 3E E8     	CALL	GETBLOCK	;get next block number within fcb to use.
3013  EE2A 32 D7 F1     	LD	(RELBLOCK),A	;and save.
3014  EE2D 01 00 00     	LD	BC,0		;start looking for space from the start
3015  EE30 B7           	OR	A		;if none allocated as yet.
3016  EE31 CA 3B EE     	JP	Z,WTSEQ2
3017  EE34 4F           	LD	C,A		;extract previous block number from fcb
3018  EE35 0B           	DEC	BC		;so we can be closest to it.
3019  EE36 CD 5E E8     	CALL	EXTBLK
3020  EE39 44           	LD	B,H
3021  EE3A 4D           	LD	C,L
3022  EE3B CD BE EB     WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
3023  EE3E 7D           	LD	A,L		;check for a zero number.
3024  EE3F B4           	OR	H
3025  EE40 C2 48 EE     	JP	NZ,WTSEQ3
3026  EE43 3E 02        	LD	A,2		;no more space?
3027  EE45 C3 01 E7     	JP	SETSTAT
3028  EE48 22 E5 F1     WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
3029  EE4B EB           	EX	DE,HL		;put block number into (DE).
3030  EE4C 2A 43 E7     	LD	HL,(PARAMS)	;now we must update the fcb for this
3031  EE4F 01 10 00     	LD	BC,16		;newly allocated block.
3032  EE52 09           	ADD	HL,BC
3033  EE53 3A DD F1     	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3034  EE56 B7           	OR	A
3035  EE57 3A D7 F1     	LD	A,(RELBLOCK)	;(* update this entry *)
3036  EE5A CA 64 EE     	JP	Z,WTSEQ4	;zero means 16 bit ones.
3037  EE5D CD 64 E9     	CALL	ADDA2HL		;(HL)=(HL)+(A)
3038  EE60 73           	LD	(HL),E		;store new block number.
3039  EE61 C3 6C EE     	JP	WTSEQ5
3040  EE64 4F           WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
3041  EE65 06 00        	LD	B,0
3042  EE67 09           	ADD	HL,BC
3043  EE68 09           	ADD	HL,BC
3044  EE69 73           	LD	(HL),E		;stuff block number (DE) there.
3045  EE6A 23           	INC	HL
3046  EE6B 72           	LD	(HL),D
3047  EE6C 0E 02        WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
3048  EE6E 3A 45 E7     WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
3049  EE71 B7           	OR	A
3050  EE72 C0           	RET	NZ
3051  EE73 C5           	PUSH	BC		;yes, save write flag for bios (register C).
3052  EE74 CD 8A E8     	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3053  EE77 3A D5 F1     	LD	A,(MODE)	;get access mode flag (1=sequential,
3054  EE7A 3D           	DEC	A		;0=random, 2=special?).
3055  EE7B 3D           	DEC	A
3056  EE7C C2 BB EE     	JP	NZ,WTSEQ9
3057  EE7F              ;
3058  EE7F              ;   Special random i/o from function #40. Maybe for M/PM, but the
3059  EE7F              ; current block, if it has not been written to, will be zeroed
3060  EE7F              ; out and then written (reason?).
3061  EE7F              ;
3062  EE7F C1           	POP	BC
3063  EE80 C5           	PUSH	BC
3064  EE81 79           	LD	A,C		;get write status flag (2=writing unused space).
3065  EE82 3D           	DEC	A
3066  EE83 3D           	DEC	A
3067  EE84 C2 BB EE     	JP	NZ,WTSEQ9
3068  EE87 E5           	PUSH	HL
3069  EE88 2A B9 F1     	LD	HL,(DIRBUF)	;zero out the directory buffer.
3070  EE8B 57           	LD	D,A		;note that (A) is zero here.
3071  EE8C 77           WTSEQ7:	LD	(HL),A
3072  EE8D 23           	INC	HL
3073  EE8E 14           	INC	D		;do 128 bytes.
3074  EE8F F2 8C EE     	JP	P,WTSEQ7
3075  EE92 CD E0 E9     	CALL	DIRDMA		;tell the bios the dma address for directory access.
3076  EE95 2A E7 F1     	LD	HL,(LOGSECT)	;get sector that starts current block.
3077  EE98 0E 02        	LD	C,2		;set 'writing to unused space' flag.
3078  EE9A 22 E5 F1     WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
3079  EE9D C5           	PUSH	BC
3080  EE9E CD D1 E7     	CALL	TRKSEC1		;determine its track and sector numbers.
3081  EEA1 C1           	POP	BC
3082  EEA2 CD B8 E7     	CALL	DOWRITE		;now write out 128 bytes of zeros.
3083  EEA5 2A E5 F1     	LD	HL,(BLKNMBR)	;get sector number.
3084  EEA8 0E 00        	LD	C,0		;set normal write flag.
3085  EEAA 3A C4 F1     	LD	A,(BLKMASK)	;determine if we have written the entire
3086  EEAD 47           	LD	B,A		;physical block.
3087  EEAE A5           	AND	L
3088  EEAF B8           	CP	B
3089  EEB0 23           	INC	HL		;prepare for the next one.
3090  EEB1 C2 9A EE     	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
3091  EEB4 E1           	POP	HL		;reset next sector number.
3092  EEB5 22 E5 F1     	LD	(BLKNMBR),HL
3093  EEB8 CD DA E9     	CALL	DEFDMA		;and reset dma address.
3094  EEBB              ;
3095  EEBB              ;   Normal disk write. Set the desired track and sector then
3096  EEBB              ; do the actual write.
3097  EEBB              ;
3098  EEBB CD D1 E7     WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
3099  EEBE C1           	POP	BC		;get write status flag.
3100  EEBF C5           	PUSH	BC
3101  EEC0 CD B8 E7     	CALL	DOWRITE		;and write this out.
3102  EEC3 C1           	POP	BC
3103  EEC4 3A E3 F1     	LD	A,(SAVNREC)	;get number of records in file.
3104  EEC7 21 E1 F1     	LD	HL,SAVNXT	;get last record written.
3105  EECA BE           	CP	(HL)
3106  EECB DA D2 EE     	JP	C,WTSEQ10
3107  EECE 77           	LD	(HL),A		;we have to update record count.
3108  EECF 34           	INC	(HL)
3109  EED0 0E 02        	LD	C,2
3110  EED2              ;
3111  EED2              ;*   This area has been patched to correct disk update problem
3112  EED2              ;* when using blocking and de-blocking in the BIOS.
3113  EED2              ;
3114  EED2 00           WTSEQ10:NOP			;was 'dcr c'
3115  EED3 00           	NOP			;was 'dcr c'
3116  EED4 21 00 00     	LD	HL,0		;was 'jnz wtseq99'
3117  EED7              ;
3118  EED7              ; *   End of patch.
3119  EED7              ;
3120  EED7 F5           	PUSH	AF
3121  EED8 CD 69 E9     	CALL	GETS2		;set 'extent written to' flag.
3122  EEDB E6 7F        	AND	7FH		;(* clear bit 7 *)
3123  EEDD 77           	LD	(HL),A
3124  EEDE F1           	POP	AF		;get record count for this extent.
3125  EEDF FE 7F        WTSEQ99:CP	127		;is it full?
3126  EEE1 C2 00 EF     	JP	NZ,WTSEQ12
3127  EEE4 3A D5 F1     	LD	A,(MODE)	;yes, are we in sequential mode?
3128  EEE7 FE 01        	CP	1
3129  EEE9 C2 00 EF     	JP	NZ,WTSEQ12
3130  EEEC CD D2 E8     	CALL	SETNREC		;yes, set next record number.
3131  EEEF CD 5A ED     	CALL	GETNEXT		;and get next empty space in directory.
3132  EEF2 21 45 E7     	LD	HL,STATUS	;ok?
3133  EEF5 7E           	LD	A,(HL)
3134  EEF6 B7           	OR	A
3135  EEF7 C2 FE EE     	JP	NZ,WTSEQ11
3136  EEFA 3D           	DEC	A		;yes, set record count to -1.
3137  EEFB 32 E3 F1     	LD	(SAVNREC),A
3138  EEFE 36 00        WTSEQ11:LD	(HL),0		;clear status.
3139  EF00 C3 D2 E8     WTSEQ12:JP	SETNREC		;set next record to access.
3140  EF03              ;
3141  EF03              ;   For random i/o, set the fcb for the desired record number
3142  EF03              ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3143  EF03              ; used as follows:
3144  EF03              ;
3145  EF03              ;       fcb+35            fcb+34            fcb+33
3146  EF03              ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3147  EF03              ;  |7             0 | 7             0 | 7             0|
3148  EF03              ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3149  EF03              ;  |    overflow   | | extra |  extent   |   record #  |
3150  EF03              ;  | ______________| |_extent|__number___|_____________|
3151  EF03              ;                     also 's2'
3152  EF03              ;
3153  EF03              ;   On entry, register (C) contains 0ffh if this is a read
3154  EF03              ; and thus we can not access unwritten disk space. Otherwise,
3155  EF03              ; another extent will be opened (for writing) if required.
3156  EF03              ;
3157  EF03 AF           POSITION: XOR	A		;set random i/o flag.
3158  EF04 32 D5 F1     	LD	(MODE),A
3159  EF07              ;
3160  EF07              ;   Special entry (function #40). M/PM ?
3161  EF07              ;
3162  EF07 C5           POSITN1:PUSH	BC		;save read/write flag.
3163  EF08 2A 43 E7     	LD	HL,(PARAMS)	;get address of fcb.
3164  EF0B EB           	EX	DE,HL
3165  EF0C 21 21 00     	LD	HL,33		;now get byte 'r0'.
3166  EF0F 19           	ADD	HL,DE
3167  EF10 7E           	LD	A,(HL)
3168  EF11 E6 7F        	AND	7FH		;keep bits 0-6 for the record number to access.
3169  EF13 F5           	PUSH	AF
3170  EF14 7E           	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3171  EF15 17           	RLA
3172  EF16 23           	INC	HL
3173  EF17 7E           	LD	A,(HL)
3174  EF18 17           	RLA
3175  EF19 E6 1F        	AND	1FH		;and save this in bits 0-4 of (C).
3176  EF1B 4F           	LD	C,A		;this is the extent byte.
3177  EF1C 7E           	LD	A,(HL)		;now get the extra extent byte.
3178  EF1D 1F           	RRA
3179  EF1E 1F           	RRA
3180  EF1F 1F           	RRA
3181  EF20 1F           	RRA
3182  EF21 E6 0F        	AND	0FH
3183  EF23 47           	LD	B,A		;and save it in (B).
3184  EF24 F1           	POP	AF		;get record number back to (A).
3185  EF25 23           	INC	HL		;check overflow byte 'r2'.
3186  EF26 6E           	LD	L,(HL)
3187  EF27 2C           	INC	L
3188  EF28 2D           	DEC	L
3189  EF29 2E 06        	LD	L,6		;prepare for error.
3190  EF2B C2 8B EF     	JP	NZ,POSITN5	;out of disk space error.
3191  EF2E 21 20 00     	LD	HL,32		;store record number into fcb.
3192  EF31 19           	ADD	HL,DE
3193  EF32 77           	LD	(HL),A
3194  EF33 21 0C 00     	LD	HL,12		;and now check the extent byte.
3195  EF36 19           	ADD	HL,DE
3196  EF37 79           	LD	A,C
3197  EF38 96           	SUB	(HL)		;same extent as before?
3198  EF39 C2 47 EF     	JP	NZ,POSITN2
3199  EF3C 21 0E 00     	LD	HL,14		;yes, check extra extent byte 's2' also.
3200  EF3F 19           	ADD	HL,DE
3201  EF40 78           	LD	A,B
3202  EF41 96           	SUB	(HL)
3203  EF42 E6 7F        	AND	7FH
3204  EF44 CA 7F EF     	JP	Z,POSITN3	;same, we are almost done then.
3205  EF47              ;
3206  EF47              ;  Get here when another extent is required.
3207  EF47              ;
3208  EF47 C5           POSITN2:PUSH	BC
3209  EF48 D5           	PUSH	DE
3210  EF49 CD A2 EC     	CALL	CLOSEIT		;close current extent.
3211  EF4C D1           	POP	DE
3212  EF4D C1           	POP	BC
3213  EF4E 2E 03        	LD	L,3		;prepare for error.
3214  EF50 3A 45 E7     	LD	A,(STATUS)
3215  EF53 3C           	INC	A
3216  EF54 CA 84 EF     	JP	Z,POSITN4	;close error.
3217  EF57 21 0C 00     	LD	HL,12		;put desired extent into fcb now.
3218  EF5A 19           	ADD	HL,DE
3219  EF5B 71           	LD	(HL),C
3220  EF5C 21 0E 00     	LD	HL,14		;and store extra extent byte 's2'.
3221  EF5F 19           	ADD	HL,DE
3222  EF60 70           	LD	(HL),B
3223  EF61 CD 51 EC     	CALL	OPENIT		;try and get this extent.
3224  EF64 3A 45 E7     	LD	A,(STATUS)	;was it there?
3225  EF67 3C           	INC	A
3226  EF68 C2 7F EF     	JP	NZ,POSITN3
3227  EF6B C1           	POP	BC		;no. can we create a new one (writing?).
3228  EF6C C5           	PUSH	BC
3229  EF6D 2E 04        	LD	L,4		;prepare for error.
3230  EF6F 0C           	INC	C
3231  EF70 CA 84 EF     	JP	Z,POSITN4	;nope, reading unwritten space error.
3232  EF73 CD 24 ED     	CALL	GETEMPTY	;yes we can, try to find space.
3233  EF76 2E 05        	LD	L,5		;prepare for error.
3234  EF78 3A 45 E7     	LD	A,(STATUS)
3235  EF7B 3C           	INC	A
3236  EF7C CA 84 EF     	JP	Z,POSITN4	;out of space?
3237  EF7F              ;
3238  EF7F              ;   Normal return location. Clear error code and return.
3239  EF7F              ;
3240  EF7F C1           POSITN3:POP	BC		;restore stack.
3241  EF80 AF           	XOR	A		;and clear error code byte.
3242  EF81 C3 01 E7     	JP	SETSTAT
3243  EF84              ;
3244  EF84              ;   Error. Set the 's2' byte to indicate this (why?).
3245  EF84              ;
3246  EF84 E5           POSITN4:PUSH	HL
3247  EF85 CD 69 E9     	CALL	GETS2
3248  EF88 36 C0        	LD	(HL),0C0H
3249  EF8A E1           	POP	HL
3250  EF8B              ;
3251  EF8B              ;   Return with error code (presently in L).
3252  EF8B              ;
3253  EF8B C1           POSITN5:POP	BC
3254  EF8C 7D           	LD	A,L		;get error code.
3255  EF8D 32 45 E7     	LD	(STATUS),A
3256  EF90 C3 78 E9     	JP	SETS2B7
3257  EF93              ;
3258  EF93              ;   Read a random record.
3259  EF93              ;
3260  EF93 0E FF        READRAN:LD	C,0FFH		;set 'read' status.
3261  EF95 CD 03 EF     	CALL	POSITION	;position the file to proper record.
3262  EF98 CC C1 ED     	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
3263  EF9B C9           	RET
3264  EF9C              ;
3265  EF9C              ;   Write to a random record.
3266  EF9C              ;
3267  EF9C 0E 00        WRITERAN: LD	C,0		;set 'writing' flag.
3268  EF9E CD 03 EF     	CALL	POSITION	;position the file to proper record.
3269  EFA1 CC 03 EE     	CALL	Z,WTSEQ1	;and write as usual (if no errors).
3270  EFA4 C9           	RET
3271  EFA5              ;
3272  EFA5              ;   Compute the random record number. Enter with (HL) pointing
3273  EFA5              ; to a fcb an (DE) contains a relative location of a record
3274  EFA5              ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3275  EFA5              ; byte, and (A) the 'r2' byte.
3276  EFA5              ;
3277  EFA5              ;   On return, the zero flag is set if the record is within
3278  EFA5              ; bounds. Otherwise, an overflow occured.
3279  EFA5              ;
3280  EFA5 EB           COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
3281  EFA6 19           	ADD	HL,DE		;compute relative position of record #.
3282  EFA7 4E           	LD	C,(HL)		;get record number into (BC).
3283  EFA8 06 00        	LD	B,0
3284  EFAA 21 0C 00     	LD	HL,12		;now get extent.
3285  EFAD 19           	ADD	HL,DE
3286  EFAE 7E           	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3287  EFAF 0F           	RRCA			;move lower bit into bit 7.
3288  EFB0 E6 80        	AND	80H		;and ignore all other bits.
3289  EFB2 81           	ADD	A,C		;add to our record number.
3290  EFB3 4F           	LD	C,A
3291  EFB4 3E 00        	LD	A,0		;take care of any carry.
3292  EFB6 88           	ADC	A,B
3293  EFB7 47           	LD	B,A
3294  EFB8 7E           	LD	A,(HL)		;now get the upper bits of extent into
3295  EFB9 0F           	RRCA			;bit positions 0-3.
3296  EFBA E6 0F        	AND	0FH		;and ignore all others.
3297  EFBC 80           	ADD	A,B		;add this in to 'r1' byte.
3298  EFBD 47           	LD	B,A
3299  EFBE 21 0E 00     	LD	HL,14		;get the 's2' byte (extra extent).
3300  EFC1 19           	ADD	HL,DE
3301  EFC2 7E           	LD	A,(HL)
3302  EFC3 87           	ADD	A,A		;and shift it left 4 bits (bits 4-7).
3303  EFC4 87           	ADD	A,A
3304  EFC5 87           	ADD	A,A
3305  EFC6 87           	ADD	A,A
3306  EFC7 F5           	PUSH	AF		;save carry flag (bit 0 of flag byte).
3307  EFC8 80           	ADD	A,B		;now add extra extent into 'r1'.
3308  EFC9 47           	LD	B,A
3309  EFCA F5           	PUSH	AF		;and save carry (overflow byte 'r2').
3310  EFCB E1           	POP	HL		;bit 0 of (L) is the overflow indicator.
3311  EFCC 7D           	LD	A,L
3312  EFCD E1           	POP	HL		;and same for first carry flag.
3313  EFCE B5           	OR	L		;either one of these set?
3314  EFCF E6 01        	AND	01H		;only check the carry flags.
3315  EFD1 C9           	RET
3316  EFD2              ;
3317  EFD2              ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3318  EFD2              ; reflect the last record used for a random (or other) file.
3319  EFD2              ; This reads the directory and looks at all extents computing
3320  EFD2              ; the largerst record number for each and keeping the maximum
3321  EFD2              ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3322  EFD2              ; maximum record number. This is used to compute the space used
3323  EFD2              ; by a random file.
3324  EFD2              ;
3325  EFD2 0E 0C        RANSIZE:LD	C,12		;look thru directory for first entry with
3326  EFD4 CD 18 EB     	CALL	FINDFST		;this name.
3327  EFD7 2A 43 E7     	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3328  EFDA 11 21 00     	LD	DE,33
3329  EFDD 19           	ADD	HL,DE
3330  EFDE E5           	PUSH	HL
3331  EFDF 72           	LD	(HL),D		;note that (D)=0.
3332  EFE0 23           	INC	HL
3333  EFE1 72           	LD	(HL),D
3334  EFE2 23           	INC	HL
3335  EFE3 72           	LD	(HL),D
3336  EFE4 CD F5 E9     RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
3337  EFE7 CA 0C F0     	JP	Z,RANSIZ3	;no, we are done.
3338  EFEA CD 5E E9     	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3339  EFED 11 0F 00     	LD	DE,15		;point to last record in extent.
3340  EFF0 CD A5 EF     	CALL	COMPRAND	;and compute random parameters.
3341  EFF3 E1           	POP	HL
3342  EFF4 E5           	PUSH	HL		;now check these values against those
3343  EFF5 5F           	LD	E,A		;already in fcb.
3344  EFF6 79           	LD	A,C		;the carry flag will be set if those
3345  EFF7 96           	SUB	(HL)		;in the fcb represent a larger size than
3346  EFF8 23           	INC	HL		;this extent does.
3347  EFF9 78           	LD	A,B
3348  EFFA 9E           	SBC	A,(HL)
3349  EFFB 23           	INC	HL
3350  EFFC 7B           	LD	A,E
3351  EFFD 9E           	SBC	A,(HL)
3352  EFFE DA 06 F0     	JP	C,RANSIZ2
3353  F001 73           	LD	(HL),E		;we found a larger (in size) extent.
3354  F002 2B           	DEC	HL		;stuff these values into fcb.
3355  F003 70           	LD	(HL),B
3356  F004 2B           	DEC	HL
3357  F005 71           	LD	(HL),C
3358  F006 CD 2D EB     RANSIZ2:CALL	FINDNXT		;now get the next extent.
3359  F009 C3 E4 EF     	JP	RANSIZ1		;continue til all done.
3360  F00C E1           RANSIZ3:POP	HL		;we are done, restore the stack and
3361  F00D C9           	RET			;return.
3362  F00E              ;
3363  F00E              ;   Function to return the random record position of a given
3364  F00E              ; file which has been read in sequential mode up to now.
3365  F00E              ;
3366  F00E 2A 43 E7     SETRAN:	LD	HL,(PARAMS)	;point to fcb.
3367  F011 11 20 00     	LD	DE,32		;and to last used record.
3368  F014 CD A5 EF     	CALL	COMPRAND	;compute random position.
3369  F017 21 21 00     	LD	HL,33		;now stuff these values into fcb.
3370  F01A 19           	ADD	HL,DE
3371  F01B 71           	LD	(HL),C		;move 'r0'.
3372  F01C 23           	INC	HL
3373  F01D 70           	LD	(HL),B		;and 'r1'.
3374  F01E 23           	INC	HL
3375  F01F 77           	LD	(HL),A		;and lastly 'r2'.
3376  F020 C9           	RET
3377  F021              ;
3378  F021              ;   This routine select the drive specified in (ACTIVE) and
3379  F021              ; update the login vector and bitmap table if this drive was
3380  F021              ; not already active.
3381  F021              ;
3382  F021 2A AF F1     LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
3383  F024 3A 42 E7     	LD	A,(ACTIVE)	;get the default drive.
3384  F027 4F           	LD	C,A
3385  F028 CD EA E8     	CALL	SHIFTR		;position active bit for this drive
3386  F02B E5           	PUSH	HL		;into bit 0.
3387  F02C EB           	EX	DE,HL
3388  F02D CD 59 E7     	CALL	SELECT		;select this drive.
3389  F030 E1           	POP	HL
3390  F031 CC 47 E7     	CALL	Z,SLCTERR	;valid drive?
3391  F034 7D           	LD	A,L		;is this a newly activated drive?
3392  F035 1F           	RRA
3393  F036 D8           	RET	C
3394  F037 2A AF F1     	LD	HL,(LOGIN)	;yes, update the login vector.
3395  F03A 4D           	LD	C,L
3396  F03B 44           	LD	B,H
3397  F03C CD 0B E9     	CALL	SETBIT
3398  F03F 22 AF F1     	LD	(LOGIN),HL	;and save.
3399  F042 C3 A3 EA     	JP	BITMAP		;now update the bitmap.
3400  F045              ;
3401  F045              ;   Function to set the active disk number.
3402  F045              ;
3403  F045 3A D6 F1     SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
3404  F048 21 42 E7     	LD	HL,ACTIVE	;represents a change in drives.
3405  F04B BE           	CP	(HL)
3406  F04C C8           	RET	Z
3407  F04D 77           	LD	(HL),A		;yes it does, log it in.
3408  F04E C3 21 F0     	JP	LOGINDRV
3409  F051              ;
3410  F051              ;   This is the 'auto disk select' routine. The firsst byte
3411  F051              ; of the fcb is examined for a drive specification. If non
3412  F051              ; zero then the drive will be selected and loged in.
3413  F051              ;
3414  F051 3E FF        AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
3415  F053 32 DE F1     	LD	(AUTO),A
3416  F056 2A 43 E7     	LD	HL,(PARAMS)	;get drive specified.
3417  F059 7E           	LD	A,(HL)
3418  F05A E6 1F        	AND	1FH		;look at lower 5 bits.
3419  F05C 3D           	DEC	A		;adjust for (1=A, 2=B) etc.
3420  F05D 32 D6 F1     	LD	(EPARAM),A	;and save for the select routine.
3421  F060 FE 1E        	CP	1EH		;check for 'no change' condition.
3422  F062 D2 75 F0     	JP	NC,AUTOSL1	;yes, don't change.
3423  F065 3A 42 E7     	LD	A,(ACTIVE)	;we must change, save currently active
3424  F068 32 DF F1     	LD	(OLDDRV),A	;drive.
3425  F06B 7E           	LD	A,(HL)		;and save first byte of fcb also.
3426  F06C 32 E0 F1     	LD	(AUTOFLAG),A	;this must be non-zero.
3427  F06F E6 E0        	AND	0E0H		;whats this for (bits 6,7 are used for
3428  F071 77           	LD	(HL),A		;something)?
3429  F072 CD 45 F0     	CALL	SETDSK		;select and log in this drive.
3430  F075 3A 41 E7     AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
3431  F078 2A 43 E7     	LD	HL,(PARAMS)	;(* upper half of first byte *)
3432  F07B B6           	OR	(HL)
3433  F07C 77           	LD	(HL),A
3434  F07D C9           	RET			;and return (all done).
3435  F07E              ;
3436  F07E              ;   Function to return the current cp/m version number.
3437  F07E              ;
3438  F07E 3E 22        GETVER:	LD	A,022H		;version 2.2
3439  F080 C3 01 E7     	JP	SETSTAT
3440  F083              ;
3441  F083              ;   Function to reset the disk system.
3442  F083              ;
3443  F083 21 00 00     RSTDSK:	LD	HL,0		;clear write protect status and log
3444  F086 22 AD F1     	LD	(WRTPRT),HL	;in vector.
3445  F089 22 AF F1     	LD	(LOGIN),HL
3446  F08C AF           	XOR	A		;select drive 'A'.
3447  F08D 32 42 E7     	LD	(ACTIVE),A
3448  F090 21 80 00     	LD	HL,TBUFF	;setup default dma address.
3449  F093 22 B1 F1     	LD	(USERDMA),HL
3450  F096 CD DA E9     	CALL	DEFDMA
3451  F099 C3 21 F0     	JP	LOGINDRV	;now log in drive 'A'.
3452  F09C              ;
3453  F09C              ;   Function to open a specified file.
3454  F09C              ;
3455  F09C CD 72 E9     OPENFIL:CALL	CLEARS2		;clear 's2' byte.
3456  F09F CD 51 F0     	CALL	AUTOSEL		;select proper disk.
3457  F0A2 C3 51 EC     	JP	OPENIT		;and open the file.
3458  F0A5              ;
3459  F0A5              ;   Function to close a specified file.
3460  F0A5              ;
3461  F0A5 CD 51 F0     CLOSEFIL: CALL	AUTOSEL		;select proper disk.
3462  F0A8 C3 A2 EC     	JP	CLOSEIT		;and close the file.
3463  F0AB              ;
3464  F0AB              ;   Function to return the first occurence of a specified file
3465  F0AB              ; name. If the first byte of the fcb is '?' then the name will
3466  F0AB              ; not be checked (get the first entry no matter what).
3467  F0AB              ;
3468  F0AB 0E 00        GETFST:	LD	C,0		;prepare for special search.
3469  F0AD EB           	EX	DE,HL
3470  F0AE 7E           	LD	A,(HL)		;is first byte a '?'?
3471  F0AF FE 3F        	CP	'?'
3472  F0B1 CA C2 F0     	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
3473  F0B4 CD A6 E8     	CALL	SETEXT		;get the extension byte from fcb.
3474  F0B7 7E           	LD	A,(HL)		;is it '?'? if yes, then we want
3475  F0B8 FE 3F        	CP	'?'		;an entry with a specific 's2' byte.
3476  F0BA C4 72 E9     	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
3477  F0BD CD 51 F0     	CALL	AUTOSEL		;select proper drive.
3478  F0C0 0E 0F        	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
3479  F0C2 CD 18 EB     GETFST1:CALL	FINDFST		;find an entry and then move it into
3480  F0C5 C3 E9 E9     	JP	MOVEDIR		;the users dma space.
3481  F0C8              ;
3482  F0C8              ;   Function to return the next occurence of a file name.
3483  F0C8              ;
3484  F0C8 2A D9 F1     GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
3485  F0CB 22 43 E7     	LD	(PARAMS),HL	;other dbos calls are allowed.
3486  F0CE CD 51 F0     	CALL	AUTOSEL		;no error will be returned, but the
3487  F0D1 CD 2D EB     	CALL	FINDNXT		;results will be wrong.
3488  F0D4 C3 E9 E9     	JP	MOVEDIR
3489  F0D7              ;
3490  F0D7              ;   Function to delete a file by name.
3491  F0D7              ;
3492  F0D7 CD 51 F0     DELFILE:CALL	AUTOSEL		;select proper drive.
3493  F0DA CD 9C EB     	CALL	ERAFILE		;erase the file.
3494  F0DD C3 01 EB     	JP	STSTATUS	;set status and return.
3495  F0E0              ;
3496  F0E0              ;   Function to execute a sequential read of the specified
3497  F0E0              ; record number.
3498  F0E0              ;
3499  F0E0 CD 51 F0     READSEQ:CALL	AUTOSEL		;select proper drive then read.
3500  F0E3 C3 BC ED     	JP	RDSEQ
3501  F0E6              ;
3502  F0E6              ;   Function to write the net sequential record.
3503  F0E6              ;
3504  F0E6 CD 51 F0     WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
3505  F0E9 C3 FE ED     	JP	WTSEQ
3506  F0EC              ;
3507  F0EC              ;   Create a file function.
3508  F0EC              ;
3509  F0EC CD 72 E9     FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
3510  F0EF CD 51 F0     	CALL	AUTOSEL		;select proper drive and get the next
3511  F0F2 C3 24 ED     	JP	GETEMPTY	;empty directory space.
3512  F0F5              ;
3513  F0F5              ;   Function to rename a file.
3514  F0F5              ;
3515  F0F5 CD 51 F0     RENFILE:CALL	AUTOSEL		;select proper drive and then switch
3516  F0F8 CD 16 EC     	CALL	CHGNAMES	;file names.
3517  F0FB C3 01 EB     	JP	STSTATUS
3518  F0FE              ;
3519  F0FE              ;   Function to return the login vector.
3520  F0FE              ;
3521  F0FE 2A AF F1     GETLOG:	LD	HL,(LOGIN)
3522  F101 C3 29 F1     	JP	GETPRM1
3523  F104              ;
3524  F104              ;   Function to return the current disk assignment.
3525  F104              ;
3526  F104 3A 42 E7     GETCRNT:LD	A,(ACTIVE)
3527  F107 C3 01 E7     	JP	SETSTAT
3528  F10A              ;
3529  F10A              ;   Function to set the dma address.
3530  F10A              ;
3531  F10A EB           PUTDMA:	EX	DE,HL
3532  F10B 22 B1 F1     	LD	(USERDMA),HL	;save in our space and then get to
3533  F10E C3 DA E9     	JP	DEFDMA		;the bios with this also.
3534  F111              ;
3535  F111              ;   Function to return the allocation vector.
3536  F111              ;
3537  F111 2A BF F1     GETALOC:LD	HL,(ALOCVECT)
3538  F114 C3 29 F1     	JP	GETPRM1
3539  F117              ;
3540  F117              ;   Function to return the read-only status vector.
3541  F117              ;
3542  F117 2A AD F1     GETROV:	LD	HL,(WRTPRT)
3543  F11A C3 29 F1     	JP	GETPRM1
3544  F11D              ;
3545  F11D              ;   Function to set the file attributes (read-only, system).
3546  F11D              ;
3547  F11D CD 51 F0     SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
3548  F120 CD 3B EC     	CALL	SAVEATTR
3549  F123 C3 01 EB     	JP	STSTATUS
3550  F126              ;
3551  F126              ;   Function to return the address of the disk parameter block
3552  F126              ; for the current drive.
3553  F126              ;
3554  F126 2A BB F1     GETPARM:LD	HL,(DISKPB)
3555  F129 22 45 E7     GETPRM1:LD	(STATUS),HL
3556  F12C C9           	RET
3557  F12D              ;
3558  F12D              ;   Function to get or set the user number. If (E) was (FF)
3559  F12D              ; then this is a request to return the current user number.
3560  F12D              ; Else set the user number from (E).
3561  F12D              ;
3562  F12D 3A D6 F1     GETUSER:LD	A,(EPARAM)	;get parameter.
3563  F130 FE FF        	CP	0FFH		;get user number?
3564  F132 C2 3B F1     	JP	NZ,SETUSER
3565  F135 3A 41 E7     	LD	A,(USERNO)	;yes, just do it.
3566  F138 C3 01 E7     	JP	SETSTAT
3567  F13B E6 1F        SETUSER:AND	1FH		;no, we should set it instead. keep low
3568  F13D 32 41 E7     	LD	(USERNO),A	;bits (0-4) only.
3569  F140 C9           	RET
3570  F141              ;
3571  F141              ;   Function to read a random record from a file.
3572  F141              ;
3573  F141 CD 51 F0     RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
3574  F144 C3 93 EF     	JP	READRAN
3575  F147              ;
3576  F147              ;   Function to compute the file size for random files.
3577  F147              ;
3578  F147 CD 51 F0     WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
3579  F14A C3 9C EF     	JP	WRITERAN
3580  F14D              ;
3581  F14D              ;   Function to compute the size of a random file.
3582  F14D              ;
3583  F14D CD 51 F0     FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
3584  F150 C3 D2 EF     	JP	RANSIZE
3585  F153              ;
3586  F153              ;   Function #37. This allows a program to log off any drives.
3587  F153              ; On entry, set (DE) to contain a word with bits set for those
3588  F153              ; drives that are to be logged off. The log-in vector and the
3589  F153              ; write protect vector will be updated. This must be a M/PM
3590  F153              ; special function.
3591  F153              ;
3592  F153 2A 43 E7     LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
3593  F156 7D           	LD	A,L		;for each bit that is set, we want
3594  F157 2F           	CPL			;to clear that bit in (LOGIN)
3595  F158 5F           	LD	E,A		;and (WRTPRT).
3596  F159 7C           	LD	A,H
3597  F15A 2F           	CPL
3598  F15B 2A AF F1     	LD	HL,(LOGIN)	;reset the login vector.
3599  F15E A4           	AND	H
3600  F15F 57           	LD	D,A
3601  F160 7D           	LD	A,L
3602  F161 A3           	AND	E
3603  F162 5F           	LD	E,A
3604  F163 2A AD F1     	LD	HL,(WRTPRT)
3605  F166 EB           	EX	DE,HL
3606  F167 22 AF F1     	LD	(LOGIN),HL	;and save.
3607  F16A 7D           	LD	A,L		;now do the write protect vector.
3608  F16B A3           	AND	E
3609  F16C 6F           	LD	L,A
3610  F16D 7C           	LD	A,H
3611  F16E A2           	AND	D
3612  F16F 67           	LD	H,A
3613  F170 22 AD F1     	LD	(WRTPRT),HL	;and save. all done.
3614  F173 C9           	RET
3615  F174              ;
3616  F174              ;   Get here to return to the user.
3617  F174              ;
3618  F174 3A DE F1     GOBACK:	LD	A,(AUTO)	;was auto select activated?
3619  F177 B7           	OR	A
3620  F178 CA 91 F1     	JP	Z,GOBACK1
3621  F17B 2A 43 E7     	LD	HL,(PARAMS)	;yes, but was a change made?
3622  F17E 36 00        	LD	(HL),0		;(* reset first byte of fcb *)
3623  F180 3A E0 F1     	LD	A,(AUTOFLAG)
3624  F183 B7           	OR	A
3625  F184 CA 91 F1     	JP	Z,GOBACK1
3626  F187 77           	LD	(HL),A		;yes, reset first byte properly.
3627  F188 3A DF F1     	LD	A,(OLDDRV)	;and get the old drive and select it.
3628  F18B 32 D6 F1     	LD	(EPARAM),A
3629  F18E CD 45 F0     	CALL	SETDSK
3630  F191 2A 0F E7     GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
3631  F194 F9           	LD	SP,HL
3632  F195 2A 45 E7     	LD	HL,(STATUS)	;get return status.
3633  F198 7D           	LD	A,L		;force version 1.4 compatability.
3634  F199 44           	LD	B,H
3635  F19A C9           	RET			;and go back to user.
3636  F19B              ;
3637  F19B              ;   Function #40. This is a special entry to do random i/o.
3638  F19B              ; For the case where we are writing to unused disk space, this
3639  F19B              ; space will be zeroed out first. This must be a M/PM special
3640  F19B              ; purpose function, because why would any normal program even
3641  F19B              ; care about the previous contents of a sector about to be
3642  F19B              ; written over.
3643  F19B              ;
3644  F19B CD 51 F0     WTSPECL:CALL	AUTOSEL		;select proper drive.
3645  F19E 3E 02        	LD	A,2		;use special write mode.
3646  F1A0 32 D5 F1     	LD	(MODE),A
3647  F1A3 0E 00        	LD	C,0		;set write indicator.
3648  F1A5 CD 07 EF     	CALL	POSITN1		;position the file.
3649  F1A8 CC 03 EE     	CALL	Z,WTSEQ1	;and write (if no errors).
3650  F1AB C9           	RET
3651  F1AC              ;
3652  F1AC              ;**************************************************************
3653  F1AC              ;*
3654  F1AC              ;*     BDOS data storage pool.
3655  F1AC              ;*
3656  F1AC              ;**************************************************************
3657  F1AC              ;
3658  F1AC E5           EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
3659  F1AD 00 00        WRTPRT:	DEFW	0		;write protect status for all 16 drives.
3660  F1AF 00 00        LOGIN:	DEFW	0		;drive active word (1 bit per drive).
3661  F1B1 80 00        USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
3662  F1B3              ;
3663  F1B3              ;   Scratch areas from parameter block.
3664  F1B3              ;
3665  F1B3 00 00        SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
3666  F1B5 00 00        SCRATCH2: DEFW	0		;last selected track number.
3667  F1B7 00 00        SCRATCH3: DEFW	0		;last selected sector number.
3668  F1B9              ;
3669  F1B9              ;   Disk storage areas from parameter block.
3670  F1B9              ;
3671  F1B9 00 00        DIRBUF:	DEFW	0		;address of directory buffer to use.
3672  F1BB 00 00        DISKPB:	DEFW	0		;contains address of disk parameter block.
3673  F1BD 00 00        CHKVECT:DEFW	0		;address of check vector.
3674  F1BF 00 00        ALOCVECT: DEFW	0		;address of allocation vector (bit map).
3675  F1C1              ;
3676  F1C1              ;   Parameter block returned from the bios.
3677  F1C1              ;
3678  F1C1 00 00        SECTORS:DEFW	0		;sectors per track from bios.
3679  F1C3 00           BLKSHFT:DEFB	0		;block shift.
3680  F1C4 00           BLKMASK:DEFB	0		;block mask.
3681  F1C5 00           EXTMASK:DEFB	0		;extent mask.
3682  F1C6 00 00        DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
3683  F1C8 00 00        DIRSIZE:DEFW	0		;directory size.
3684  F1CA 00 00        ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
3685  F1CC 00 00        ALLOC1:	DEFW	0
3686  F1CE 00 00        OFFSET:	DEFW	0		;first usable track number.
3687  F1D0 00 00        XLATE:	DEFW	0		;sector translation table address.
3688  F1D2              ;
3689  F1D2              ;
3690  F1D2 00           CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
3691  F1D3 00           RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
3692  F1D4 00           FNDSTAT:DEFB	0		;filename found status (0=found first entry).
3693  F1D5 00           MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
3694  F1D6 00           EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
3695  F1D7 00           RELBLOCK: DEFB	0		;relative position within fcb of block number written.
3696  F1D8 00           COUNTER:DEFB	0		;byte counter for directory name searches.
3697  F1D9 00 00 00 00  SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
3698  F1DD 00           BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
3699  F1DE 00           AUTO:	DEFB	0		;if non-zero, then auto select activated.
3700  F1DF 00           OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
3701  F1E0 00           AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
3702  F1E1 00           SAVNXT:	DEFB	0		;storage for next record number to access.
3703  F1E2 00           SAVEXT:	DEFB	0		;storage for extent number of file.
3704  F1E3 00 00        SAVNREC:DEFW	0		;storage for number of records in file.
3705  F1E5 00 00        BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
3706  F1E7 00 00        LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
3707  F1E9 00           FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
3708  F1EA 00 00        FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
3709  F1EC              ;
3710  F1EC              ;   Disk directory buffer checksum bytes. One for each of the
3711  F1EC              ; 16 possible drives.
3712  F1EC              ;
3713  F1EC 00 00 00 00  CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3713  F1F0 00 00 00 00
3713  F1F4 00 00 00 00
3713  F1F8 00 00 00 00
3714  F1FC              ;
3715  F1FC              ;   Extra space ?
3716  F1FC              ;
3717  F1FC 00 00 00 00  	DEFB	0,0,0,0
3718  F200
3719  F200              ENDADR:
3720  F200
3721  F200              ;
3722  F200              ;**************************************************************
3723  F200              ;*
3724  F200              ;*        B I O S   J U M P   T A B L E
3725  F200              ;*
3726  F200              ;**************************************************************
3727  F200              ;
3728  F200 C3 00 00     BOOT:	JP	0
3729  F203 C3 00 00     WBOOT:	JP	0
3730  F206 C3 00 00     CONST:	JP	0
3731  F209 C3 00 00     CONIN:	JP	0
3732  F20C C3 00 00     CONOUT:	JP  0
3733  F20F C3 00 00     LIST:	JP  0
3734  F212 C3 00 00     PUNCH:	JP  0
3735  F215 C3 00 00     READER:	JP  0
3736  F218 C3 00 00     HOME:	JP  0
3737  F21B C3 00 00     SELDSK:	JP	0
3738  F21E C3 00 00     SETTRK:	JP  0
3739  F221 C3 00 00     SETSEC:	JP  0
3740  F224 C3 00 00     SETDMA:	JP  0
3741  F227 C3 00 00     READ:	JP  0
3742  F22A C3 00 00     WRITE:	JP  0
3743  F22D C3 00 00     PRSTAT:	JP  0
3744  F230 C3 00 00     SECTRN:	JP  0
# file closed: CPM22.asm
