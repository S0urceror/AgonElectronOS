; BINTRP.MAC

; BASIC interpreter main functions, MSX 1 version (version 1.0)

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by ASCII and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders


        .Z80
        ASEG
        ORG     394ah;392EH


        INCLUDE MSX.INC


BEEP    EQU     00C0H
CLS     EQU     00C3H
PINLIN  EQU     00AEH
INLIN   EQU     00B1H
QINLIN  EQU     00B4H
ISCNTC  EQU     00BAH
CKCNTC  EQU     00BDH
TOTEXT  EQU     00D2H
ISFLIO  EQU     014AH

USRTAB  EQU     0F39AH
LINL40  EQU     0F3AEH
LINL32  EQU     0F3AFH
LINLEN  EQU     0F3B0H
CLMLST  EQU     0F3B2H
ENDPRG  EQU     0F40FH
ERRFLG  EQU     0F414H
LPTPOS  EQU     0F415H
PRTFLG  EQU     0F416H
VLZADR  EQU     0F419H
VLZDAT  EQU     0F41BH
CURLIN  EQU     0F41CH
KBFMIN  EQU     0F41EH
KBUF    EQU     0F41FH
BUFMIN  EQU     0F55DH
BUF     EQU     0F55EH
TTYPOS  EQU     0F661H
VALTYP  EQU     0F663H
DORES   EQU     0F664H
DONUM   EQU     0F665H
CONTXT  EQU     0F666H
CONSAV  EQU     0F668H
CONTYP  EQU     0F669H
CONLO   EQU     0F66AH
TXTTAB  EQU     0F676H
TEMPST  EQU     0F67AH
DSCTMP  EQU     0F698H
TEMP3   EQU     0F69DH
ENDFOR  EQU     0F6A1H
DATLIN  EQU     0F6A3H
SUBFLG  EQU     0F6A5H
FLGINP  EQU     0F6A6H
TEMP    EQU     0F6A7H
PTRFLG  EQU     0F6A9H
AUTFLG  EQU     0F6AAH
AUTLIN  EQU     0F6ABH
AUTINC  EQU     0F6ADH
SAVTXT  EQU     0F6AFH
SAVSTK  EQU     0F6B1H
ERRLIN  EQU     0F6B3H
DOT     EQU     0F6B5H
ERRTXT  EQU     0F6B7H
ONELIN  EQU     0F6B9H
ONEFLG  EQU     0F6BBH
TEMP2   EQU     0F6BCH
OLDLIN  EQU     0F6BEH
OLDTXT  EQU     0F6C0H
VARTAB  EQU     0F6C2H
ARYTAB  EQU     0F6C4H
STREND  EQU     0F6C6H
DATPTR  EQU     0F6C8H
DEFTBL  EQU     0F6CAH
PRMSTK  EQU     0F6E4H
PRMLEN  EQU     0F6E6H
PARM1   EQU     0F6E8H
PRMLN2  EQU     0F74EH
PARM2   EQU     0F750H
NOFUNS  EQU     0F7B7H
FUNACT  EQU     0F7BAH
TRCFLG  EQU     0F7C4H
DAC     EQU     0F7F6H
PTRFIL  EQU     0F864H
NLONLY  EQU     0F87CH
ONGSBF  EQU     0FBD8H
OLDSCR  EQU     0FCB0H

H.PRGE  EQU     0FEF8H
H.ERRP  EQU     0FEFDH
H.ERRF  EQU     0FF02H
H.READ  EQU     0FF07H
H.MAIN  EQU     0FF0CH
H.DIRD  EQU     0FF11H
H.FINI  EQU     0FF16H
H.FINE  EQU     0FF1BH
H.CRUN  EQU     0FF20H
H.CRUS  EQU     0FF25H
H.ISRE  EQU     0FF2AH
H.NTFN  EQU     0FF2FH
H.NOTR  EQU     0FF34H
H.SNGF  EQU     0FF39H
H.NEWS  EQU     0FF3EH
H.GONE  EQU     0FF43H
H.CHRG  EQU     0FF48H
H.RETU  EQU     0FF4DH
H.PRTF  EQU     0FF52H
H.COMP  EQU     0FF57H
H.FINP  EQU     0FF5CH
H.TRMN  EQU     0FF61H
H.FRME  EQU     0FF66H
H.NTPL  EQU     0FF6BH
H.EVAL  EQU     0FF70H
H.OKNO  EQU     0FF75H
H.FING  EQU     0FF7AH
H.ISMI  EQU     0FF7FH
H.WIDT  EQU     0FF84H
H.LIST  EQU     0FF89H
H.BUFL  EQU     0FF8EH
H.FRQI  EQU     0FF93H
H.SCNE  EQU     0FF98H
H.ERRO  EQU     0FFB1H


        PUBLIC  SNERR
        PUBLIC  UFERR
        PUBLIC  REERR
        PUBLIC  OVERR
        PUBLIC  MOERR
        PUBLIC  TMERR
        PUBLIC  FCERR
        PUBLIC  DV0ERR
        PUBLIC  NFERR
        PUBLIC  DDERR
        PUBLIC  USERR
        PUBLIC  ERROR
        PUBLIC  REDDY
        PUBLIC  FRMEVL
        PUBLIC  GETBYT
        PUBLIC  GETUIN
        PUBLIC  GTBYTC
        PUBLIC  FRMPRN
        PUBLIC  FRMEQL
        PUBLIC  CONINT
        PUBLIC  NEWSTT
        PUBLIC  NEWSTN
        PUBLIC  STPRDY
        PUBLIC  READY
        PUBLIC  NULSTR
        PUBLIC  DEPTR
        PUBLIC  SCCALL
        PUBLIC  SCCLIN
        PUBLIC  SCCPTR
        PUBLIC  FINPRT
        PUBLIC  MAKUPL
        PUBLIC  MAKUPS
        PUBLIC  MORCP2
        PUBLIC  FINI
        PUBLIC  DOASIG
        PUBLIC  LETCON
        PUBLIC  FRQINT
        PUBLIC  MAIN
        PUBLIC  GONE
        PUBLIC  ISVAR
        PUBLIC  INTIDX
        PUBLIC  INTID2
        PUBLIC  FRMCHK
        PUBLIC  LPOPER
        PUBLIC  TSTOP
        PUBLIC  GIVDBL
        PUBLIC  EVAL
        PUBLIC  LINKER
        PUBLIC  GOSUBT
        PUBLIC  LINGET
        PUBLIC  FNDLIN
        PUBLIC  BRKTXT
        PUBLIC  ERRFIN
        PUBLIC  FNDFOR
        PUBLIC  NXTCON
        PUBLIC  SYNCHR
        PUBLIC  CHRGTR
        PUBLIC  CHRGT2
        PUBLIC  GETYPR
        PUBLIC  OCTCNS
        PUBLIC  INTXT
        PUBLIC  MINPLS
        PUBLIC  GETIN2
        PUBLIC  LIST
        PUBLIC  SNGFLT
	PUBLIC	READYR
        PUBLIC  FLTLIN

        EXTRN   DECSUB
        EXTRN   DECADD
        EXTRN   DECMUL
        EXTRN   DECDIV
        EXTRN   DCOMP
        EXTRN   SGNADD
        EXTRN   SGNSUB
        EXTRN   SGNMUL
        EXTRN   SGNDIV
        EXTRN   COS
        EXTRN   SIN
        EXTRN   TAN
        EXTRN   ATN
        EXTRN   LOG
        EXTRN   SQR
        EXTRN   EXP
        EXTRN   RND
        EXTRN   SIGN
        EXTRN   ABSFN
        EXTRN   SGN
        EXTRN   VINT
        EXTRN   PUSHF
        EXTRN   MOVFR
        EXTRN   MOVRF
        EXTRN   VMOVE
        EXTRN   VMOVFM
        EXTRN   VMOVAF
        EXTRN   VMOVMF
        EXTRN   FCOMP
        EXTRN   ICOMP
        EXTRN   FRCINT
        EXTRN   FRCSNG
        EXTRN   FIXER
        EXTRN   ISUB
        EXTRN   IADD
        EXTRN   IMULT
        EXTRN   IDIV
        EXTRN   IMOD
        EXTRN   FIN
        EXTRN   FOUT
        EXTRN   FOUTO
        EXTRN   FOUTH
        EXTRN   SGNEXP
        EXTRN   DBLEXP
        EXTRN   INTEXP
        EXTRN   CHKSTR
        EXTRN   FRCDBL
        EXTRN   BLTU
        EXTRN   GETSTK
        EXTRN   RUNC
        EXTRN   CLEARC
        EXTRN   STKERR
        EXTRN   LINPRT
        EXTRN   INPRT
        EXTRN   PRGFIN
        EXTRN   FINLPT
        EXTRN   PTRGET
        EXTRN   PTRGT2
        EXTRN   ISLET
        EXTRN   ISLET2
        EXTRN   ENDS
        EXTRN   STOPS
        EXTRN   STPEND
        EXTRN   ENDCON
        EXTRN   STROUT
        EXTRN   FILIDX
        EXTRN   CRDONZ
        EXTRN   CRDO
        EXTRN   CONIA
        EXTRN   CONSUI
        EXTRN   CONSIH
        EXTRN   STRLIT
        EXTRN   STRLTI
        EXTRN   STRLT3
        EXTRN   STRLT2
        EXTRN   POPHRT
        EXTRN   FONE
        EXTRN   ISIGN
        EXTRN   VSIGN
        EXTRN   MOVE1
        EXTRN   MAKINT
        EXTRN   VNEG
        EXTRN   STRCPY
        EXTRN   FRETMS
        EXTRN   STRPRT
        EXTRN   OUTCH1
        EXTRN   PTRGTV
        EXTRN   CRFIN
        EXTRN   DIRDO
        EXTRN   TRPHDL
        EXTRN   TRPEXE
        EXTRN   TRPRSM
        EXTRN   FILINP
        EXTRN   FILGET
        EXTRN   FILIND
        EXTRN   RESFIN
        EXTRN   CAT
        EXTRN   SGNDVT
        EXTRN   STRCMP
        EXTRN   PUTTMP
        EXTRN   FREDAC
        EXTRN   PPSWRT
        EXTRN   PRINUS
        EXTRN   GLINE
        EXTRN   DLINE
        EXTRN   OUTDO
        EXTRN   DCOMPR
        EXTRN   CALLF

        EXTRN   DIM
        EXTRN   NEXT
        EXTRN   RESTOR
        EXTRN   CLEAR
        EXTRN   SCRATH
        EXTRN   CONT
        EXTRN   CSAVE
        EXTRN   CLOAD
        EXTRN   TON
        EXTRN   TOFF
        EXTRN   SWAP
        EXTRN   ERASE
        EXTRN   DSKCHI
        EXTRN   INSTR
        EXTRN   INKEY
        EXTRN   STRNG$
        EXTRN   FIXINP
        EXTRN   CSRLIN
        EXTRN   POINT
        EXTRN   PLAY
        EXTRN   PLAY$
        EXTRN   TIME
        EXTRN   TIME$
        EXTRN   SPRITE
        EXTRN   SPRIT$
        EXTRN   VDP
        EXTRN   VDP$
        EXTRN   BASE
        EXTRN   BASE$
        EXTRN   DSKO$
        EXTRN   SETS
        EXTRN   NAME
        EXTRN   KILL
        EXTRN   IPL
        EXTRN   COPY
        EXTRN   CMD
        EXTRN   DSKF
        EXTRN   DSKI$
        EXTRN   ATTR$
        EXTRN   LSET
        EXTRN   RSET
        EXTRN   FIELD
        EXTRN   MKI$
        EXTRN   MKS$
        EXTRN   MKD$
        EXTRN   CVI
        EXTRN   CVS
        EXTRN   CVD
        EXTRN   MOTOR
        EXTRN   SOUND
        EXTRN   PUTS
        EXTRN   GETS
        EXTRN   LOCATE
        EXTRN   INTS
        EXTRN   ONGOT
        EXTRN   KEYS
        EXTRN   STICK
        EXTRN   TRIG
        EXTRN   PDL
        EXTRN   PAD
        EXTRN   COLOR
        EXTRN   SCREEN
        EXTRN   VPOKE
        EXTRN   VPEEK
        EXTRN   CHR$
        EXTRN   SPACE$
        EXTRN   LEFT$
        EXTRN   RIGHT$
        EXTRN   MID$
        EXTRN   MIDS
        EXTRN   VAL
        EXTRN   LEN
        EXTRN   STR$
        EXTRN   ASC
        EXTRN   FRE
        EXTRN   OCT$
        EXTRN   HEX$
        EXTRN   BIN$
        EXTRN   OPEN
        EXTRN   LRUN
        EXTRN   LOAD
        EXTRN   MERGE
        EXTRN   SAVE
        EXTRN   CLOSE
        EXTRN   LFILES
        EXTRN   FILES
        EXTRN   LOC
        EXTRN   LOF
        EXTRN   EOF
        EXTRN   FPOS
        EXTRN   POINT
        EXTRN   CIRCLE
        EXTRN   DRAW
        EXTRN   PAINT
        EXTRN   PSET
        EXTRN   PRESET
        EXTRN   CALL$
        EXTRN   CALLS
        EXTRN   KEYS
        EXTRN   MAXS
        EXTRN   BLOAD
        EXTRN   BSAVE
        EXTRN   STRIGS
        EXTRN   GETENT

_RST    MACRO   X
        IFIDN   <X>,<SYNCHR>
        RST     08H
        ENDIF
        IFIDN   <X>,<CHRGTR>
        RST     10H
        ENDIF
        IFIDN   <X>,<OUTDO>
        RST     18H
        ENDIF
        IFIDN   <X>,<DCOMPR>
        RST     20H
        ENDIF
        IFIDN   <X>,<GETYPR>
        CALL    GETENT ;RST     28H
        ENDIF
        IFIDN   <X>,<CALLF>
        RST     30H
        ENDIF
        ENDM

KEYWRD  MACRO   X,Y
G       ASET    0
Q       ASET    0
        IRPC    D,<X>
        IF      G EQ 0
G       ASET    1
        ELSE
        IF      Q NE 0
        DEFB    Q
        ENDIF
Q       ASET    "&D"
        ENDIF
        ENDM
        DEFB    Q+128
        DEFB    Y
        ENDM

TOKEN   MACRO   X,Y
        DEFB    "&X"+128
        DEFB    Y
        ENDM


; BASIC tokens
;
; 00                    line endmarker
; 01-0A                 unknown
; 0B LLHH               octal number
; 0C LLHH               hexadecimal number
; 0D LLHH               linepointer
; 0E LLHH               linenumber
; 0F LL                 integer 11-255
; 10                    internal token
; 11                    integer 0
; 12                    integer 1
; 13                    integer 2
; 14                    integer 3
; 15                    integer 4
; 16                    integer 5
; 17                    integer 6
; 18                    integer 7
; 19                    integer 8
; 1A                    integer 9
; 1B                    integer 10
; 1C LLHH               integer
; 1D EEDDDDDD           single real
; 1E                    internal token
; 1F EEDDDDDDDDDDDDDD   double real
; 20-7F                 ASCII chars
; 80                    unknown token
; 81-D8                 statement tokens
; D9-ED                 other tokens
; EE                    >
; EF                    =
; F0                    <
; F1                    +
; F2                    -
; F3                    *
; F4                    /
; F5                    ^
; F6                    AND
; F7                    OR
; F8                    XOR
; F9                    EQV
; FA                    IMP
; FB                    MOD
; FC                    \
; FD                    unknown token, other microsoft basic versions use this to extend token range
; FE                    unknown token, other microsoft basic versions use this to extend token range
; FF TT                 function token

; START	SUBTTL	BINTRP

	SUBTTL	BINTRP

;       Table   addresses of BASIC statement token service routines
;       Remark  start with token 081H, ends with token 0D8H

I392E:  DEFW    ENDS                    ; END
        DEFW    FOR                     ; FOR
        DEFW    NEXT                    ; NEXT
        DEFW    DATA                    ; DATA, skip to end of statement
        DEFW    INPUT                   ; INPUT
        DEFW    DIM                     ; DIM
        DEFW    READ                    ; READ
        DEFW    LET                     ; LET
        DEFW    GOTO                    ; GOTO
        DEFW    RUN                     ; RUN
        DEFW    IFS                     ; IF
        DEFW    RESTOR                  ; RESTORE
        DEFW    GOSUB                   ; GOSUB
        DEFW    RETURN                  ; RETURN
        DEFW    REM                     ; REM, skip to end of BASIC line
        DEFW    STOPS                   ; STOP
        DEFW    PRINT                   ; PRINT
        DEFW    CLEAR                   ; CLEAR
        DEFW    LIST                    ; LIST
        DEFW    SCRATH                  ; NEW
        DEFW    ONGOTO                  ; ON
        DEFW    FNWAIT                  ; WAIT
        DEFW    DEF                     ; DEF
        DEFW    POKE                    ; POKE
        DEFW    CONT                    ; CONT
        DEFW    CSAVE                   ; CSAVE (token not used with GW-BASIC)
        DEFW    CLOAD                   ; CLOAD (token not used with GW-BASIC)
        DEFW    FNOUT                   ; OUT
        DEFW    LPRINT                  ; LPRINT
        DEFW    LLIST                   ; LLIST
        DEFW    CLS                     ; CLS (token not used with GW-BASIC)
        DEFW    WIDTH                   ; WIDTH
        DEFW    ELSES                   ; ELSE, skip to end of BASIC line
        DEFW    TON                     ; TRON
        DEFW    TOFF                    ; TROFF
        DEFW    SWAP                    ; SWAP
        DEFW    ERASE                   ; ERASE
        DEFW    ERRORS                  ; ERROR
        DEFW    RESUME                  ; RESUME
        DEFW    DELETE                  ; DELETE
        DEFW    AUTO                    ; AUTO
        DEFW    RESEQ                   ; RENUM
        DEFW    DEFSTR                  ; DEFSTR
        DEFW    DEFINT                  ; DEFINT
        DEFW    DEFREA                  ; DEFSNG
        DEFW    DEFDBL                  ; DEFDBL
        DEFW    LINE                    ; LINE

; from here tokens are incompatible with GW-BASIC

        DEFW    OPEN                    ; OPEN
        DEFW    FIELD                   ; FIELD
        DEFW    GETS                    ; GET
        DEFW    PUTS                    ; PUT
        DEFW    CLOSE                   ; CLOSE
        DEFW    LOAD                    ; LOAD
        DEFW    MERGE                   ; MERGE
        DEFW    FILES                   ; FILES
        DEFW    LSET                    ; LSET
        DEFW    RSET                    ; RSET
        DEFW    SAVE                    ; SAVE
        DEFW    LFILES                  ; LFILES
        DEFW    CIRCLE                  ; CIRCLE
        DEFW    COLOR                   ; COLOR
        DEFW    DRAW                    ; DRAW
        DEFW    PAINT                   ; PAINT
        DEFW    BEEP                    ; BEEP
        DEFW    PLAY                    ; PLAY
        DEFW    PSET                    ; PSET
        DEFW    PRESET                  ; PRESET
        DEFW    SOUND                   ; SOUND
        DEFW    SCREEN                  ; SCREEN
        DEFW    VPOKE                   ; VPOKE
        DEFW    SPRITE                  ; SPRITE
        DEFW    VDP                     ; VDP
        DEFW    BASE                    ; BASE
        DEFW    CALLS                   ; CALL
        DEFW    TIME                    ; TIME
        DEFW    KEYS                    ; KEY
        DEFW    MAXS                    ; MAX
        DEFW    MOTOR                   ; MOTOR
        DEFW    BLOAD                   ; BLOAD
        DEFW    BSAVE                   ; BSAVE
        DEFW    DSKO$                   ; DSKO$
        DEFW    SETS                    ; SET
        DEFW    NAME                    ; NAME
        DEFW    KILL                    ; KILL
        DEFW    IPL                     ; IPL
        DEFW    COPY                    ; COPY
        DEFW    CMD                     ; CMD
        DEFW    LOCATE                  ; LOCATE

;       Table   addresses of BASIC function token service routines
;       Remark  

I39DE:  DEFW    LEFT$                   ; LEFT$
        DEFW    RIGHT$                  ; RIGHT$
        DEFW    MID$                    ; MID$
        DEFW    SGN                     ; SGN
        DEFW    VINT                    ; INT
        DEFW    ABSFN                   ; ABS
        DEFW    SQR                     ; SQR
        DEFW    RND                     ; RND
        DEFW    SIN                     ; SIN
        DEFW    LOG                     ; LOG
        DEFW    EXP                     ; EXP
        DEFW    COS                     ; COS
        DEFW    TAN                     ; TAN
        DEFW    ATN                     ; ATN
        DEFW    FRE                     ; FRE
        DEFW    FNINP                   ; INP
        DEFW    POS                     ; POS
        DEFW    LEN                     ; LEN
        DEFW    STR$                    ; STR$
        DEFW    VAL                     ; VAL
        DEFW    ASC                     ; ASC
        DEFW    CHR$                    ; CHR$
        DEFW    PEEK                    ; PEEK
        DEFW    VPEEK                   ; VPEEK
        DEFW    SPACE$                  ; SPACE$
        DEFW    OCT$                    ; OCT$
        DEFW    HEX$                    ; HEX$
        DEFW    LPOS                    ; LPOS
        DEFW    BIN$                    ; BIN$
        DEFW    FRCINT                  ; CINT
        DEFW    FRCSNG                  ; CSNG
        DEFW    FRCDBL                  ; CDBL
        DEFW    FIXER                   ; FIX
        DEFW    STICK                   ; STICK
        DEFW    TRIG                    ; TRIG
        DEFW    PDL                     ; PDL
        DEFW    PAD                     ; PAD
        DEFW    DSKF                    ; DSKF
        DEFW    FPOS                    ; FPOS
        DEFW    CVI                     ; CVI
        DEFW    CVS                     ; CVS
        DEFW    CVD                     ; CVD
        DEFW    EOF                     ; EOF
        DEFW    LOC                     ; LOC
        DEFW    LOF                     ; LOF
        DEFW    MKI$                    ; MKI$
        DEFW    MKS$                    ; MKS$
        DEFW    MKD$                    ; MKD$

;       Table   pointers to the start of keywords of a given letter
;       Remark  start with the pointer for all "A" keywords and ends with "Z" keywords

I3A3E:  DEFW    T3A72
        DEFW    T3A88
        DEFW    T3A9F
        DEFW    T3AF3
        DEFW    T3B2E
        DEFW    T3B4F
        DEFW    T3B69
        DEFW    T3B7B
        DEFW    T3B80
        DEFW    T3B9F
        DEFW    T3BA0
        DEFW    T3BA8
        DEFW    T3BE8
        DEFW    T3C09
        DEFW    T3C18
        DEFW    T3C2B
        DEFW    T3C5D
        DEFW    T3C5E
        DEFW    T3C8E
        DEFW    T3CDB
        DEFW    T3CF6
        DEFW    T3CFF
        DEFW    T3D16
        DEFW    T3D20
        DEFW    T3D24
        DEFW    T3D25 

T3A72:  KEYWRD  <AUTO>,0A9H
        KEYWRD  <AND>,0F6H
        KEYWRD  <ABS>,006H
        KEYWRD  <ATN>,00EH
        KEYWRD  <ASC>,015H
        KEYWRD  <ATTR$>,0E9H
        DEFB    0

T3A88:  KEYWRD  <BASE>,0C9H
        KEYWRD  <BSAVE>,0D0H
        KEYWRD  <BLOAD>,0CFH
        KEYWRD  <BEEP>,0C0H
        KEYWRD  <BIN$>,01DH
        DEFB    0

T3A9F:  KEYWRD  <CALL>,0CAH
        KEYWRD  <CLOSE>,0B4H
        KEYWRD  <COPY>,0D6H
        KEYWRD  <CONT>,099H
        KEYWRD  <CLEAR>,092H
        KEYWRD  <CLOAD>,09BH
        KEYWRD  <CSAVE>,09AH
        KEYWRD  <CSRLIN>,0E8H
        KEYWRD  <CINT>,01EH
        KEYWRD  <CSNG>,01FH
        KEYWRD  <CDBL>,020H
        KEYWRD  <CVI>,028H
        KEYWRD  <CVS>,029H
        KEYWRD  <CVD>,02AH
        KEYWRD  <COS>,00CH
        KEYWRD  <CHR$>,016H
        KEYWRD  <CIRCLE>,0BCH
        KEYWRD  <COLOR>,0BDH
        KEYWRD  <CLS>,09FH
        KEYWRD  <CMD>,0D7H
        DEFB    0

T3AF3:  KEYWRD  <DELETE>,0A8H
        KEYWRD  <DATA>,084H
        KEYWRD  <DIM>,086H
        KEYWRD  <DEFSTR>,0ABH
        KEYWRD  <DEFINT>,0ACH
        KEYWRD  <DEFSNG>,0ADH
        KEYWRD  <DEFDBL>,0AEH
        KEYWRD  <DSKO$>,0D1H
        KEYWRD  <DEF>,097H
        KEYWRD  <DSKI$>,0EAH
        KEYWRD  <DSKF>,026H
        KEYWRD  <DRAW>,0BEH
        DEFB    0

T3B2E:  KEYWRD  <ELSE>,0A1H
        KEYWRD  <END>,081H
        KEYWRD  <ERASE>,0A5H
        KEYWRD  <ERROR>,0A6H
        KEYWRD  <ERL>,0E1H
        KEYWRD  <ERR>,0E2H
        KEYWRD  <EXP>,00BH
        KEYWRD  <EOF>,02BH
        KEYWRD  <EQV>,0F9H
        DEFB    0

T3B4F:  KEYWRD  <FOR>,082H
        KEYWRD  <FIELD>,0B1H
        KEYWRD  <FILES>,0B7H
        KEYWRD  <FN>,0DEH
        KEYWRD  <FRE>,00FH
        KEYWRD  <FIX>,021H
        KEYWRD  <FPOS>,027H
        DEFB    0

T3B69:  KEYWRD  <GOTO>,089H
        KEYWRD  <GO TO>,089H
        KEYWRD  <GOSUB>,08DH
        KEYWRD  <GET>,0B2H
        DEFB    0

T3B7B:  KEYWRD  <HEX$>,01BH
        DEFB    0

T3B80:  KEYWRD  <INPUT>,085H
        KEYWRD  <IF>,08BH
        KEYWRD  <INSTR>,0E5H
        KEYWRD  <INT>,005H
        KEYWRD  <INP>,010H
        KEYWRD  <IMP>,0FAH
        KEYWRD  <INKEY$>,0ECH
        KEYWRD  <IPL>,0D5H
        DEFB    0

T3B9F:  DEFB    0

T3BA0:  KEYWRD  <KILL>,0D4H
        KEYWRD  <KEY>,0CCH
        DEFB    0

T3BA8:  KEYWRD  <LPRINT>,09DH
        KEYWRD  <LLIST>,09EH
        KEYWRD  <LPOS>,01CH
        KEYWRD  <LET>,088H
        KEYWRD  <LOCATE>,0D8H
        KEYWRD  <LINE>,0AFH
        KEYWRD  <LOAD>,0B5H
        KEYWRD  <LSET>,0B8H
        KEYWRD  <LIST>,093H
        KEYWRD  <LFILES>,0BBH
        KEYWRD  <LOG>,00AH
        KEYWRD  <LOC>,02CH
        KEYWRD  <LEN>,012H
        KEYWRD  <LEFT$>,001H
        KEYWRD  <LOF>,02DH
        DEFB    0

T3BE8:  KEYWRD  <MOTOR>,0CEH
        KEYWRD  <MERGE>,0B6H
        KEYWRD  <MOD>,0FBH
        KEYWRD  <MKI$>,02EH
        KEYWRD  <MKS$>,02FH
        KEYWRD  <MKD$>,030H
        KEYWRD  <MID$>,003H
        KEYWRD  <MAX>,0CDH
        DEFB    0

T3C09:  KEYWRD  <NEXT>,083H
        KEYWRD  <NAME>,0D3H
        KEYWRD  <NEW>,094H
        KEYWRD  <NOT>,0E0H
        DEFB    0

T3C18:  KEYWRD  <OPEN>,0B0H
        KEYWRD  <OUT>,09CH
        KEYWRD  <ON>,095H
        KEYWRD  <OR>,0F7H
        KEYWRD  <OCT$>,01AH
        KEYWRD  <OFF>,0EBH
        DEFB    0

T3C2B:  KEYWRD  <PRINT>,091H
        KEYWRD  <PUT>,0B3H
        KEYWRD  <POKE>,098H
        KEYWRD  <POS>,011H
        KEYWRD  <PEEK>,017H
        KEYWRD  <PSET>,0C2H
        KEYWRD  <PRESET>,0C3H
        KEYWRD  <POINT>,0EDH
        KEYWRD  <PAINT>,0BFH
        KEYWRD  <PDL>,024H
        KEYWRD  <PAD>,025H
        KEYWRD  <PLAY>,0C1H
        DEFB    0

T3C5D:  DEFB    0

T3C5E:  KEYWRD  <RETURN>,08EH
        KEYWRD  <READ>,087H
        KEYWRD  <RUN>,08AH
        KEYWRD  <RESTORE>,08CH
        KEYWRD  <REM>,08FH
        KEYWRD  <RESUME>,0A7H
        KEYWRD  <RSET>,0B9H
        KEYWRD  <RIGHT$>,002H
        KEYWRD  <RND>,008H
        KEYWRD  <RENUM>,0AAH
        DEFB    0

T3C8E:  KEYWRD  <SCREEN>,0C5H
        KEYWRD  <SPRITE>,0C7H
        KEYWRD  <STOP>,090H
        KEYWRD  <SWAP>,0A4H
        KEYWRD  <SET>,0D2H
        KEYWRD  <SAVE>,0BAH
        KEYWRD  <SPC(>,0DFH
        KEYWRD  <STEP>,0DCH
        KEYWRD  <SGN>,004H
        KEYWRD  <SQR>,007H
        KEYWRD  <SIN>,009H
        KEYWRD  <STR$>,013H
        KEYWRD  <STRING$>,0E3H
        KEYWRD  <SPACE$>,019H
        KEYWRD  <SOUND>,0C4H
        KEYWRD  <STICK>,022H
        KEYWRD  <STRIG>,023H
        DEFB    0

T3CDB:  KEYWRD  <THEN>,0DAH
        KEYWRD  <TRON>,0A2H
        KEYWRD  <TROFF>,0A3H
        KEYWRD  <TAB(>,0DBH
        KEYWRD  <TO>,0D9H
        KEYWRD  <TIME>,0CBH
        KEYWRD  <TAN>,00DH
        DEFB    0

T3CF6:  KEYWRD  <USING>,0E4H
        KEYWRD  <USR>,0DDH
        DEFB    0

T3CFF:  KEYWRD  <VAL>,014H
        KEYWRD  <VARPTR>,0E7H
        KEYWRD  <VDP>,0C8H
        KEYWRD  <VPOKE>,0C6H
        KEYWRD  <VPEEK>,018H
        DEFB    0

T3D16:  KEYWRD  <WIDTH>,0A0H
        KEYWRD  <WAIT>,096H
        DEFB    0

T3D20:  KEYWRD  <XOR>,0F8H
        DEFB    0

T3D24:  DEFB    0

T3D25:  DEFB    0

I3D26:  TOKEN   !+,0F1H
        TOKEN   !-,0F2H
        TOKEN   !*,0F3H
        TOKEN   !/,0F4H
        TOKEN   !^,0F5H
        TOKEN   !\,0FCH
        ;DEFB    "\'"+128
        ;DEFB    0E6h
        TOKEN   !',0E6H
        TOKEN   !>,0EEH
        TOKEN   !=,0EFH
        TOKEN   !<,0F0H
        DEFB    0

I3D3B:  DEFB    079H                    ; +
        DEFB    079H                    ; -
        DEFB    07CH                    ; *
        DEFB    07CH                    ; /
        DEFB    07FH                    ; ^
        DEFB    050H                    ; AND
        DEFB    046H                    ; OR
        DEFB    03CH                    ; XOR
        DEFB    032H                    ; EQV
        DEFB    028H                    ; IMP
        DEFB    07AH                    ; MOD
        DEFB    07BH                    ; \

I3D47:  DEFW    FRCDBL                  ; convert DAC to double real
        DEFW    0
        DEFW    FRCINT                  ; convert DAC to integer
        DEFW    CHKSTR                  ; check if string (error if not)
        DEFW    FRCSNG                  ; convert DAC to single real

I3D51:  DEFW    DECADD                  ; double real addition DECADD
        DEFW    DECSUB                  ; double real subtract DECSUB
        DEFW    DECMUL                  ; double real multiply DECMUL
        DEFW    DECDIV                  ; double real divide DECDIV
        DEFW    DBLEXP                  ; double real to the power
        DEFW    DCOMP                   ; double real compare

I3D5D:  DEFW    SGNADD                  ; single real addition
        DEFW    SGNSUB                  ; single real subtract
        DEFW    SGNMUL                  ; single real muliply
        DEFW    SGNDIV                  ; single real divide
        DEFW    SGNEXP                  ; single real to the power
        DEFW    FCOMP                   ; single real compare (FCOMP)

I3D69:  DEFW    IADD                    ; integer addition
        DEFW    ISUB                    ; integer subtract
        DEFW    IMULT                   ; integer multiply
        DEFW    INTDIV                  ; integer divide
        DEFW    INTEXP                  ; integer to the power
        DEFW    ICOMP                   ; integer compare

I3D75:  DEFB    0
        DEFB    "NEXT without FOR",0
        DEFB    "Syntax error",0
        DEFB    "RETURN without GOSUB",0
        DEFB    "Out of DATA",0
        DEFB    "Illegal function call",0
        DEFB    "Overflow",0
        DEFB    "Out of memory",0
        DEFB    "Undefined line number",0
        DEFB    "Subscript out of range",0
        DEFB    "Redimensioned array",0
        DEFB    "Division by zero",0
        DEFB    "Illegal direct",0
        DEFB    "Type mismatch",0
        DEFB    "Out of string space",0
        DEFB    "String too long",0
        DEFB    "String formula too complex",0
        DEFB    "Can't CONTINUE",0
        DEFB    "Undefined user function",0
        DEFB    "Device I/O error",0
        DEFB    "Verify error",0
        DEFB    "No RESUME",0
        DEFB    "RESUME without error",0
        DEFB    "Unprintable error",0
        DEFB    "Missing operand",0
        DEFB    "Line buffer overflow",0
        DEFB    "FIELD overflow",0
        DEFB    "Internal error",0
        DEFB    "Bad file number",0
        DEFB    "File not found",0
        DEFB    "File already open",0
        DEFB    "Input past end",0
        DEFB    "Bad file name",0
        DEFB    "Direct statement in file",0
        DEFB    "Sequential I/O only",0
        DEFB    "File not OPEN",0 

INTXT:
I3FD2:  DEFB    " in ",0
NULSTR  EQU     $-1

REDDY:
I3FD7:  DEFB    "Ok",13,10,0

BRKTXT:
I3FDC:  DEFB    "Break",0

;       Subroutine      search FOR block on stack (skip 2 words)
;       Inputs          DE = address loop variable (0 if any FOR block)
;       Outputs         Zx set if found, Zx reset if other block found first

FNDFOR:
C3FE2:  LD      HL,4                    ; skip this routine return address and main loop return address
        ADD     HL,SP

;       Subroutine      search FOR block
;       Inputs          ________________________
;       Outputs         ________________________

C3FE6:  LD      A,(HL)
        INC     HL
        CP      82H                     ; FOR block ?
        RET     NZ                      ; nope, quit
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; address loop variable
        INC     HL
        PUSH    HL
        LD      H,B
        LD      L,C
        LD      A,D
        OR      E                       ; variable specified ?
        EX      DE,HL
        JR      Z,J3FF9                 ; nope, found
        EX      DE,HL
        _RST    DCOMPR                  ; same variable ?
J3FF9:  LD      BC,25-3
        POP     HL
        RET     Z                       ; yep, quit
        ADD     HL,BC
        JR      C3FE6                   ; next block

;       Subroutine      INP function
;       Inputs          ________________________
;       Outputs         ________________________

FNINP:
C4001:  CALL    FRQINT                  ; convert address to integer
        LD      B,H
        LD      C,L
        RST     038h 
        defb    0ffh ; IN      A,(C)
        JP      SNGFLT                  ; byte to DAC

;       Subroutine      evaluate address operand and byte operand seperated by a ","
;       Inputs          ________________________
;       Outputs         ________________________

C400B:  CALL    GETUIN                  ; evaluate address operand
        PUSH    DE
        _RST    SYNCHR
        DEFB    ","			; check for ,
        CALL    GETBYT                  ; evaluate byte operand
        POP     BC
        RET

;       Subroutine      OUT statement
;       Inputs          ________________________
;       Outputs         ________________________

FNOUT:
C4016:  CALL    C400B                   ; evaluate address operand and byte operand seperated by a ","
        RST     28h ; OUT     (C),A
        defb    0ffh
        RET

;       Subroutine      WAIT statement
;       Inputs          ________________________
;       Outputs         ________________________

FNWAIT:
C401C:  CALL    C400B                   ; evaluate address operand and byte operand seperated by a ","
        PUSH    BC
        PUSH    AF
        LD      E,0                     ; assume no XOR parameter
        DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        JR      Z,J402C                 ; yep, start wait
        _RST    SYNCHR
        DEFB    ","			; check for ,
        CALL    GETBYT                  ; evaluate byte operand
J402C:  POP     AF
        LD      D,A                     ; AND parameter
        POP     BC                      ; i/o address
J402F:  CALL    CKCNTC
        RST     038h 
        defb    0ffh ; IN      A,(C)
        XOR     E
        AND     D
        JR      Z,J402F
        RET

;       Subroutine      at end of BASIC program
;       Inputs          ________________________
;       Outputs         ________________________

J4039:  CALL    H.PRGE                  ; hook program ends
        LD      HL,(CURLIN)
        LD      A,H
        AND     L
        INC     A                       ; interpreter in direct mode ?
        JR      Z,J404C                 ; yep, skip error handling stuff
        LD      A,(ONEFLG)
        OR      A                       ; in ERROR handling routine ?
        LD      E,21
        JR      NZ,ERROR                ; yep, no resume error
J404C:  JP      ENDCON                  ; END without closing i/o channels, clearing

J404F:  LD      HL,(DATLIN)
        LD      (CURLIN),HL

SNERR:
J4055:  LD      E,2
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

DV0ERR:
J4058:  LD      E,11
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

NFERR:
J405B:  LD      E,1
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

DDERR:
J405E:  LD      E,10
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

UFERR:
J4061:  LD      E,18
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

REERR:
J4064:  LD      E,22
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

OVERR:
J4067:  LD      E,6
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

MOERR:
J406A:  LD      E,24
        DEFB    001H			; LD BC,xxxx, trick to skip next instruction

TMERR:
J406D:  LD      E,13

;       Subroutine      BASIC error
;       Inputs          E = errornumber
;       Outputs         ________________________

ERROR:
J406F:  CALL    H.ERRO                  ; hook start of the BASIC error routine
        XOR     A
        LD      (NLONLY),A              ; not loading basic program, close i/o channels when requested
        LD      HL,(VLZADR)
        LD      A,H
        OR      L
        JR      Z,J4087
        LD      A,(VLZDAT)
        LD      (HL),A
        LD      HL,0
        LD      (VLZADR),HL
J4087:  EI
        LD      HL,(CURLIN)
        LD      (ERRLIN),HL             ; linenumber at error
        LD      A,H
        AND     L
        INC     A                       ; error occured in direct mode ?
        JR      Z,J4096
        LD      (DOT),HL                ; nope, set DOT
J4096:  LD      BC,I40A4
        JR      J409E

;       Subroutine      warm start MSX BASIC
;       Inputs          -
;       Outputs         -

READYR:
J409B:  LD      BC,STPRDY               ; ok and mainloop (+POP)
J409E:  LD      HL,(SAVSTK)
        JP      STKERR                  ; reinitialize stack

I40A4:  POP     BC
        LD      A,E
        LD      C,E
        LD      (ERRFLG),A              ; save errorcode
        LD      HL,(SAVTXT)
        LD      (ERRTXT),HL             ; BASICpointer at error
        EX      DE,HL
        LD      HL,(ERRLIN)
        LD      A,H
        AND     L
        INC     A                       ; error occured in direct mode ?
        JR      Z,J40C0 
        LD      (OLDLIN),HL
        EX      DE,HL
        LD      (OLDTXT),HL             ; nope, save linenumber and BASICpointer for continue
J40C0:  LD      HL,(ONELIN)
        LD      A,H
        OR      L                       ; ERROR handler defined ?
        EX      DE,HL
        LD      HL,ONEFLG
        JR      Z,J40D3                 ; nope, abort
        AND     (HL)                    ; in ERROR handler ?
        JR      NZ,J40D3                ; yep, abort
        DEC     (HL)                    ; flag in ERROR handler
        EX      DE,HL
        JP      J4620                   ; execute statement (execute ERROR handler)

J40D3:  XOR     A
        LD      (HL),A                  ; not in ERROR handler
        LD      E,C                     ; errorcode
        CALL    CRDONZ                  ; fresh line to interpreter output
        LD      HL,I3D75
        CALL    H.ERRP                  ; hook error pointer
        LD      A,E
        CP      60                      ; errorcode 60-255 ?
        JR      NC,J40EC                ; yep, use unprintable error string
        CP      50                      ; errorcode 50-59 ?
        JR      NC,J40EE                ; adjust and search errorstring
        CP      26                      ; errorcode 1-25 ?
        JR      C,J40F1                 ; yep, search errorstring
J40EC:  LD      A,47                    ; unprintable error
J40EE:  SUB     24
        LD      E,A
J40F1:  CALL    REM                     ; skip to end of BASIC line (to search end of errorstring)
        INC     HL
        DEC     E
        JR      NZ,J40F1                ; next errorstring
        PUSH    HL
        LD      HL,(ERRLIN)
        EX      (SP),HL                 ; save linenumber error

ERRFIN:
J40FD:  CALL    H.ERRF
        PUSH    HL
        CALL    TOTEXT                  ; force to text screenmode
        POP     HL
        LD      A,(HL)
        CP      "?"                     ; errorstring start with a "?"
        JR      NZ,J4110                ; nope, print errormessage
        POP     HL                      ; error linenumber
        LD      HL,I3D75
        JR      J40EC                   ; use unprintable error

J4110:  LD      A,7
        _RST    OUTDO                   ; beep to interpreter output
        CALL    STROUT                  ; message to interpreter output
        POP     HL                      ; error linenumber
        LD      A,H
        AND     L
        INC     A                       ; error occured in direct mode ?
        CALL    NZ,INPRT                ; nope, "in" number to interpreter output
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction

;       Subroutine      ok and mainloop (+POP)
;       Inputs          ________________________
;       Outputs         ________________________

STPRDY:
J411E:  POP     BC

;       Subroutine      ok and mainloop
;       Inputs          ________________________
;       Outputs         ________________________

READY:
J411F:  CALL    TOTEXT                  ; force text screenmode
        CALL    FINLPT                  ; end printeroutput
        CALL    PRGFIN                  ; close i/o channel 0 and load HL from (TEMP)
        CALL    H.READ                  ; hook prompt ready
        CALL    CRDONZ                  ; fresh line to interpreter output
        LD      HL,REDDY                ; "Ok" message
        CALL    STROUT                  ; message to interpreter output

;       Subroutine      mainloop
;       Inputs          ________________________
;       Outputs         ________________________

MAIN:
J4134:  CALL    H.MAIN                  ; hook start mainloop
        LD      HL,0FFFFH
        LD      (CURLIN),HL             ; interpreter in direct mode
        LD      HL,ENDPRG
        LD      (SAVTXT),HL
        LD      A,(AUTFLG)
        OR      A                       ; in auto linenumber mode ?
        JR      Z,J415F                 ; nope, skip auto linenumber
        LD      HL,(AUTLIN)             ; current auto linenumber
        PUSH    HL
        CALL    LINPRT                  ; number to interpreter output
        POP     DE
        PUSH    DE
        CALL    FNDLIN                  ; search linenumber from start of program
        LD      A,"*"
        JR      C,J415B                 ; found, existing line indicator
        LD      A," "                   ; not found, new line indicator
J415B:  _RST    OUTDO                   ; lineindicator to interpreter output
        LD      (AUTFLG),A              ; save line exist status
J415F:  CALL    ISFLIO                  ; interpreter input/output device = file ?
        JR      NZ,J4170                ; yep,
        CALL    PINLIN                  ; get line from keyboard
        JR      NC,J4173                ; not aborted, continue
        XOR     A
        LD      (AUTFLG),A              ; quit auto linenumber mode
        JP      MAIN                    ; mainloop

J4170:  CALL    DSKCHI                  ; get line from interpreter input file
J4173:  _RST    CHRGTR                  ; get next BASIC character
        INC     A
        DEC     A                       ; empty line ?
        JR      Z,MAIN                  ; yep, restart mainloop
        PUSH    AF
        CALL    LINGET                  ; collect linenumber
        JR      NC,J4184                ; linenumber ok,
        CALL    ISFLIO                  ; interpreter input/output device = file ?
        JP      Z,SNERR                 ; nope, syntax error
J4184:  CALL    C4514                   ; skip space chars
        LD      A,(AUTFLG)
        OR      A                       ; in auto linenumber mode ?
        JR      Z,J4195                 ; nope, skip check
        CP      "*"                     ; existing linenumber ?
        JR      NZ,J4195                ; nope,
        CP      (HL)                    ; yep, is this the "*" char ?
        JR      NZ,J4195
        INC     HL                      ; yep, skip it
J4195:  LD      A,D
        OR      E
        JR      Z,J419F
        LD      A,(HL)
        CP      " "
        JR      NZ,J419F
        INC     HL
J419F:  PUSH    DE
        CALL    C42B2                   ; encode BASIC line
        POP     DE
        POP     AF
        LD      (SAVTXT),HL
        CALL    H.DIRD
        JR      C,J41B4
        XOR     A
        LD      (AUTFLG),A              ; quit auto linenumber mode
        JP      DIRDO                   ; handle direct statement

J41B4:  PUSH    DE
        PUSH    BC
        _RST    CHRGTR                  ; get next BASIC character
        OR      A
        PUSH    AF                      ; Zx set if empty line
        LD      A,(AUTFLG)
        AND     A                       ; in auto linenumber mode ?
        JR      Z,J41C2                 ; nope,
        POP     AF
        SCF                             ; auto linenumber mode
        PUSH    AF
J41C2:  LD      (DOT),DE
        LD      HL,(AUTINC)
        ADD     HL,DE                   ; new linenumber for auto linenumber mode
        JR      C,J41D7                 ; >65535, end auto line number mode
        PUSH    DE
        LD      DE,65530
        _RST    DCOMPR
        POP     DE                      ; new linenumber < 65530 ?
        LD      (AUTLIN),HL             ; new auto linenumber
        JR      C,J41DB                 ; yep, contine
J41D7:  XOR     A
        LD      (AUTFLG),A              ; quit auto linenumber mode
J41DB:  CALL    FNDLIN                  ; search linenumber from start of program
        JR      C,C41ED                 ; extact match found,
        POP     AF
        PUSH    AF
        JR      NZ,J41EA                ; not found + non empty line,
        JP      NC,USERR                ; not found + no auto + empty line, undefined line number error
                                        ; not found + auto + empty, do nothing
J41E7:  PUSH    BC
        JR      FINI

J41EA:  OR      A                       ; flag line addition
        JR      J41F4

C41ED:  POP     AF
        PUSH    AF
        JR      NZ,J41F3                ; found + non empty line, flag line removeable
        JR      C,J41E7                 ; found + auto + empty line, do nothing
                                        ; found + no auto + empty line, flag line removeable
J41F3:  SCF
J41F4:  PUSH    BC
        PUSH    AF
        PUSH    HL
        CALL    DEPTR                   ; convert to linepointers to linenumbers if needed
        POP     HL
        POP     AF
        POP     BC
        PUSH    BC
        CALL    C,C5405                 ; flag remove, remove line
        POP     DE
        POP     AF                      ; empty line ?
        PUSH    DE
        JR      Z,FINI                  ; yep, skip line adding
        POP     DE
        LD      HL,0
        LD      (ONELIN),HL             ; disable ERROR handler
        LD      HL,(VARTAB)
        EX      (SP),HL
        POP     BC
        PUSH    HL
        ADD     HL,BC
        PUSH    HL
        CALL    BLTU                    ; check for enough stackspace and move data
        POP     HL
        LD      (VARTAB),HL
        EX      DE,HL
        LD      (HL),H
        POP     BC
        POP     DE
        PUSH    HL
        INC     HL
        INC     HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        INC     HL
        LD      DE,KBUF
        DEC     BC
        DEC     BC
        DEC     BC
        DEC     BC
J422E:  LD      A,(DE)
        LD      (HL),A
        INC     HL
        INC     DE
        DEC     BC
        LD      A,C
        OR      B
        JR      NZ,J422E

FINI:
J4237:  CALL    H.FINI
        POP     DE
        CALL    C4257                   ; setup BASIC linelinks from this point
        LD      HL,(PTRFIL)
        LD      (TEMP2),HL              ; save interpreter input/output device
        CALL    RUNC                    ; initialize interpreter, basic pointer at start of program
        CALL    H.FINE
        LD      HL,(TEMP2)
        LD      (PTRFIL),HL             ; restore interpreter input/output device
        JP      MAIN                    ; main loop

;       Subroutine      setup BASIC linelinks
;       Inputs          ________________________
;       Outputs         ________________________

LINKER:
C4253:  LD      HL,(TXTTAB)
        EX      DE,HL

;       Subroutine      setup BASIC linelinks from this point
;       Inputs          ________________________
;       Outputs         ________________________

C4257:  LD      H,D
        LD      L,E
        LD      A,(HL)
        INC     HL
        OR      (HL)                    ; end of program ?
        RET     Z                       ; yep, quit
        INC     HL
        INC     HL                      ; skip over linenuber
J425F:  INC     HL
        LD      A,(HL)
J4261:  OR      A                       ; end of BASIC line ?
        JR      Z,J4272                 ; yep, fill linelink
        CP      20H                     ; character or non numeric token ?
        JR      NC,J425F                ; yep, next
        CP      0BH                     ; multi byte numeric token ?
        JR      C,J425F                 ; nope, next
        CALL    C466A                   ; get BASIC character (numeric token)
        _RST    CHRGTR                  ; get next BASIC character (get value)
        JR      J4261

J4272:  INC     HL
        EX      DE,HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        JR      C4257                   ; next line

;       Subroutine      evaluate linenumber (range) and search start linenumber
;       Inputs          ________________________
;       Outputs         ________________________

C4279:  LD      DE,0                    ; default start linenumber = 0
        PUSH    DE
        JR      Z,J4288                 ; end of statement, skip start
        POP     DE
        CALL    LINSPC                  ; collect linenumber (with DOT supported)
        PUSH    DE                      ; save start linenumber
        JR      Z,J4291                 ; end of statement,
        _RST    SYNCHR
        DEFB    0F2H                    ; check for -
J4288:  LD      DE,65530                ; default end linenumber = 65530
        CALL    NZ,LINSPC               ; not end of statement, collect linenumber (with DOT supported)
        JP      NZ,SNERR                ; not end of statement, syntax error
J4291:  EX      DE,HL
        POP     DE                      ; start linenumber

;       Subroutine      stack HL and search linenumber from start of program
;       Inputs          ________________________
;       Outputs         ________________________

C4293:  EX      (SP),HL
        PUSH    HL                      ; save end linenumber on stack

;       Subroutine      search linenumber from start of program
;       Inputs          DE = linenumber to search
;       Outputs         ________________________

FNDLIN:
C4295:  LD      HL,(TXTTAB)             ; start of BASIC program

;       Subroutine      search linenumber
;       Inputs          HL = current pointer, DE = linenumber to search
;       Outputs         ________________________

C4298:  LD      B,H
        LD      C,L                     ; save start of line
        LD      A,(HL)
        INC     HL
        OR      (HL)                    ; endpointer ?
        DEC     HL
        RET     Z                       ; yep, quit
        INC     HL
        INC     HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A                     ; linenumber
        _RST    DCOMPR                  ; compare with the one we search
        LD      H,B
        LD      L,C
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A                     ; start of next line
        CCF
        RET     Z                       ; exact match, quit (Cx set)
        CCF
        RET     NC			; bigger found, quit (Cx reset)
        JR      C4298			; continue search

;       Subroutine      encode BASIC line
;       Inputs          ________________________
;       Outputs         ________________________

C42B2:  XOR     A
        LD      (DONUM),A               ; normal behavior numeric constant
        LD      (DORES),A               ; not in DATA statement
        CALL    H.CRUN
        LD      BC,315
        LD      DE,KBUF
J42C2:  LD      A,(HL)
        OR      A                       ; end of line ?
        JR      NZ,J42D9                ; nope,
J42C6:  LD      HL,320
        LD      A,L
        SUB     C
        LD      C,A
        LD      A,H
        SBC     A,B
        LD      B,A
        LD      HL,KBFMIN               ; statement seperator, before KBUF
        XOR     A
        LD      (DE),A                  ; end of BASIC line
        INC     DE
        LD      (DE),A
        INC     DE
        LD      (DE),A                  ; pointer, end of BASIC program
        RET

J42D9:  CP      '"'                     ; start of string ?
        JP      Z,J4316                 ; yep, put " in KBUF and all chars that follow until " or end of line reached
        CP      " "                     ; space ?
        JR      Z,J42E9                 ; yep, put in KBUF and continue
        LD      A,(DORES)
        OR      A                       ; in DATA statement ?
        LD      A,(HL)
        JR      Z,J4326                 ; nope, normal behavior
J42E9:  INC     HL
        PUSH    AF
        CP      01H                     ; MSX graphic char header ?
        JR      NZ,J42F3                ; nope, put in KBUF
        LD      A,(HL)
        AND     A                       ; end of line ?
        LD      A,01H
J42F3:  CALL    NZ,C44E0                ; nope, put in KBUF
        POP     AF
        SUB     ":"                     ; statement seperator ?
        JR      Z,J4301                 ; yep, not in DATA statement and normal numeric behavior
        CP      84H-":"                 ; DATA token ?
        JR      NZ,J4307                ; nope, skip
        LD      A,1                     ; yep, set DATA statement flag, numeric to linenumber
J4301:  LD      (DORES),A               ; in DATA statement
        LD      (DONUM),A               ; numeric behavior
J4307:  SUB     8FH-":"                 ; REM token ?
        JR      NZ,J42C2                ; nope,
        PUSH    AF                      ; no special end char
J430C:  LD      A,(HL)
        OR      A                       ; end of line ?
        EX      (SP),HL
        LD      A,H
        POP     HL
        JR      Z,J42C6                 ; yep, stop encoding
        CP      (HL)
        JR      Z,J42E9                 ; yep, put in KBUF and continue
J4316:  PUSH    AF
        LD      A,(HL)
J4318:  INC     HL
        CP      01H                     ; MSX graphic char header ?
        JR      NZ,J4321                ; nope, put in KBUF
        LD      A,(HL)
        AND     A                       ; end of line ?
        LD      A,01H
J4321:  CALL    NZ,C44E0                ; nope, put in KBUF
        JR      J430C

J4326:  INC     HL
        OR      A                       ; 80H-0FFH ?
        JP      M,J42C2                 ; yep, skip
        CP      01H                     ; MSX graphic char header ?
        JR      NZ,J4336                ; nope,
        LD      A,(HL)
        AND     A                       ; end of line ?
        JR      Z,J42C6                 ; yep, stop encoding
        INC     HL
        JR      J42C2                   ; skip MSX graphic char

J4336:  DEC     HL
        CP      "?"                     ; short for PRINT ?
        LD      A,91H                   ; PRINT token
        PUSH    DE
        PUSH    BC
        JP      Z,J43A3                 ; yep,
        LD      A,(HL)
        CP      "_"                     ; short for CALL ?
        JP      Z,J43A3                 ; yep,
        LD      DE,I3D26                ; ??, useless instruction
        CALL    MAKUPL                  ; get char uppercase
        CALL    ISLET2                  ; is upcase letter character ?
        JP      C,J441D                 ; nope, not a keyword
        PUSH    HL
        CALL    H.CRUS
        LD      HL,I3A3E
        SUB     "A"
        ADD     A,A
        LD      C,A
        LD      B,0
        ADD     HL,BC
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        POP     HL                      ; get pointer the keywords which start with the given letter
        INC     HL
J4365:  PUSH    HL
J4366:  CALL    MAKUPL                  ; get char uppercase
        LD      C,A
        LD      A,(DE)
        AND     7FH                     ; end of the keyword list ?
        JP      Z,J44EB                 ; yep, no keyword
        INC     HL
        CP      C                       ; match ?
        JR      NZ,J4398                ; no, next keyword
        LD      A,(DE)
        INC     DE
        OR      A                       ; end of keyword ?
        JP      P,J4366                 ; nope, next char
        POP     AF                      ; remove pointer from stack
        LD      A,(DE)                  ; token
        CALL    H.ISRE
        OR      A                       ; function token ?
        JP      M,J43A2                 ; nope,
        POP     BC
        POP     DE                      ; KBUF vars
        OR      80H                     ; set b7
        PUSH    AF
        LD      A,0FFH                  ; function token header
        CALL    C44E0                   ; put in KBUF
        XOR     A
        LD      (DONUM),A               ; back to normal numeric behavior
        POP     AF                      ; function token
        CALL    C44E0                   ; put in KBUF
        JP      J42C2                   ; next

J4398:  POP     HL
J4399:  LD      A,(DE)
        INC     DE
        OR      A                       ; end of keyword ?
        JP      P,J4399                 ; nope, skip next
        INC     DE
        JR      J4365                   ; try next keyword

J43A2:  DEC     HL
J43A3:  PUSH    AF
        CALL    H.NTFN
        LD      DE,I43B5                ; table tokens with linenumber as operand
        LD      C,A
J43AB:  LD      A,(DE)
        OR      A                       ; end of table ?
        JR      Z,J43C4                 ; yep, not a linenumber token
        INC     DE
        CP      C                       ; match ?
        JR      NZ,J43AB                ; nope, next
        JR      J43C6                   ; linenumber token

;       Table   tokens with linenumber as operand

I43B5:  DEFB    08CH			; RESTORE
        DEFB    0A9H			; AUTO
        DEFB    0AAH			; RENUM
        DEFB    0A8H			; DELETE
        DEFB    0A7H			; RESUME
        DEFB    0E1H			; ERL
        DEFB    0A1H			; ELSE
        DEFB    08AH			; RUN
        DEFB    093H			; LIST
        DEFB    09EH			; LLIST
        DEFB    089H			; GOTO
        DEFB    08EH			; RETURN
        DEFB    0DAH			; THEN
        DEFB    08DH			; GOSUB
        DEFB    0

J43C4:  XOR     A                       ; normal numeric behavior
        DEFB    0C2H                    ; JP NZ,xxxx, trick to skip next instruction
J43C6:  LD      A,1                     ; numeric is linenumber
J43C8:  LD      (DONUM),A
        POP     AF                      ; char/token
J43CC:  POP     BC
        POP     DE                      ; KBUF vars
        CP      0A1H                    ; ELSE token ?
        PUSH    AF
        CALL    Z,C44DE                 ; yep, put statement seperator in KBUF
        POP     AF
        CP      0CAH                    ; CALL token ?
        JR      Z,J43DD                 ; yep, put in KBUF
        CP      "_"                     ; short for CALL ?
        JR      NZ,J4406                ; nope, other
J43DD:  CALL    NC,C44E0                ; yep, put in KBUF
J43E0:  INC     HL
        CALL    MAKUPL                  ; get char uppercase
        AND     A                       ; end of line ?
J43E5:  JP      Z,J42C6                 ; yep, stop encoding
        JP      M,J43E0                 ; 80H-0FFH, skip
        CP      01H                     ; MSX graphic char header ?
        JR      NZ,J43F6                ; nope,
        INC     HL
        LD      A,(HL)
        AND     A                       ; end of line ?
        JR      Z,J43E5                 ; yep, stop encoding
        JR      J43E0                   ; next

J43F6:  CP      " "                     ; space char ?
        JR      Z,J43DD                 ; yep, put in KBUF and continue
        CP      ":"                     ; statement seperator ?
        JR      Z,J443A                 ; yep, put in KBUF and continue
        CP      "("                     ; start of a parenthesized operand ?
        JR      Z,J443A                 ; yep, put in KBUF and continue
        CP      "0"                     ; 30H-7FH ?
        JR      J43DD                   ; yep, put in KBUF and continue else skip and continue

J4406:  CP      0E6H                    ; token for ' ?
        JP      NZ,J44B4                ; nope, other
        PUSH    AF
        CALL    C44DE                   ; put statement seperator in KBUF
        LD      A,8FH                   ; REM token
        CALL    C44E0                   ; put in KBUF
        POP     AF
        PUSH    HL
        LD      HL,0
        EX      (SP),HL                 ; no special end char
        JP      J4318                   ; put in REM token KBUF and all chars that follow until end of line is reached

J441D:  LD      A,(HL)
        CP      "."
        JR      Z,J442C
        CP      "9"+1
        JP      NC,J44A2                ; not numeric, check for 1 character tokens
        CP      "0"
        JP      C,J44A2                 ; not numeric, check for 1 character tokens
J442C:  LD      A,(DONUM)
        OR      A
        LD      A,(HL)
        POP     BC
        POP     DE
        JP      M,J42E9                 ; no numeric conversion, put in KBUF and continue
        JR      Z,J4457                 ; normal behavior
        CP      "."
J443A:  JP      Z,J42E9                 ; put in KBUF and continue
        LD      A,0EH                   ; linenumber token
        CALL    C44E0                   ; put in KBUF
        PUSH    DE
        CALL    LINGET                  ; collect linenumber
        CALL    C4514                   ; skip space chars
J4449:  EX      (SP),HL
        EX      DE,HL
J444B:  LD      A,L
        CALL    C44E0                   ; put in KBUF
        LD      A,H
J4450:  POP     HL
        CALL    C44E0                   ; put in KBUF
        JP      J42C2                   ; next

J4457:  PUSH    DE
        PUSH    BC
        LD      A,(HL)
        CALL    FIN                     ; convert text to number
        CALL    C4514                   ; skip space chars
        POP     BC
        POP     DE
        PUSH    HL
        LD      A,(VALTYP)
        CP      2                       ; integer number ?
        JR      NZ,J447F                ; nope, put constant in KBUF
        LD      HL,(DAC+2)
        LD      A,H
        OR      A                       ; number 0-255 ?
        LD      A,2
        JR      NZ,J447F                ; nope, put integer in KBUF
        LD      A,L
        LD      H,L                     ; number
        LD      L,0FH                   ; token for numeric byte constant
        CP      10                      ; number 0-9 ?
        JR      NC,J444B                ; nope, put word in KBUF and continue
        ADD     A,11H                   ; tokens for numeric constant 0-9
        JR      J4450                   ; put byte in KBUF and continue

J447F:  PUSH    AF
        RRCA
        ADD     A,1BH                   ; 1CH for integer, 1DH for single real, 1FH for double real
        CALL    C44E0                   ; put in KBUF
        LD      HL,DAC
        LD      A,(VALTYP)
        CP      2
        JR      NZ,J4493
        LD      HL,DAC+2
J4493:  POP     AF
J4494:  PUSH    AF
        LD      A,(HL)
        CALL    C44E0                   ; put in KBUF
        POP     AF
        INC     HL
        DEC     A
        JR      NZ,J4494
        POP     HL
        JP      J42C2                   ; next

J44A2:  LD      DE,I3D26-1              ; special 1 character tokens
J44A5:  INC     DE
        LD      A,(DE)
        AND     7FH                     ; end of table ?
        JP      Z,J44FA                 ; yep, others
        INC     DE
        CP      (HL)                    ; match ?
        LD      A,(DE)
        JR      NZ,J44A5                ; nope, next
        JP      J4509                   ; yep,

J44B4:  CP      "&"                     ; header for other radix ?
        JP      NZ,J42E9                ; nope, put in KBUF and continue
        PUSH    HL
        _RST    CHRGTR                  ; get next BASIC character (a bit strange but works)
        POP     HL
        CALL    MAKUPS                  ; upcase char
        CP      "H"                     ; hexadecimal ?
        JR      Z,J44D0                 ; yep, put hexadecimal constant in KBUF
        CP      "O"                     ; octal ?
        JR      Z,J44CC                 ; yep, put octal constant in KBUF
        LD      A,"&"
        JP      J42E9                   ; put "&" in KBUF and continue

J44CC:  LD      A,0BH                   ; token for octal constant
        JR      J44D2

J44D0:  LD      A,0CH                   ; token for hexadecimal constant
J44D2:  CALL    C44E0                   ; put in KBUF
        PUSH    DE
        PUSH    BC
        CALL    C4EB8                   ; convert text with radix indication to number
        POP     BC
        JP      J4449                   ; put word on stack in KBUF

;       Subroutine      put statement seperator in KBUF
;       Inputs          ________________________
;       Outputs         ________________________

C44DE:  LD      A,":"

;       Subroutine      put in KBUF
;       Inputs          A = data
;       Outputs         ________________________

C44E0:  LD      (DE),A
        INC     DE
        DEC     BC
        LD      A,C
        OR      B
        RET     NZ
        LD      E,25
        JP      ERROR                   ; line buffer overflow error

J44EB:  CALL    H.NOTR
        POP     HL
        DEC     HL
        DEC     A
        LD      (DONUM),A               ; numeric not converted
        CALL    MAKUPL                  ; get char uppercase
        JP      J43CC

J44FA:  LD      A,(HL)
        CP      20H                     ; 20H-7FH ?
        JR      NC,J4509                ; yep,
        CP      09H                     ; TAB ?
        JR      Z,J4509                 ; yep,
        CP      0AH                     ; LF ?
        JR      Z,J4509                 ; yep,
        LD      A," "                   ; others are replaced by a space
J4509:  PUSH    AF
        LD      A,(DONUM)
        INC     A                       ; numeric not converted ?
        JR      Z,J4511                 ; yep, back to normal numeric behavior
        DEC     A                       ; numeric is not converted
J4511:  JP      J43C8


;       Subroutine      skip space chars
;       Inputs          ________________________
;       Outputs         ________________________

C4514:  DEC     HL
        LD      A,(HL)
        CP      " "
        JR      Z,C4514
        CP      09H
        JR      Z,C4514
        CP      0AH
        JR      Z,C4514
        INC     HL
        RET

;       Subroutine      FOR statement
;       Inputs          ________________________
;       Outputs         ________________________

FOR:
C4524:  LD      A,64H
        LD      (SUBFLG),A              ; variable search flag = loopvariable
        CALL    LET                     ; LET statement (initialize loopvariable)
        POP     BC
        PUSH    HL
        CALL    DATA                    ; skip to end of statement
        LD      (ENDFOR),HL
        LD      HL,2
        ADD     HL,SP                   ; skip 1st word
J4538:  CALL    C3FE6                   ; search FOR block on stack
        JR      NZ,J4554                ; not found, continue
        ADD     HL,BC                   ; to next block
        PUSH    DE
        DEC     HL
        LD      D,(HL)
        DEC     HL
        LD      E,(HL)                  ; ENDFOR address
        INC     HL
        INC     HL
        PUSH    HL
        LD      HL,(ENDFOR)
        _RST    DCOMPR                  ; same as this ENDFOR ?
        POP     HL
        POP     DE
        JR      NZ,J4538                ; nope, search next FOR block
        POP     DE                      ; restore BASIC pointer
        LD      SP,HL                   ; remove FOR blocks from stack
        LD      (SAVSTK),HL
        DEFB    00EH                    ; LD C,xx, trick to skip next instruction
J4554:  POP     DE
        EX      DE,HL
        LD      C,12
        CALL    GETSTK                  ; check if enough stackspace for 12 words
        PUSH    HL
        LD      HL,(ENDFOR)
        EX      (SP),HL
        PUSH    HL
        LD      HL,(CURLIN)
        EX      (SP),HL
        _RST    SYNCHR
        DEFB    0D9H                    ; check for TO
        _RST    GETYPR
        JP      Z,TMERR                 ; string, type mismatch error
        PUSH    AF
        CALL    FRMEVL                  ; evaluate expression
        POP     AF
        PUSH    HL
        JR      NC,J458B                ; loopvariable double real,
        JP      P,J45C2                 ; loopvariable single real,
        CALL    FRCINT                  ; convert DAC to integer
        EX      (SP),HL
        LD      DE,1                    ; default STEP value is 1
        LD      A,(HL)
        CP      0DCH                    ; STEP token ?
        CALL    Z,C520E                 ; yep, skip STEP token and evaluate integer operand
        PUSH    DE
        PUSH    HL
        EX      DE,HL
        CALL    ISIGN                   ; get sign of integer
        JR      J45E8                   ; push step value on stack and continue

J458B:  CALL    FRCDBL                  ; convert DAC to double real
        POP     DE
        LD      HL,-8
        ADD     HL,SP
        LD      SP,HL
        PUSH    DE
        CALL    VMOVMF                  ; HL = DAC
        POP     HL
        LD      A,(HL)
        CP      0DCH                    ; STEP token ?
        LD      DE,FONE                 ; 1.0 double real
        LD      A,1                     ; sign is positive
        JR      NZ,J45B2                ; nope, use 1.0 as STEP value
        _RST    CHRGTR                  ; get next BASIC character
        CALL    FRMEVL                  ; evaluate expression
        PUSH    HL
        CALL    FRCDBL                  ; convert DAC to double real
        CALL    SIGN                    ; get sign DAC
        LD      DE,DAC
        POP     HL
J45B2:  LD      B,H
        LD      C,L
        LD      HL,-8
        ADD     HL,SP
        LD      SP,HL
        PUSH    AF
        PUSH    BC
        CALL    VMOVE                   ; HL = DE (valtyp)
        POP     HL
        POP     AF
        JR      J45EF                   ; continue

J45C2:  CALL    FRCSNG                  ; convert DAC to single real
        CALL    MOVRF                   ; DEBC = DAC (single)
        POP     HL
        PUSH    BC
        PUSH    DE
        LD      BC,1041H
        LD      DE,0000H                ; 1.0 single real
        CALL    H.SNGF
        LD      A,(HL)
        CP      0DCH                    ; STEP token ?
        LD      A,1                     ; sign is positive
        JR      NZ,J45E9                ; nope, push step value on stack and continue
        CALL    FRMCHK                  ; skip character and evaluate expression
        PUSH    HL
        CALL    FRCSNG                  ; convert DAC to single real
        CALL    MOVRF                   ; DEBC = DAC (single real)
        CALL    SIGN                    ; get sign DAC
J45E8:  POP     HL
J45E9:  PUSH    DE
        PUSH    BC
        PUSH    BC
        PUSH    BC
        PUSH    BC
        PUSH    BC
J45EF:  OR      A
        JR      NZ,J45F4
        LD      A,2
J45F4:  LD      C,A
        _RST    GETYPR
        LD      B,A                     ;
        PUSH    BC
        PUSH    HL
        LD      HL,(TEMP)
        EX      (SP),HL

NXTCON:
J45FD:  LD      B,82H
        PUSH    BC
        INC     SP

;       Subroutine      execute new statement
;       Inputs          ________________________
;       Outputs         ________________________

NEWSTT:
C4601:  CALL    H.NEWS
        LD      (SAVSTK),SP
        CALL    ISCNTC                  ; check CTRL-STOP
        LD      A,(ONGSBF)
        OR      A                       ; trap occured ?
        CALL    NZ,TRPEXE               ; yep, handle trap

NEWSTN:
J4612:  EI
        LD      (SAVTXT),HL
        LD      A,(HL)
        CP      ":"
        JR      Z,GONE                  ; statement seperator, skip new line stuff
        OR      A
        JP      NZ,SNERR                ; spurious text after statement, syntax error
        INC     HL
J4620:  LD      A,(HL)
        INC     HL
        OR      (HL)                    ; end of basictext ?
        JP      Z,J4039                 ; yep, at end of BASIC program
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; linenumber
        EX      DE,HL
        LD      (CURLIN),HL             ; update current linenumber
        LD      A,(TRCFLG)
        OR      A                       ; trace mode ?
        JR      Z,J463F                 ; skip trace
        PUSH    DE
        LD      A,"["
        _RST    OUTDO                   ; "[" to interpreter output
        CALL    LINPRT                  ; number to interpreter output
        LD      A,"]"
        _RST    OUTDO                   ; "]" to interpreter output
        POP     DE
J463F:  EX      DE,HL
GONE:
J4640:  _RST    CHRGTR                  ; get next BASIC character
        LD      DE,NEWSTT
        PUSH    DE
        RET     Z                       ; end of BASIC line, execute new statement
J4646:  CALL    H.GONE
        CP      "_"                     ; CALL ?
        JP      Z,CALL$                 ; yep, execute CALL statement
        SUB     81H                     ; statement token ? (081H-0D8H)
        JP      C,LET                   ; nope, LET statement
        CP      0D9H-081H               ; valid statement token ?
        JP      NC,J51AD                ; nope, check if function token allowed as statement
        RLCA
        LD      C,A
        LD      B,0
        EX      DE,HL
        LD      HL,I392E
        ADD     HL,BC
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        PUSH    BC                      ; execute statement after this
        EX      DE,HL

;       Subroutine      CHRGTR (get next BASIC char)
;       Inputs          ________________________
;       Outputs         Zx set if end of statement, Cx set if numeric

CHRGTR:
C4666:  CALL    H.CHRG
        INC     HL

;       Subroutine      get BASIC char
;       Inputs          ________________________
;       Outputs         ________________________

CHRGT2:
C466A:  LD      A,(HL)
        CP      3AH                     ; 3AH-FFH, quit with Cx reset. Zx set if statement seperator
        RET     NC
        CP      " "                     ; SPACE ?
        JR      Z,CHRGTR                ; yep, skip
        JR      NC,J46E0                ; 21H-39H,
        OR      A                       ; end of BASIC line ?
        RET     Z                       ; yep, quit with Cx reset, Zx set
        CP      0BH                     ; 01H-0AH ?
        JR      C,J46DB
        CP      1EH                     ; 1EH token ?
        JR      NZ,J4683                ; nope (0BH-1FH),
        LD      A,(CONSAV)
        OR      A                       ; yep, orginal numeric token
        RET

J4683:  CP      10H                     ; 10H token ?
        JR      Z,J46BB                 ; yep, return to orginal BASIC pointer
        PUSH    AF                      ; save numeric token
        INC     HL
        LD      (CONSAV),A              ; save token
        SUB     1CH                     ; 1CH, 1DH or 1FH token ?
        JR      NC,J46C0                ; yep, numeric constant
        SUB     11H-1CH                 ; 11H-1BH token ?
        JR      NC,J469A                ; yep, numeric constant 0-10
        CP      0FEH                    ; 0FH token ?
        JR      NZ,J46AE                ; nope, token 0BH,0CH,0DH or 0EH, numeric word constant
        LD      A,(HL)                  ; yep, get byte constant
        INC     HL
J469A:  LD      (CONTXT),HL             ; where BASIC pointer continues
        LD      H,0                     ; clear highbyte
J469F:  LD      L,A
        LD      (CONLO),HL              ; save constant
        LD      A,2
        LD      (CONTYP),A              ; integer type
        LD      HL,I46E6                ; special internal token sequence
        POP     AF                      ; restore numeric token
        OR      A                       ; Cx reset, Zx reset
        RET

J46AE:  LD      A,(HL)                  ; get lowbyte constant
        INC     HL
        INC     HL
        LD      (CONTXT),HL             ; where BASIC pointer continues
        DEC     HL
        LD      H,(HL)                  ; get highbyte constant
        JR      J469F                   ; save constant

J46B8:  CALL    C46E8                   ; get numeric constant (in DAC)
J46BB:  LD      HL,(CONTXT)             ; restore BASIC pointer
        JR      C466A                   ; get BASIC character

J46C0:  INC     A                       ; 1,2 or 4
        RLCA                            ; 2,4 or 8
        LD      (CONTYP),A              ; type
        PUSH    DE
        PUSH    BC
        LD      DE,CONLO
        EX      DE,HL
        LD      B,A
        CALL    MOVE1
        EX      DE,HL
        POP     BC
        POP     DE                      ; copy to CONLO
        LD      (CONTXT),HL             ; where BASIC pointer continues
        POP     AF
        LD      HL,I46E6                ; special internal token sequence
        OR      A                       ; Cx reset, Zx reset
        RET

J46DB:  CP      09H                     ; 09H or 0AH ?
        JP      NC,CHRGTR               ; yep, skip
J46E0:  CP      "0"
        CCF                             ; Cx set if digit
        INC     A
        DEC     A                       ; Zx reset
        RET

I46E6:  DEFB    01EH                    ; internal token for returning the orginal numeric token
        DEFB    010H                    ; resume BASIC pointer

;       Subroutine      get numeric constant (in DAC)
;       Inputs          ________________________
;       Outputs         ________________________

C46E8:  LD      A,(CONSAV)
        CP      0FH                     ; numeric tokens 0FH,11H-1BH,1AH,1BH,1CH,1DH,1FH ?
        JR      NC,J4702                ; yep,
        CP      0DH                     ; numeric tokens 0BH,0CH ?
        JR      C,J4702                 ; yep,
        LD      HL,(CONLO)              ; linenumber/linepointer
        JR      NZ,J46FF                ; numeric token 0EH, linenumber
        INC     HL
        INC     HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        EX      DE,HL                   ; linenumber
FLTLIN:
J46FF:  JP      CONSUI                  ; convert unsigned integer to single real

J4702:  LD      A,(CONTYP)
        LD      (VALTYP),A
        CP      2
        JR      NZ,J4712
        LD      HL,(CONLO)
        LD      (DAC+2),HL
J4712:  LD      HL,CONLO
        JP      VMOVFM                  ; DAC = CONLO

;       Subroutine      DEFSTR statement
;       Inputs          ________________________
;       Outputs         ________________________

DEFSTR:
C4718:  LD      E,3                     ; string
        DEFB    01H			; LD BC,xxxx, trick to skip next instruction

;       Subroutine      DEFINT statement
;       Inputs          ________________________
;       Outputs         ________________________

DEFINT:
C471B:  LD      E,2                     ; integer
        DEFB    01H			; LD BC,xxxx, trick to skip next instruction

;       Subroutine      DEFSNG statement
;       Inputs          ________________________
;       Outputs         ________________________

DEFREA:
C471E:  LD      E,4                     ; single real
        DEFB    01H			; LD BC,xxxx, trick to skip next instruction

;       Subroutine      DEFDBL statement
;       Inputs          ________________________
;       Outputs         ________________________

DEFDBL:
C4721:  LD      E,8                     ; double real
J4723:  CALL    ISLET                   ; is current BASIC character a upcase letter ?
        LD      BC,SNERR
        PUSH    BC
        RET     C                       ; nope, syntax error
        SUB     "A"
        LD      C,A
        LD      B,A
        _RST    CHRGTR                  ; get next BASIC character (upcase letter)
        CP      0F2H                    ; - token ?
        JR      NZ,J473D                ; nope,
        _RST    CHRGTR                  ; get next BASIC character (- token)
        CALL    ISLET                   ; is current BASIC character a upcase letter ?
        RET     C                       ; nope, syntax error
        SUB     "A"
        LD      B,A
        _RST    CHRGTR                  ; get next BASIC character (upcase letter)
J473D:  LD      A,B
        SUB     C                       ; postive range ?
        RET     C                       ; nope, syntax error
        INC     A
        EX      (SP),HL                 ; save BASIC pointer (and remove syntax error address)
        LD      HL,DEFTBL
        LD      B,0
        ADD     HL,BC                   ; to start letter
J4748:  LD      (HL),E                  ; default variabele type
        INC     HL
        DEC     A
        JR      NZ,J4748                ; next
        POP     HL                      ; restore BASIC pointer
        LD      A,(HL)
        CP      ","                     ; an other range follows ?
        RET     NZ                      ; nope, quit
        _RST    CHRGTR                  ; get next BASIC character (, char)
        JR      J4723                   ; next range


;       Subroutine      skip basic char, evaluate word operand and check for 0-32767 range
;       Inputs          ________________________
;       Outputs         ________________________

INTIDX:
C4755:  _RST    CHRGTR                  ; get next BASIC character

;       Subroutine      evaluate word operand and check for 0-32767 range
;       Inputs          ________________________
;       Outputs         ________________________

INTID2:
C4756:  CALL    GETIN2                  ; evaluate integer operand
        RET     P

;       Subroutine      illegal function call
;       Inputs          ________________________
;       Outputs         ________________________

FCERR:
C475A:  LD      E,5
        JP      ERROR                   ; illegal function call

;       Subroutine      collect linenumber (with DOT supported)
;       Inputs          ________________________
;       Outputs         ________________________

LINSPC:
C475F:  LD      A,(HL)
        CP      "."
        LD      DE,(DOT)
        JP      Z,CHRGTR                ; get next BASIC character and quit

;       Subroutine      collect linenumber
;       Inputs          ________________________
;       Outputs         ________________________

LINGET:
C4769:  DEC     HL

;       Subroutine      collect linenumber
;       Inputs          ________________________
;       Outputs         ________________________

LINGT2:
C476A:  _RST    CHRGTR                  ; get next BASIC character
        CP      0EH                     ; linenumber token ?
        JR      Z,C4771                 ; yep,
        CP      0DH                     ; linepointer token ?

;       Subroutine      get linenumber
;       Inputs          ________________________
;       Outputs         ________________________

LINGT3:
C4771:  LD      DE,(CONLO)
        JP      Z,CHRGTR                ; yep, get next BASIC character
        XOR     A
        LD      (CONSAV),A
        LD      DE,0
        DEC     HL
J4780:  _RST    CHRGTR                  ; get next BASIC character
        RET     NC
        PUSH    HL
        PUSH    AF
        LD      HL,6552                 ; 65530/10-1
        _RST    DCOMPR
        JR      C,J479B
        LD      H,D
        LD      L,E
        ADD     HL,DE			; *2
        ADD     HL,HL			; *4
        ADD     HL,DE			; *5
        ADD     HL,HL			; *10
        POP     AF
        SUB     '0'
        LD      E,A
        LD      D,0
        ADD     HL,DE
        EX      DE,HL
        POP     HL
        JR      J4780

J479B:  POP     AF
        POP     HL
        RET

;       Subroutine      RUN statement
;       Inputs          ________________________
;       Outputs         ________________________

RUN:
C479E:  JP      Z,RUNC                  ; end of statement, initialize interpreter, basic pointer at start of program and quit (which start the program!)
        CP      0EH                     ; linenumber token ?
        JR      Z,J47AA                 ; yep, RUN line
        CP      0DH                     ; linepointer token ?
        JP      NZ,LRUN                 ; nope, RUN file
J47AA:  CALL    CLEARC                  ; initialize interpreter
        LD      BC,NEWSTT
        JR      J47E7                   ; execute GOTO statement, after that execute new statement

;       Subroutine      GOSUB statement
;       Inputs          ________________________
;       Outputs         ________________________

GOSUB:
C47B2:  LD      C,3
        CALL    GETSTK                  ; check if enough stackspace for 3 words
        CALL    LINGET                  ; collect linenumber
        POP     BC
        PUSH    HL                      ; save current BASIC pointer
        PUSH    HL
        LD      HL,(CURLIN)
        EX      (SP),HL                 ; save current linenumber
        LD      BC,0
        PUSH    BC                      ; 0, not a trapentry
        LD      BC,NEWSTT
        LD      A,8DH
        PUSH    AF
        INC     SP                      ; GOSUB parameter block
        PUSH    BC                      ; after this, execute new statement
        JR      C47EB                   ; goto linenumber

;       Subroutine      GOSUB traphandler
;       Inputs          ________________________
;       Outputs         ________________________

GOSUBT:
J47CF:  PUSH    HL                      ; save current BASIC pointer
        PUSH    HL
        LD      HL,(CURLIN)
        EX      (SP),HL                 ; save current linenumber
        PUSH    BC                      ; save trapentry
        LD      A,8DH
        PUSH    AF
        INC     SP                      ; GOSUB parameter block
        EX      DE,HL
        DEC     HL
        LD      (SAVTXT),HL             ; start of traphandler as start for CONT
        INC     HL
        LD      (SAVSTK),SP             ; current stackpointer
        JP      J4620                   ; start executing traphandler

J47E7:  PUSH    BC

;       Subroutine      GOTO statement
;       Inputs          ________________________
;       Outputs         ________________________

GOTO:
C47E8:  CALL    LINGET                  ; collect linenumber

;       Subroutine      goto linenumber
;       Inputs          ________________________
;       Outputs         ________________________

C47EB:  LD      A,(CONSAV)
        CP      0DH                     ; linepointer token ?
        EX      DE,HL
        RET     Z                       ; yep, quit
        CP      0EH                     ; linenumber token ?
        JP      NZ,SNERR                ; nope, syntax error
        EX      DE,HL
        PUSH    HL
        LD      HL,(CONTXT)
        EX      (SP),HL
        CALL    REM                     ; skip to end of BASIC line
        INC     HL
        PUSH    HL
        LD      HL,(CURLIN)
        _RST    DCOMPR			; forward in program ?
        POP     HL
        CALL    C,C4298			; yep, search linenumber from current (faster)
        CALL    NC,FNDLIN               ; not forward or exact match not found, search linenumber from start of program
        JR      NC,USERR                ; no exact match found, undefined line number error
        DEC     BC
        LD      A,0DH
        LD      (PTRFLG),A
        POP     HL
        CALL    C5583
        LD      H,B
        LD      L,C
        RET

USERR:
J481C:  LD      E,8
        JP      ERROR                   ; undefined line number error

;       Subroutine      RETURN statement
;       Inputs          ________________________
;       Outputs         ________________________

RETURN:
C4821:  CALL    H.RETU                  ; hook start return statement
        LD      (TEMP),HL
        LD      D,0FFH                  ; DE=0FFxxH (impossible loop variable address)
        CALL    FNDFOR                  ; search FOR block on stack (skip 2 words)
        CP      8DH                     ; search stopped by a GOSUB block ?
        JR      Z,J4831                 ; yep,
        DEC     HL
J4831:  LD      SP,HL
        LD      (SAVSTK),HL
        LD      E,3
        JP      NZ,ERROR                ; nope, return without gosub error
        POP     HL
        LD      A,H
        OR      L                       ; return from trap handler ?
        JR      Z,J4845                 ; nope,
        LD      A,(HL)
        AND     01H                     ; trap enabled ?
        CALL    NZ,TRPRSM               ; yep, unpause trap
J4845:  POP     BC
        LD      HL,NEWSTT
        EX      (SP),HL                 ; after this, execute new statement
        EX      DE,HL
        LD      HL,(TEMP)
        DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        JP      NZ,GOTO                 ; not end of statement, goto statement
        LD      H,B
        LD      L,C
        LD      (CURLIN),HL
        EX      DE,HL
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction


;       Subroutine      skip to end of statement
;       Inputs          ________________________
;       Outputs         ________________________

J485A:  POP     HL

;       Subroutine      skip to end of statement (also DATA statement handler)
;       Inputs          ________________________
;       Outputs         ________________________

DATA:
C485B:  DEFB    001H                    ; LD BC,xx3AH, skip to 485E
        DEFB    ":"                     ; end search character outside string = :

;       Subroutine      skip to end of BASIC line (also REM/ELSE statement handler)
;       Inputs          ________________________
;       Outputs         ________________________

ELSES:
REM:
C485D:  LD      C,0                     ; end search character outside string = none
        LD      B,0                     ; end search character inside string = none

;       Subroutine      skip to end of BASIC line with extra end characters
;       Inputs          C = end search character outside string, B = end search character inside string
;       Outputs         ________________________

J4861:  LD      A,C
        LD      C,B
        LD      B,A
J4864:  DEC     HL
J4865:  _RST    CHRGTR                  ; get next BASIC character
        OR      A                       ; end of BASIC line ?
        RET     Z                       ; yep, quit
        CP      B
        RET     Z
        INC     HL
        CP      '"'
        JR      Z,J4861
        INC     A                       ; function token header ?
        JR      Z,J4865                 ; skip function token as well
        SUB     8BH+1                   ; IF token ?
        JR      NZ,J4864                ; nope, next
        CP      B                       ; end search character defined ?
        ADC     A,D
        LD      D,A                     ; yep, increase IF nesting level
        JR      J4864                   ; next

LETCON:
J487B:  POP     AF
        ADD     A,3
        JR      J4892

;       Subroutine      LET statement
;       Inputs          ________________________
;       Outputs         ________________________

LET:
C4880:  CALL    PTRGET                  ; locate variable
        _RST    SYNCHR
        DEFB    0EFH                    ; check for =
        LD      (TEMP),DE               ; save variable address
        PUSH    DE
        LD      A,(VALTYP)
        PUSH    AF                      ; save variable type
        CALL    FRMEVL                  ; evaluate expression
        POP     AF
J4892:  EX      (SP),HL
J4893:  LD      B,A
        LD      A,(VALTYP)
        CP      B
        LD      A,B                     ; result expression of the same type as variable ?
        JR      Z,J48A1                 ; yep, no need to convert
        CALL    C517A                   ; convert to DAC to new type
J489E:  LD      A,(VALTYP)
J48A1:  LD      DE,DAC
        CP      2                       ; integer ?
        JR      NZ,J48AB
        LD      DE,DAC+2                ; yep, use DAC+2
J48AB:  PUSH    HL
        CP      3                       ; string ?
        JR      NZ,J48DE                ; nope, just copy value in variable
        LD      HL,(DAC+2)
        PUSH    HL
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; pointer to string
        LD      HL,KBUF-1
        _RST    DCOMPR
        JR      C,J48D2                 ; string in KBUF, copy in string storage area
        LD      HL,(STREND)
        _RST    DCOMPR
        POP     DE                      ; stringdescriptor
        JR      NC,J48DA                ; string in programtext, no need to copy
        LD      HL,DSCTMP-1
        _RST    DCOMPR
        JR      C,J48D1                 ; temporary stringdescriptor, copy string in string storage area
        LD      HL,TEMPST-1
        _RST    DCOMPR
        JR      C,J48DA                 ; no temporaty result stringdesciptor, no need to copy
J48D1:  DEFB    03EH                    ; LD A,xx, trick to skip next instruction
J48D2:  POP     DE                      ;
        CALL    FRETMS                  ; free descriptor if temporary and on top of heap
        EX      DE,HL
        CALL    STRCPY                  ; copy string to new temporary string
J48DA:  CALL    FRETMS                  ; free descriptor if temporary and on top of heap
        EX      (SP),HL
J48DE:  CALL    VMOVE                   ; HL=DE (valtyp)
        POP     DE
        POP     HL
        RET

;       Subroutine      ON statement
;       Inputs          ________________________
;       Outputs         ________________________

ONGOTO:
C48E4:  CP      0A6H                    ; ERROR token ?
        JR      NZ,J490D
        _RST    CHRGTR                  ; get next BASIC character (ERROR token)
        _RST    SYNCHR
        DEFB    089H                    ; check for GOTO token
        CALL    LINGET                  ; collect linenumber
        LD      A,D
        OR      E                       ; linenumber zero ?
        JR      Z,J48FB                 ; yep, no ERROR handling
        CALL    C4293                   ; stack HL and search linenumber from start of program
        LD      D,B
        LD      E,C
        POP     HL                      ; restore BASIC pointer
        JP      NC,USERR                ; linenumber not found, undefined line number error
J48FB:  LD      (ONELIN),DE             ; set ERROR handler
        RET     C                       ; not ON ERROR GOTO 0, quit
        LD      A,(ONEFLG)
        OR      A                       ; in ERROR handling routine ?
        LD      A,E                     ; ?? unneeded instruction ??
        RET     Z                       ; nope, quit
        LD      A,(ERRFLG)
        LD      E,A                     ; saved errorcode
        JP      J4096                   ; BASIC error

;       Subroutine      ON statement (not ON ERROR)
;       Inputs          ________________________
;       Outputs         ________________________

J490D:  CALL    ONGOT
        JR      C,J4943
        PUSH    BC
        _RST    CHRGTR                  ; get next BASIC character
        _RST    SYNCHR
        DEFB    08DH                    ; check for GOSUB token
        XOR     A
J4917:  POP     BC
        PUSH    BC
        CP      C
        JP      NC,SNERR                ; nope, syntax error
        PUSH    AF
        CALL    LINGET                  ; collect linenumber
        LD      A,D
        OR      E
        JR      Z,J492E
        CALL    C4293                   ; stack HL and search linenumber from start of program
        LD      D,B
        LD      E,C
        POP     HL
        JP      NC,USERR                ; nope, undefined line number error
J492E:  POP     AF
        POP     BC
        PUSH    AF
        ADD     A,B
        PUSH    BC
        CALL    TRPHDL
        DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        POP     BC
        POP     DE
        RET     Z			; yep, quit
        PUSH    BC
        PUSH    DE
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        POP     AF
        INC     A
        JR      J4917

J4943:  CALL    GETBYT                  ; evaluate byte operand
        LD      A,(HL)
        LD      B,A
        CP      8DH                     ; GOSUB token ?
        JR      Z,J494F
        _RST    SYNCHR
        DEFB    089H                    ; check for GOTO token
        DEC     HL
J494F:  LD      C,E
J4950:  DEC     C
        LD      A,B
        JP      Z,J4646
        CALL    C476A                   ; collect linenumber
        CP      ","
        RET     NZ
        JR      J4950

;       Subroutine      RESUME statement
;       Inputs          ________________________
;       Outputs         ________________________

RESUME:
C495D:  LD      A,(ONEFLG)
        OR      A                       ; in ERROR handling routine ?
        JR      NZ,J496C                ; yep,
        LD      (ONELIN+0),A
        LD      (ONELIN+1),A            ; disable ERROR handler
        JP      J4064                   ; resume without error

J496C:  INC     A
        LD      (ERRFLG),A              ; clear errorcode
        LD      A,(HL)
        CP      83H                     ; NEXT token ?
        JR      Z,J4985                 ; yep,
        CALL    LINGET                  ; collect linenumber
        RET     NZ                      ; not end of statement, quit (which generates syntax error)
        LD      A,D
        OR      E                       ; linenumber zero ?
        JR      Z,J4989                 ; yep, resume at error position
        CALL    C47EB                   ; goto linenumber
        XOR     A
        LD      (ONEFLG),A              ; not in ERROR handling routine anymore
        RET

J4985:  _RST    CHRGTR                  ; get next BASIC character
        RET     NZ                      ; not end of statement, quit (which generates syntax error)
        JR      J498E                   ; flag RESUME 0

J4989:  XOR     A
        LD      (ONEFLG),A              ; not in ERROR handling routine
        INC     A                       ; flag RESUME NEXT
J498E:  LD      HL,(ERRTXT)
        EX      DE,HL
        LD      HL,(ERRLIN)
        LD      (CURLIN),HL             ; current linenumber = linenumber when error occured
        EX      DE,HL                   ; BASIC pointer = BASIC pointer when error occured
        RET     NZ                      ; RESUME NEXT, quit
        LD      A,(HL)
        OR      A                       ; at end of BASIC line ?
        JR      NZ,J49A2                ; nope,
        INC     HL
        INC     HL
        INC     HL
        INC     HL                      ; skip linelink and linenumber
J49A2:  INC     HL
        XOR     A
        LD      (ONEFLG),A              ; not in ERROR handling routine
        JP      DATA                    ; skip to end of statement

;       Subroutine      ERROR statement
;       Inputs          ________________________
;       Outputs         ________________________

ERRORS:
C49AA:  CALL    GETBYT                  ; evaluate byte operand
        RET     NZ                      ; not end of statement, quit (which generates a syntax error)
        OR      A                       ; errornumber 0 ?
        JP      Z,FCERR                 ; yep, illegal function call
        JP      ERROR                   ; BASIC error

;       Subroutine      AUTO statement
;       Inputs          ________________________
;       Outputs         ________________________

AUTO:
C49B5:  LD      DE,10			; default step value = 10
        PUSH    DE			; default starting linenumber = 10
        JR      Z,J49D1			; end of statement, start auto
        CALL    LINSPC                  ; collect linenumber (with DOT supported)
        EX      DE,HL
        EX      (SP),HL			; replace starting linenumber
        JR      Z,J49D2			; end of statement, start auto
        EX      DE,HL
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        LD      DE,(AUTINC)
        JR      Z,J49D1			; end of statement, use previous step value and start auto
        CALL    LINGET                  ; collect linenumber (step value)
        JP      NZ,SNERR                ; not end of statement, syntax error
J49D1:  EX      DE,HL
J49D2:  LD      A,H
        OR      L			; step value is 0 ?
        JP      Z,FCERR                 ; yep, illegal function call error
        LD      (AUTINC),HL
        LD      (AUTFLG),A              ; in auto linenumber mode
        POP     HL
        LD      (AUTLIN),HL
        POP     BC
        JP      MAIN                    ; mainloop

;       Subroutine      IF statement
;       Inputs          ________________________
;       Outputs         ________________________

IFS:
C49E5:  CALL    FRMEVL                  ; evaluate expression
        LD      A,(HL)
        CP      ","
        CALL    Z,CHRGTR                ; yep, get next BASIC character
        CP      89H                     ; GOTO token ?
        JR      Z,J49F5                 ; yep,
        _RST    SYNCHR
        DEFB    0DAH                    ; check for THEN token
        DEC     HL
J49F5:  PUSH    HL
        CALL    VSIGN                   ; get sign DAC
        POP     HL
        JR      Z,J4A0C                 ; DAC is zero, execute ELSE part (if any)
J49FC:  _RST    CHRGTR                  ; get next BASIC character
        RET     Z                       ; end of statement, quit
        CP      0EH                     ; linenumber follows ?
        JP      Z,GOTO                  ; yep, goto statement
        CP      0DH                     ; linepointer follows ?
        JP      NZ,J4646                ; nope, execute THEN part
        LD      HL,(CONLO)
        RET

J4A0C:  LD      D,1                     ; IF nesting level=1
J4A0E:  CALL    DATA                    ; skip to end of statement
        OR      A                       ; end of BASIC line ?
        RET     Z                       ; yep, quit
        _RST    CHRGTR                  ; get next BASIC character
        CP      0A1H                    ; ELSE token ?
        JR      NZ,J4A0E                ; nope, skip more
        DEC     D
        JR      NZ,J4A0E
        JR      J49FC

;       Subroutine      LPRINT statement
;       Inputs          ________________________
;       Outputs         ________________________

LPRINT:
C4A1D:  LD      A,1
        LD      (PRTFLG),A              ; interpreter output to printer
        JR      J4A29

;       Subroutine      PRINT statement
;       Inputs          ________________________
;       Outputs         ________________________

PRINT:
C4A24:  LD      C,2                     ; requested filemode = output
        CALL    FILGET                  ; redirect interpreter output if i/o channel specified
J4A29:  DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        CALL    Z,CRDO                  ; yep, newline to interpreter output
J4A2E:  JP      Z,FINPRT                ; return interpreter output to screen and quit
        CP      0E4H
        JP      Z,PRINUS                ; USING token,
        CP      0DBH
        JP      Z,J4AC6                 ; TAB( token,
        CP      0DFH
        JP      Z,J4AC6                 ; SPC( token,
        PUSH    HL
        CP      ","
        JR      Z,J4A94
        CP      ";"
        JP      Z,J4AFA
        POP     BC
        CALL    FRMEVL                  ; evaluate expression
        PUSH    HL
        _RST    GETYPR
        JR      Z,J4A8D                 ; string,
        CALL    FOUT                    ; convert DAC to text, unformatted
        CALL    STRLIT                  ; analyse string and create temporary stringdescriptor
        LD      (HL),20H
        LD      HL,(DAC+2)
        INC     (HL)
        CALL    H.PRTF
        CALL    ISFLIO                  ; interpreter input/output device = file ?
        JR      NZ,J4A89                ; yep,
        LD      HL,(DAC+2)
        LD      A,(PRTFLG)
        OR      A                       ; interpreter output to screen ?
        JR      Z,J4A77                 ; yep,
        LD      A,(LPTPOS)
        ADD     A,(HL)
        CP      255
        JR      J4A81

J4A77:  LD      A,(LINLEN)
        LD      B,A
        LD      A,(TTYPOS)
        ADD     A,(HL)
        DEC     A
        CP      B
J4A81:  JR      C,J4A89
        CALL    Z,CRFIN                 ; yep, interpreter output pos = 0
        CALL    NZ,CRDO                 ; nope, newline to interpreter output
J4A89:  CALL    STRPRT                  ; free string and string to interpreter output
        OR      A
J4A8D:  CALL    Z,STRPRT                ; free string and string to interpreter output
        POP     HL
        JP      J4A29

J4A94:  CALL    H.COMP
        LD      BC,8
        LD      HL,(PTRFIL)
        ADD     HL,BC
        CALL    ISFLIO                  ; interpreter input/output device = file ?
        LD      A,(HL)			; position in buffer
        JR      NZ,J4ABF                ; yep,
        LD      A,(PRTFLG)
        OR      A                       ; interpreter output to screen ?
        JR      Z,J4AB1                 ; yep,
        LD      A,(LPTPOS)
        CP      0EEH
        JR      J4AB9

J4AB1:  LD      A,(CLMLST)
        LD      B,A
        LD      A,(TTYPOS)
        CP      B
J4AB9:  CALL    NC,CRDO                 ; newline to interpreter output
        JP      NC,J4AFA
J4ABF:  SUB     14
        JR      NC,J4ABF
        CPL
        JR      J4AF3

J4AC6:  PUSH    AF
        CALL    GTBYTC                  ; skip basic char and evaluate byte operand
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        DEC     HL
        POP     AF
        SUB     0DFH
        PUSH    HL
        JR      Z,J4AEF
        LD      BC,8
        LD      HL,(PTRFIL)
        ADD     HL,BC
        CALL    ISFLIO                  ; interpreter input/output device = file ?
        LD      A,(HL)			; position in buffer
        JR      NZ,J4AEF                ; yep,
        LD      A,(PRTFLG)
        OR      A                       ; interpreter output to screen ?
        JP      Z,J4AEC                 ; yep,
        LD      A,(LPTPOS)
        JR      J4AEF

J4AEC:  LD      A,(TTYPOS)
J4AEF:  CPL
        ADD     A,E
        JR      NC,J4AFA
J4AF3:  INC     A
        LD      B,A
        LD      A," "
J4AF7:  _RST    OUTDO                   ; space to interpreter output
        DJNZ    J4AF7
J4AFA:  POP     HL
        _RST    CHRGTR                  ; get next BASIC character
        JP      J4A2E

;       Subroutine      return interpreter output to screen
;       Inputs          ________________________
;       Outputs         ________________________

FINPRT:
C4AFF:  CALL    H.FINP
        XOR     A
        LD      (PRTFLG),A              ; interpreter output to screen
        PUSH    HL
        LD      H,A
        LD      L,A
        LD      (PTRFIL),HL             ; interpreter input/output device = keyboard/screen
        POP     HL
        RET

;       Subroutine      LINE statement
;       Inputs          ________________________
;       Outputs         ________________________

LINE:
C4B0E:  CP      85H                     ; next character INPUT token ?
        JP      NZ,GLINE                ; nope, graphics LINE statement
        _RST    SYNCHR
        DEFB    085H                    ; check for INPUT token
        CP      "#"                     ; bufferid follows ?
        JP      Z,DLINE                 ; yep, LINEINPUT for files
        CALL    C4B7B
        CALL    PTRGET                  ; locate variable
        CALL    CHKSTR                  ; check if string
        PUSH    DE
        PUSH    HL
        CALL    INLIN
        POP     DE
        POP     BC
        JP      C,STPEND                ; aborted,
        PUSH    BC
        PUSH    DE
        LD      B,0
        CALL    STRLT3                  ; analyze string with specified endmaker (1st char is skipped) and create temporary stringdescriptor
        POP     HL
        LD      A,3
        JP      J4892

I4B3A:  DEFB    "?Redo from start",13,10,0

J4B4D:  CALL    H.TRMN
        LD      A,(FLGINP)
J4B53:  OR      A
        JP      NZ,J404F
        POP     BC
        LD      HL,I4B3A
        CALL    STROUT                  ; message to interpreter output
        LD      HL,(SAVTXT)
        RET

J4B62:  CALL    FILINP                  ; redirect interpreter input if i/o channel specified
        PUSH    HL                      ; save BASIC pointer
        LD      HL,BUFMIN
        JP      J4B9B

;       Subroutine      INPUT statement
;       Inputs          ________________________
;       Outputs         ________________________

INPUT:
C4B6C:  CP      "#"                     ; bufferid follows ?
        JR      Z,J4B62                 ; yep,
        PUSH    HL
        PUSH    AF
        CALL    TOTEXT                  ; force text screenmode
        POP     AF
        POP     HL
        LD      BC,I4B8B
        PUSH    BC

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C4B7B:  CP      '"'                     ; inputprompt specified ?
        LD      A,0
        RET     NZ                      ; nope, start input
        CALL    STRLTI                  ; analyze string with " as endmarker (1st char is skipped) and create temporary stringdescriptor
        _RST    SYNCHR
        DEFB    ";"                     ; check for ;
        PUSH    HL
        CALL    STRPRT                  ; free string and string to interpreter output
        POP     HL
        RET

I4B8B:  PUSH    HL
        CALL    QINLIN
        POP     BC
        JP      C,STPEND                ; aborted,
        INC     HL
        LD      A,(HL)
        OR      A
        DEC     HL
        PUSH    BC
        JP      Z,J485A                 ; skip to end of statement
J4B9B:  LD      (HL),","
        JR      J4BA4

;       Subroutine      READ statement
;       Inputs          ________________________
;       Outputs         ________________________

READ:
C4B9F:  PUSH    HL
        LD      HL,(DATPTR)
        DEFB    0F6H                    ; XOR 0AFH, trick to skip next instruction
J4BA4:  XOR     A
        LD      (FLGINP),A
        EX      (SP),HL
        DEFB    001H                    ; LD BC,xxxx, trick to skip next instruction
J4BAA:  _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    PTRGET                  ; locate variable
        EX      (SP),HL
        PUSH    DE
        LD      A,(HL)
        CP      ","
        JR      Z,J4BD1
        LD      A,(FLGINP)
J4BB9:  OR      A
        JP      NZ,J4C40
        LD      A,"?"
        _RST    OUTDO                   ; "?" to interpreter output
        CALL    QINLIN
        POP     DE
        POP     BC
        JP      C,STPEND                ; aborted,
        INC     HL
        LD      A,(HL)
        DEC     HL
        OR      A
        PUSH    BC
        JP      Z,J485A                 ; skip to end of statement
        PUSH    DE
J4BD1:  CALL    ISFLIO                  ; interpreter input/output device = file ?
        JP      NZ,FILIND               ; yep,
        _RST    GETYPR
        PUSH    AF
        JR      NZ,J4BFD                ; not a string,
        _RST    CHRGTR                  ; get next BASIC character
        LD      D,A
        LD      B,A
        CP      '"'
        JR      Z,J4BEE
        LD      A,(FLGINP)
        OR      A
        LD      D,A
        JR      Z,J4BEB
        LD      D,":"
J4BEB:  LD      B,","
        DEC     HL
J4BEE:  CALL    STRLT2                  ; analyse string with specified endmarkers (1st char is skipped) and create temporary stringdescriptor

DOASIG:
J4BF1:  POP     AF
        ADD     A,3
        EX      DE,HL
        LD      HL,I4C05
        EX      (SP),HL
        PUSH    DE
        JP      J4893

J4BFD:  _RST    CHRGTR                  ; get next BASIC character
        LD      BC,DOASIG
        PUSH    BC
        JP      FIN                     ; convert text to number

I4C05:  DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        JR      Z,J4C0E			; yep,
        CP      ","
        JP      NZ,J4B4D
J4C0E:  EX      (SP),HL
        DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        JP      NZ,J4BAA		; nope,
        POP     DE
        LD      A,(FLGINP)
        OR      A
        EX      DE,HL
        JP      NZ,RESFIN               ; set new DATA pointer and quit
        PUSH    DE
        CALL    ISFLIO                  ; interpreter input/output device = file ?
        JR      NZ,J4C2B                ; yep, skip extra ignored
        LD      A,(HL)
        OR      A

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C4C25:  LD      HL,I4C2F
        CALL    NZ,STROUT               ; nope, message to interpreter output
J4C2B:  POP     HL
        JP      FINPRT                  ; return interpreter output to screen

I4C2F:  DEFB    "?Extra ignored",13,10,0

J4C40:  CALL    DATA
        OR      A
        JR      NZ,J4C57
        INC     HL
        LD      A,(HL)
        INC     HL
        OR      (HL)
        LD      E,4
        JP      Z,ERROR                 ; yep, out of data error
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      (DATLIN),DE
J4C57:  _RST    CHRGTR                  ; get next BASIC character
        CP      84H
        JR      NZ,J4C40
        JP      J4BD1

;       Subroutine      evaluate = expression
;       Inputs          HL = basicpointer
;       Outputs         ________________________

FRMEQL:
C4C5F:  _RST    SYNCHR
        DEFB    0EFH                    ; check for =
        DEFB    001H                    ; LD BC,xxxx, trick to skip next instruction

;       Subroutine      evaluate ( expression
;       Inputs          HL = basicpointer
;       Outputs         ________________________

FRMPRN:
C4C62:  _RST    SYNCHR
        DEFB    "("                     ; check for (

;       Subroutine      FRMEVL (Expression Evaluator)
;       Inputs          HL = BASIC pointer
;       Outputs         ________________________

FRMEVL:
C4C64:  DEC     HL


;       Subroutine      skip character and evaluate expression
;       Inputs          ________________________
;       Outputs         ________________________

FRMCHK:
C4C65:  LD      D,0                     ; current precedence level 0

;       Subroutine      skip character and evaluate expression with precendence level
;       Inputs          ________________________
;       Outputs         ________________________

LPOPER:
C4C67:  PUSH    DE
        LD      C,1
        CALL    GETSTK                  ; check if enough stackspace for 1 word
        CALL    H.FRME
        CALL    EVAL                    ; evaluate factor
TSTOP:
I4C73:  LD      (TEMP2),HL
J4C76:  LD      HL,(TEMP2)
        POP     BC
        LD      A,(HL)
        LD      (TEMP3),HL
        CP      0EEH                    ; token EEH or above ?
        RET     C                       ; nope, quit (expression ends)
        CP      0F1H                    ; math operator ?
        JR      C,J4CE4                 ; nope, relational operators (EEH-F0H)
        SUB     0F1H
        LD      E,A
        JR      NZ,J4C93                ; not a addition
        LD      A,(VALTYP)
        CP      3                       ; string ?
        LD      A,E
        JP      Z,CAT                   ; yep, concat strings
J4C93:  CP      0FDH-0F1H               ; token FDH-FFH ?
        RET     NC                      ; yep, quit
        LD      HL,I3D3B                ; table for math operator precedence level
        LD      D,0
        ADD     HL,DE
        LD      A,B
        LD      D,(HL)
        CP      D                       ; same or smaller precedence level ?
        RET     NC                      ; yep,
J4CA0:  PUSH    BC                      ; save current precedence level
        LD      BC,J4C76
        PUSH    BC                      ; return
        LD      A,D
        CALL    H.NTPL
        CP      51H
        JR      C,J4CFD
        AND     0FEH
        CP      7AH
        JR      Z,J4CFD
J4CB3:  LD      HL,DAC+2
        LD      A,(VALTYP)
        SUB     3
        JP      Z,TMERR                 ; type mismatch
        OR      A
        LD      HL,(DAC+2)
        PUSH    HL
        JP      M,J4CD5                 ; integer
        LD      HL,(DAC+0)
        PUSH    HL
        JP      PO,J4CD5
        LD      HL,(DAC+6)
        PUSH    HL
        LD      HL,(DAC+4)
        PUSH    HL
J4CD5:  ADD     A,3
        LD      C,E
        LD      B,A
        PUSH    BC
        LD      BC,I4D22
J4CDD:  PUSH    BC
        LD      HL,(TEMP3)
        JP      LPOPER                  ; skip character and evaluate expression with precendence level

J4CE4:  LD      D,0                     ; clear flag
J4CE6:  SUB     0EEH                    ; relational operators ?
        JR      C,J4D08                 ; nope,
        CP      0F0H-0EEH+1
        JR      NC,J4D08                ; nope,
        CP      0EFH-0EEH
        RLA                             ; b0 is >, b1 is =, b2 is <
        XOR     D
        CP      D                       ; > = > >= >< >=< =< 
        LD      D,A
        JP      C,SNERR                 ; nope, syntax error
        LD      (TEMP3),HL
        _RST    CHRGTR                  ; get next BASIC character
        JR      J4CE6

J4CFD:  PUSH    DE
        CALL    FRCINT                  ; convert DAC to integer
        POP     DE
        PUSH    HL
        LD      BC,I4F78
        JR      J4CDD

J4D08:  LD      A,B
        CP      100
        RET     NC
        PUSH    BC
        PUSH    DE
        LD      DE,100*256+5
        LD      HL,I4F57
        PUSH    HL
        _RST    GETYPR
        JP      NZ,J4CB3                ; not a string,
        LD      HL,(DAC+2)
        PUSH    HL			; save pointer to string descriptor
        LD      BC,STRCMP		; string compare routine
        JR      J4CDD

;       Subroutine      apply infix math operator
;       Inputs          ________________________
;       Outputs         ________________________

I4D22:  POP     BC
        LD      A,C
        LD      (DORES),A
        LD      A,(VALTYP)
        CP      B
        JR      NZ,J4D38
        CP      2
        JR      Z,J4D50
        CP      4
        JP      Z,J4D9D
        JR      NC,J4D63
J4D38:  LD      D,A
        LD      A,B
        CP      8
        JR      Z,J4D60
        LD      A,D
        CP      8
        JR      Z,J4D87
        LD      A,B
        CP      4
        JR      Z,J4D9A
        LD      A,D
        CP      3
        JP      Z,TMERR                 ; type mismatch
        JR      NC,J4DA4
J4D50:  LD      HL,I3D69
        LD      B,00H
        ADD     HL,BC
        ADD     HL,BC
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        POP     DE
        LD      HL,(DAC+2)
        PUSH    BC
        RET

J4D60:  CALL    FRCDBL                  ; convert DAC to double real
J4D63:  CALL    VMOVAF                  ; ARG = DAC
        POP     HL
        LD      (DAC+4),HL
        POP     HL
        LD      (DAC+6),HL
J4D6E:  POP     BC
        POP     DE
        CALL    MOVFR                   ; DAC = (single)
J4D73:  CALL    FRCDBL                  ; convert DAC to double real
        LD      HL,I3D51
J4D79:  LD      A,(DORES)
        RLCA
        ADD     A,L
        LD      L,A
        ADC     A,H
        SUB     L
        LD      H,A
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A
        JP      (HL)

J4D87:  LD      A,B
        PUSH    AF
        CALL    VMOVAF                  ; ARG = DAC
        POP     AF
        LD      (VALTYP),A
        CP      4
        JR      Z,J4D6E
        POP     HL
        LD      (DAC+2),HL
        JR      J4D73

J4D9A:  CALL    FRCSNG                  ; convert DAC to single real
J4D9D:  POP     BC
        POP     DE
J4D9F:  LD      HL,I3D5D
        JR      J4D79

J4DA4:  POP     HL
        CALL    PUSHF                   ; push DAC (single)
        CALL    CONSIH                  ; convert to single precision real
        CALL    MOVRF                   ; DEBC = DAC (single)
        POP     HL
        LD      (DAC+0),HL
        POP     HL
        LD      (DAC+2),HL
        JR      J4D9F

INTDIV:
C4DB8:  PUSH    HL
        EX      DE,HL
        CALL    CONSIH                  ; convert to single precision real
        POP     HL
        CALL    PUSHF                   ; push DAC (single)
        CALL    CONSIH                  ; convert to single precision real
        JP      SGNDVT

;       Subroutine      Factor Evaluator
;       Inputs          ________________________
;       Outputs         ________________________

EVAL:
C4DC7:  _RST    CHRGTR                  ; get next BASIC character
        JP      Z,J406A                 ; end of statement, missing operand error
        JP      C,FIN                   ; convert text to number
        CALL    ISLET2                  ; is upcase letter character ?
        JP      NC,ISVAR                ; yep, get variable value
        CP      20H                     ; numeric token ?
        JP      C,J46B8                 ; yep, get constant value
        CALL    H.EVAL
        INC     A                       ; function token ?
        JP      Z,J4EFC                 ; yep, handle function
        DEC     A
        CP      0F1H                    ; + token ?
        JR      Z,EVAL                  ; yep, again
        CP      0F2H                    ; - token ?
        JP      Z,J4E8D                 ; yep,
        CP      '"'
        JP      Z,STRLTI                ; analyze string with " as endmarker (1st char is skipped) and create temporary stringdescriptor and quit
        CP      0E0H                    ; NOT token ?
        JP      Z,J4F63                 ; yep,
        CP      "&"
        JP      Z,C4EB8                 ; convert text with radix indication to number
        CP      0E2H                    ; ERR token ?
        JR      NZ,J4E07                ; nope, other

;       Subroutine      ERR function
;       Inputs          ________________________
;       Outputs         ________________________

        _RST    CHRGTR                  ; get next BASIC character
        LD      A,(ERRFLG)
        PUSH    HL
        CALL    SNGFLT                  ; byte to DAC
        POP     HL
        RET

J4E07:  CP      0E1H                    ; ERL token ?
        JR      NZ,J4E15                ; nope, other

;       Subroutine      ERL function
;       Inputs          ________________________
;       Outputs         ________________________

        _RST    CHRGTR                  ; get next BASIC character
        PUSH    HL
        LD      HL,(ERRLIN)
        CALL    CONSUI                  ; convert unsigned integer to single real
        POP     HL
        RET

J4E15:  CP      0EDH                    ; POINT token ?
        JP      Z,POINT                 ; yep, POINT function handler
        CP      0CBH                    ; TIME token ?
        JP      Z,TIME$                 ; yep, TIME function handler
        CP      0C7H                    ; SPRITE token ?
        JP      Z,SPRIT$                ; yep, SPRITE function handler
        CP      0C8H                    ; VDP token ?
        JP      Z,VDP$                  ; yep, VDP function handler
        CP      0C9H                    ; BASE token ?
        JP      Z,BASE$                 ; yep, BASE function handler
        CP      0C1H                    ; PLAY token ?
        JP      Z,PLAY$                 ; yep, PLAY function handler
        CP      0EAH                    ; DSKI$ token ?
        JP      Z,DSKI$                 ; yep, DSKI$ function handler
        CP      0E9H                    ; ATTR$ token ?
        JP      Z,ATTR$                 ; yep, ATTR$ function handler
        CP      0E7H                    ; VARPTR token ?
        JR      NZ,J4E64                ; nope, other

;       Subroutine      VARPTR function
;       Inputs          ________________________
;       Outputs         ________________________

        _RST    CHRGTR                  ; get next BASIC character
        _RST    SYNCHR
        DEFB    "("                     ; check for (
        CP      "#"
        JR      NZ,J4E53                ; no fileid, varptr for variables
        CALL    GTBYTC                  ; skip basic char and evaluate byte operand
        PUSH    HL
        CALL    FILIDX                  ; get i/o channel pointer
        EX      DE,HL
        POP     HL
        JR      J4E56

J4E53:  CALL    PTRGTV                  ; locate variable (search only)
J4E56:  _RST    SYNCHR
        DEFB    ")"                     ; check for )
        PUSH    HL
        EX      DE,HL
        LD      A,H
        OR      L                       ; variable found ?
        JP      Z,FCERR                 ; nope, illegal function call
        CALL    MAKINT                  ; put HL in DAC
        POP     HL
        RET

J4E64:  CP      0DDH                    ; USR token ?
        JP      Z,USRFN                 ; yep, USR function handler
        CP      0E5H                    ; INSTR token ?
        JP      Z,INSTR                 ; yep, INSTR function handler
        CP      0ECH                    ; INKEY$ token ?
        JP      Z,INKEY                 ; yep, INKEY$ function handler
        CP      0E3H                    ; STRING$ token ?
        JP      Z,STRNG$                ; yep, STRING$ function handler
        CP      85H                     ; INPUT token ?
        JP      Z,FIXINP                ; yep, INPUT function handler
        CP      0E8H                    ; CSRLIN token ?
        JP      Z,CSRLIN                ; yep, CSRLIN function handler
        CP      0DEH                    ; FN token ?
        JP      Z,FNDOER                ; yep, FN function handler

;       Subroutine      evaluate ( expression )
;       Inputs          ________________________
;       Outputs         ________________________

C4E87:  CALL    FRMPRN                  ; evaluate ( expression
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        RET

J4E8D:  LD      D,7DH
        CALL    LPOPER                  ; skip character and evaluate expression with precendence level
        LD      HL,(TEMP2)
        PUSH    HL
        CALL    VNEG                    ; negate
I4E99:  POP     HL
        RET

;       Subroutine      get variable value
;       Inputs          ________________________
;       Outputs         ________________________

ISVAR:
C4E9B:  CALL    PTRGET                  ; locate variable (without creation)
        PUSH    HL
        EX      DE,HL
        LD      (DAC+2),HL
        _RST    GETYPR
        CALL    NZ,VMOVFM               ; not a string, DAC = HL
        POP     HL
        RET

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

MAKUPL:
C4EA9:  LD      A,(HL)

;       Subroutine      upcase char
;       Inputs          ________________________
;       Outputs         ________________________

MAKUPS:
C4EAA:  CP      "a"
        RET     C
        CP      "z"+1
        RET     NC
        AND     5FH
        RET

;       Subroutine      ?
;       Inputs          ________________________
;       Outputs         ________________________
;       Unused Code     Not called from anywhere, leftover from a early Microsoft BASIC

?4EB3:  CP      "&"
        JP      NZ,LINGET               ; collect linenumber

;       Subroutine      convert text with radix indication to number
;       Inputs          ________________________
;       Outputs         ________________________

OCTCNS:
C4EB8:  LD      DE,0
        _RST    CHRGTR                  ; get next BASIC character
        CALL    MAKUPS
        LD      BC,0102H
        CP      "B"
        JR      Z,J4ED5
        LD      BC,0308H
        CP      "O"
        JR      Z,J4ED5
        LD      BC,0410H
        CP      "H"
        JP      NZ,SNERR                ; nope, syntax error
J4ED5:  INC     HL
        LD      A,(HL)
        EX      DE,HL
        CALL    MAKUPS
        CP      "9"+1
        JR      C,J4EE5
        CP      "A"
        JR      C,J4EF7
        SUB     7
J4EE5:  SUB     "0"
        CP      C
        JR      NC,J4EF7
        PUSH    BC
J4EEB:  ADD     HL,HL
        JP      C,OVERR                 ; overflow error
        DJNZ    J4EEB
        POP     BC
        OR      L
        LD      L,A
        EX      DE,HL
        JR      J4ED5

J4EF7:  CALL    MAKINT                  ; put HL in DAC
        EX      DE,HL
        RET

J4EFC:  INC     HL
        LD      A,(HL)
        SUB     81H
        LD      B,00H
        RLCA
        LD      C,A
        PUSH    BC
        _RST    CHRGTR                  ; get next BASIC character
        LD      A,C
        CP      05H
        JR      NC,J4F21
        CALL    FRMPRN                  ; evaluate ( expression
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    CHKSTR                  ; check if string
        EX      DE,HL
        LD      HL,(DAC+2)
        EX      (SP),HL
        PUSH    HL
        EX      DE,HL
        CALL    GETBYT                  ; evaluate byte operand
        EX      DE,HL
        EX      (SP),HL
        JR      J4F3B

J4F21:  CALL    C4E87                   ; evaluate ( expression )
        EX      (SP),HL
        LD      A,L
        CP      0CH
        JR      C,J4F37

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C4F2A:  CP      1BH
        CALL    H.OKNO
        JR      NC,J4F37
        _RST    GETYPR
        PUSH    HL
        CALL    C,FRCDBL                ; not a double real, convert DAC to double real
        POP     HL
J4F37:  LD      DE,I4E99
        PUSH    DE
J4F3B:  LD      BC,I39DE
        CALL    H.FING

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C4F41:  ADD     HL,BC
        LD      C,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,C
        JP      (HL)

;       Subroutine      check if sign, go back if not
;       Inputs          D = 0, HL = pointer
;       Outputs         Zx set if sign was found, D = FFH when - sign found

MINPLS:
C4F47:  DEC     D
        CP      0F2H			; - token ?
        RET     Z			; yep, quit
        CP      "-"
        RET     Z
        INC     D
        CP      "+"
        RET     Z
        CP      0F1H			; + token ?
        RET     Z			; yep, quit
        DEC     HL
        RET

;       Subroutine      apply infix relational operator
;       Inputs          ________________________
;       Outputs         ________________________

I4F57:  INC     A
        ADC     A,A
        POP     BC
        AND     B
        ADD     A,0FFH
        SBC     A,A
        CALL    CONIA
        JR      J4F75

J4F63:  LD      D,5AH
        CALL    LPOPER                  ; skip character and evaluate expression with precendence level
        CALL    FRCINT                  ; convert DAC to integer
        LD      A,L
        CPL
        LD      L,A
        LD      A,H
        CPL
        LD      H,A
        LD      (DAC+2),HL
        POP     BC
J4F75:  JP      J4C76

;       Subroutine      apply infix logical operator
;       Inputs          ________________________
;       Outputs         ________________________

I4F78:  LD      A,B
        PUSH    AF
        CALL    FRCINT                  ; convert DAC to integer
        POP     AF
        POP     DE
        CP      7AH
        JP      Z,IMOD                  ; integer mod
        CP      7BH
        JP      Z,IDIV                  ; integer divide
        LD      BC,GIVINT
        PUSH    BC
        CP      46H
        JR      NZ,J4F97
        LD      A,E
        OR      L
        LD      L,A
        LD      A,H
        OR      D
        RET

J4F97:  CP      50H
        JR      NZ,J4FA1
        LD      A,E
        AND     L
        LD      L,A
        LD      A,H
        AND     D
        RET

J4FA1:  CP      3CH
        JR      NZ,J4FAB
        LD      A,E
        XOR     L
        LD      L,A
        LD      A,H
        XOR     D
        RET

J4FAB:  CP      32H
        JR      NZ,J4FB7
        LD      A,E
        XOR     L
        CPL
        LD      L,A

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C4FB3:  LD      A,H
        XOR     D
        CPL
        RET

J4FB7:  LD      A,L
        CPL
        AND     E
        CPL
        LD      L,A
        LD      A,H
        CPL
        AND     D
        CPL
        RET

GIVDBL:
J4FC1:  OR      A
        SBC     HL,DE
        JP      CONSUI                  ; convert unsigned integer to single real

;       Subroutine      LPOS function
;       Inputs          ________________________
;       Outputs         ________________________

LPOS:
C4FC7:  LD      A,(LPTPOS)
        JR      SNGFLT                  ; byte to DAC

;       Subroutine      POS function
;       Inputs          ________________________
;       Outputs         ________________________

POS:
C4FCC:  LD      A,(TTYPOS)

;       Subroutine      put byte in DAC
;       Inputs          ________________________
;       Outputs         ________________________

SNGFLT:
C4FCF:  LD      L,A
        XOR     A

GIVINT:
C4FD1:  LD      H,A
        JP      MAKINT                  ; put HL in DAC

;       Subroutine      USR function
;       Inputs          ________________________
;       Outputs         ________________________
;       Remark  user machinecode subroutine gets the following parameters:
;               HL = DAC, A = variabletype, DE = start of string

USRFN:
J4FD5:  CALL    C4FF4                   ; get usernumber and USRTAB entry
        PUSH    DE
        CALL    C4E87                   ; evaluate ( expression )
        EX      (SP),HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      HL,POPHRT
        PUSH    HL                      ; return here to restore basictext pointer after user subroutine
        PUSH    DE
        LD      A,(VALTYP)
        PUSH    AF
        CP      3
        CALL    Z,FREDAC                ; parameter is a string, free temporary string in DAC
        POP     AF
        EX      DE,HL
        LD      HL,DAC
        RET                             ; start user machinecode subroutine

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C4FF4:  _RST    CHRGTR                  ; get next BASIC character
        LD      BC,0
        CP      1BH
        JR      NC,J5007
        CP      11H
        JR      C,J5007
        _RST    CHRGTR                  ; get next BASIC character
        LD      A,(CONLO)
        OR      A
        RLA
        LD      C,A
J5007:  EX      DE,HL
        LD      HL,USRTAB
        ADD     HL,BC
        EX      DE,HL
        RET

;       Subroutine      DEF USR statement
;       Inputs          ________________________
;       Outputs         ________________________

J500E:  CALL    C4FF4
        PUSH    DE
        _RST    SYNCHR
        DEFB    0EFH                    ; check for =
        CALL    GETUIN                  ; evaluate address operand
        EX      (SP),HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        POP     HL
        RET

;       Subroutine      DEF statement
;       Inputs          ________________________
;       Outputs         ________________________

DEF:
C501D:  CP      0DDH
        JR      Z,J500E                 ; USR token, DEFUSR
        CALL    C51A1                   ; check for FN and create functionname var
        CALL    C5193                   ; illegal direct when in direct mode
        EX      DE,HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        EX      DE,HL                   ; save pointer to functiondefinition
        LD      A,(HL)
        CP      "("
        JP      NZ,DATA                 ; no parameters, skip to next statement and continue
        _RST    CHRGTR                  ; get next BASIC character
J5033:  CALL    PTRGET                  ; locate variable
        LD      A,(HL)
        CP      ")"
        JP      Z,DATA                  ; end of parameters, skip to next statement and continue
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        JR      J5033                   ; parse through parameters

;       Subroutine      FN function
;       Inputs          ________________________
;       Outputs         ________________________

FNDOER:
J5040:  CALL    C51A1                   ; check for FN and locate functionname var
        LD      A,(VALTYP)
        OR      A
        PUSH    AF
        LD      (TEMP2),HL              ; save BASIC pointer
        EX      DE,HL
        LD      A,(HL)
        INC     HL
        LD      H,(HL)
        LD      L,A                     ; pointer to functiondefinition
        LD      A,H
        OR      L
        JP      Z,J4061                 ; not defined, undefined user function error
        LD      A,(HL)
        CP      "("
        JP      NZ,J50F4                ; no parameters, skip
        _RST    CHRGTR                  ; get next BASIC character
        LD      (TEMP3),HL              ; save functiondefinition pointer
        EX      DE,HL
        LD      HL,(TEMP2)
        _RST    SYNCHR
        DEFB    "("                     ; check for (
        XOR     A
        PUSH    AF
        PUSH    HL
        EX      DE,HL
J5069:  LD      A,80H
        LD      (SUBFLG),A              ; variable search flag = function variable
        CALL    PTRGET                  ; locate variable
        EX      DE,HL
        EX      (SP),HL
        LD      A,(VALTYP)
        PUSH    AF
        PUSH    DE
        CALL    FRMEVL                  ; evaluate expression
        LD      (TEMP2),HL              ; save basictext pointer
        POP     HL
        LD      (TEMP3),HL
        POP     AF
        CALL    C517A                   ; convert to DAC to new type
        LD      C,4
        CALL    GETSTK                  ; check if enough stackspace for 4 words
        LD      HL,-8
        ADD     HL,SP
        LD      SP,HL
        CALL    VMOVMF                  ; HL = DAC
        LD      A,(VALTYP)
        PUSH    AF
        LD      HL,(TEMP2)              ; restore basictext pointer
        LD      A,(HL)
        CP      ")"
        JR      Z,J50AD
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        PUSH    HL
        LD      HL,(TEMP3)
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        JR      J5069

I50A9:  POP     AF
        LD      (PRMLN2),A
J50AD:  POP     AF
        OR      A
        JR      Z,J50E9
        LD      (VALTYP),A
        LD      HL,0
        ADD     HL,SP
        CALL    VMOVFM                  ; DAC = HL
        LD      HL,8
        ADD     HL,SP
        LD      SP,HL
        POP     DE
        LD      L,03H
        DEC     DE
        DEC     DE
        DEC     DE
        LD      A,(VALTYP)
        ADD     A,L
        LD      B,A
        LD      A,(PRMLN2)
        LD      C,A
        ADD     A,B
        CP      64H
        JP      NC,FCERR                ; illegal function call
        PUSH    AF
        LD      A,L
        LD      B,00H
        LD      HL,PARM2
        ADD     HL,BC
        LD      C,A
        CALL    C518E
        LD      BC,I50A9
        PUSH    BC
        PUSH    BC
        JP      J489E

J50E9:  LD      HL,(TEMP2)
        _RST    CHRGTR                  ; get next BASIC character
        PUSH    HL
        LD      HL,(TEMP3)
        _RST    SYNCHR
        DEFB    ")"                     ; check for )
        DEFB    03EH                    ; LD A,xx, trick to skip next instruction
J50F4:  PUSH    DE
        LD      (TEMP3),HL
        LD      A,(PRMLEN)
        ADD     A,4
        PUSH    AF
        RRCA
        LD      C,A                     ; number of words
        CALL    GETSTK                  ; check if enough stackspace
        POP     AF
        LD      C,A
        CPL
        INC     A
        LD      L,A
        LD      H,0FFH
        ADD     HL,SP
        LD      SP,HL
        PUSH    HL
        LD      DE,PRMSTK
        CALL    C518E
        POP     HL
        LD      (PRMSTK),HL
        LD      HL,(PRMLN2)
        LD      (PRMLEN),HL
        LD      B,H
        LD      C,L
        LD      HL,PARM1
        LD      DE,PARM2
        CALL    C518E
        LD      H,A
        LD      L,A
        LD      (PRMLN2),HL
        LD      HL,(FUNACT)
        INC     HL
        LD      (FUNACT),HL
        LD      A,H
        OR      L
        LD      (NOFUNS),A
        LD      HL,(TEMP3)
        CALL    FRMEQL                  ; evaluate = expression
        DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        JP      NZ,SNERR                ; nope, syntax error
        _RST    GETYPR
        JR      NZ,J5156                ; not a string,
        LD      DE,DSCTMP
        LD      HL,(DAC+2)
        _RST    DCOMPR
        JR      C,J5156
        CALL    STRCPY                  ; copy string to new temporary string
        CALL    PUTTMP                  ; push descriptor to temporary desciptor heap
J5156:  LD      HL,(PRMSTK)
        LD      D,H
        LD      E,L
        INC     HL
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)
        INC     BC
        INC     BC
        INC     BC
        INC     BC
        LD      HL,PRMSTK
        CALL    C518E
        EX      DE,HL
        LD      SP,HL
        LD      HL,(FUNACT)
        DEC     HL
        LD      (FUNACT),HL
        LD      A,H
        OR      L
        LD      (NOFUNS),A
        POP     HL
        POP     AF

;       Subroutine      convert DAC to other type
;       Inputs          A = new type, (VALTYP) = current type, (DAC) = current value
;       Outputs         ________________________

DOCNVF:
C517A:  PUSH    HL
        AND     07H
        LD      HL,I3D47
        LD      C,A
        LD      B,0
        ADD     HL,BC
        CALL    C4F41
        POP     HL
        RET

J5189:  LD      A,(DE)
        LD      (HL),A
        INC     HL
        INC     DE
        DEC     BC

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C518E:  LD      A,B
        OR      C
        JR      NZ,J5189
        RET

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C5193:  PUSH    HL
        LD      HL,(CURLIN)
        INC     HL
        LD      A,H
        OR      L                       ; interpreter in direct mode ?
        POP     HL
        RET     NZ                      ; nope, quit
        LD      E,12
        JP      ERROR                   ; illegal direct error

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C51A1:  _RST    SYNCHR
        DEFB    0DEH                    ; check for FN token
        LD      A,080H
        LD      (SUBFLG),A              ; variable search flag = function variable
        OR      (HL)
        LD      C,A                     ; first varletter with b7 set
        JP      PTRGT2                  ; locate functionname variable

;       Subroutine      check if function token allowed as statement
;       Inputs          ________________________
;       Outputs         ________________________

J51AD:  CP      0FFH-081H               ; function token header ?
        JR      NZ,J51C6                ; nope, syntax error
        INC     HL
        LD      A,(HL)                  ; get function token
        INC     HL
        CP      83H                     ; MID$ ?
        JP      Z,MIDS                  ; yep, execute MID$ statement
        CP      0A3H                    ; STRIG ?
        JP      Z,STRIGS                ; yep, execute STRIG statement
        CP      85H                     ; INT ?
        JP      Z,INTS                  ; yep, check if INTERVAL
        CALL    H.ISMI                  ; hook for more function tokens as statement
J51C6:  JP      SNERR                   ; syntax error

;       Subroutine      WIDTH statement
;       Inputs          ________________________
;       Outputs         ________________________

WIDTH:
C51C9:  CALL    GETBYT                  ; evaluate byte operand
        CALL    H.WIDT
        AND     A                       ; width 0 ?
        jr      z,A51DF
        ld      a,(OLDSCR)
        and     a
        ld      a,e
        jr      z,A51DD
        cp      32+1
        jr      nc,A51DF
A51DD:  cp      40+1
A51DF:  jp      nc,FCERR
        ld      a,(LINLEN)
        cp      e
        ret     z
        ld      a,00CH
        _RST    OUTDO
        ld      a,e
        ld      (LINLEN),a
        ld      a,(OLDSCR)
        dec     a
        ld      a,e
        jr      nz,A51FA
        ld      (LINL32),a
        jr      A51FD

A51FA:  ld      (LINL40),a
A51FD:  ld      a,00CH
        _RST    OUTDO
        ld      a,e

MORCP2:
A5201:  sub     14
        jr      nc,A5201
        add     a,2*14
        cpl
        inc     a
        add     a,e
        ld      (CLMLST),a
        ret

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

GETINT:
C520E:  _RST    CHRGTR                  ; get next BASIC character

;       Subroutine      evaluate integer operand
;       Inputs          ________________________
;       Outputs         ________________________

GETIN2:
C520F:  CALL    FRMEVL                  ; evaluate expression

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

INTFR2:
C5212:  PUSH    HL
        CALL    FRCINT                  ; convert DAC to integer
        EX      DE,HL
        POP     HL
        LD      A,D
        OR      A
        RET

;       Subroutine      skip basic char and evaluate byte operand
;       Inputs          ________________________
;       Outputs         ________________________

GTBYTC:
C521B:  _RST    CHRGTR                  ; get next BASIC character

;       Subroutine      evaluate byte operand
;       Inputs          ________________________
;       Outputs         ________________________

GETBYT:
C521C:  CALL    FRMEVL                  ; evaluate expression

;       Subroutine      check for byte value
;       Inputs          ________________________
;       Outputs         ________________________

CONINT:
C521F:  CALL    INTFR2
        JP      NZ,FCERR                ; illegal function call
        DEC     HL
        _RST    CHRGTR                  ; end of statement ?
        LD      A,E
        RET

;       Subroutine      LLIST statement
;       Inputs          ________________________
;       Outputs         ________________________

LLIST:
C5229:  LD      A,1
        LD      (PRTFLG),A              ; interpreter output to printer

;       Subroutine      LIST statement
;       Inputs          ________________________
;       Outputs         ________________________

LIST:
C522E:  CALL    H.LIST
        POP     BC
        CALL    C4279                   ; evaluate linenumber (range) and search start linenumber
        PUSH    BC                      ; save pointer to startline
J5236:  LD      HL,0FFFFH
        LD      (CURLIN),HL             ; interpreter in direct mode
        POP     HL                      ; pointer startline
        POP     DE                      ; end linenumber
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; linepointer
        INC     HL
        LD      A,B
        OR      C                       ; end of program ?
        JP      Z,READY                 ; yep, ok and mainloop
        CALL    ISFLIO                  ; interpreter input/output device = file ?
        CALL    Z,ISCNTC                ; nope, check CTRL-STOP
        PUSH    BC                      ; save start of next line
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; linenumber
        INC     HL
        PUSH    BC
        EX      (SP),HL
        EX      DE,HL
        _RST    DCOMPR                  ; compare with end linenumber
        POP     BC
        JP      C,STPRDY                ; all done, ok and mainloop (+POP)
        EX      (SP),HL
        PUSH    HL
        PUSH    BC
        EX      DE,HL
        LD      (DOT),HL
        CALL    LINPRT                  ; number to interpreter output
        POP     HL
        LD      A,(HL)
        CP      09H                     ; TAB ?
        JR      Z,J526D                 ; yep, skip space
        LD      A," "
        _RST    OUTDO                   ; space to interpreter output
J526D:  CALL    C5284                   ; decode BASIC line
        LD      HL,BUF
        CALL    C527B                   ; string to interpreter output
        CALL    CRDO                    ; newline to interpreter output
        JR      J5236                   ; next line

;       Subroutine      string to interpreter output
;       Inputs          ________________________
;       Outputs         ________________________

C527B:  LD      A,(HL)
        OR      A
        RET     Z
        CALL    OUTCH1                  ; char to interpreter output, LF expanded
        INC     HL
        JR      C527B

;       Subroutine      decode BASIC line
;       Inputs          ________________________
;       Outputs         ________________________

C5284:  LD      BC,BUF
        LD      D,255
        XOR     A
        LD      (DORES),A               ; clear decode status
        JR      J5293

J528F:  INC     BC
        INC     HL
        DEC     D
        RET     Z                       ; buffer full, quit
J5293:  LD      A,(HL)
        OR      A                       ; end of BASIC line ?
        LD      (BC),A
        RET     Z                       ; yep, quit
        CP      0BH                     ; 01H-0AH ?
        JR      C,J52C0                 ; yep, next BASIC char
        CP      20H                     ; 0BH-1FH ?
        JP      C,J5361                 ; yep, numeric token
        CP      '"'                     ; begin/end of string ?
        JR      NZ,J52AE                ; nope,
        LD      A,(DORES)
        XOR     01H
        LD      (DORES),A               ; toggle string status
        LD      A,'"'
J52AE:  CP      ":"                     ; statement seperator ?
        JR      NZ,J52C0                ; nope,
        LD      A,(DORES)
        RRA                             ; in string ?
        JR      C,J52BE                 ; yep,
        RLA
        AND     0FDH
        LD      (DORES),A               ; clear data statement flag
J52BE:  LD      A,":"
J52C0:  OR      A                       ; 01H-7FH ?
        JP      P,J528F                 ; yep, next BASIC char
        LD      A,(DORES)
        RRA                             ; in string ?
        JR      C,J52F8                 ; yep, next BASIC char
        RRA
        RRA                             ; in rem statement ?
        JR      NC,J530C                ; nope,
        LD      A,(HL)
        CP      0E6H                    ; ' token ?
        PUSH    HL
        PUSH    BC
        LD      HL,I52F5
        PUSH    HL                      ; when quit, next BASIC char
        RET     NZ                      ; nope, next BASIC char
        DEC     BC
        LD      A,(BC)
        CP      "M"
        RET     NZ
        DEC     BC
        LD      A,(BC)
        CP      "E"
        RET     NZ
        DEC     BC
        LD      A,(BC)
        CP      "R"
        RET     NZ
        DEC     BC
        LD      A,(BC)
        CP      ":"                     ; preceeded by :REM ?
        RET     NZ                      ; nope, next BASIC char
        POP     AF                      ; remove returnaddress
        POP     AF                      ; remove buf pointer
        POP     HL                      ; restore line pointer
        INC     D
        INC     D
        INC     D
        INC     D                       ; remove :REM
        JR      J531A                   ; translate '

I52F5:  POP     BC
        POP     HL
        LD      A,(HL)
J52F8:  JP      J528F

;       Subroutine      set data statement flag
;       Inputs          ________________________
;       Outputs         ________________________

C52FB:  LD      A,(DORES)
        OR      02H
J5300:  LD      (DORES),A
        XOR     A
        RET

;       Subroutine      set rem statement flag
;       Inputs          ________________________
;       Outputs         ________________________

C5305:  LD      A,(DORES)
        OR      04H
        JR      J5300

J530C:  RLA                             ; in data statement ?
        JR      C,J52F8                 ; yep, next BASIC char
        LD      A,(HL)
        CP      84H                     ; DATA token ?
        CALL    Z,C52FB                 ; yep, set data statement flag
        CP      8FH                     ; REM token ?
        CALL    Z,C5305                 ; yep, set rem statement flag
J531A:  LD      A,(HL)
        INC     A                       ; function token header ?
        LD      A,(HL)
        JR      NZ,J5323                ; nope,
        INC     HL
        LD      A,(HL)                  ; function token
        AND     7FH                     ; to 000H-07FH range
J5323:  INC     HL
        CP      0A1H                    ; ELSE token ?
        JR      NZ,J532A                ; nope,
        DEC     BC
        INC     D
J532A:  PUSH    HL
        PUSH    BC
        PUSH    DE
        CALL    H.BUFL
        LD      HL,T3A72-1
        LD      B,A
        LD      C,"A"-1
J5336:  INC     C
J5337:  INC     HL
        LD      D,H
        LD      E,L
J533A:  LD      A,(HL)
        OR      A
        JR      Z,J5336
        INC     HL
        JP      P,J533A
        LD      A,(HL)
        CP      B
        JR      NZ,J5337
        EX      DE,HL
        LD      A,C
        POP     DE
        POP     BC
        CP      "Z"+1                   ; end of normal tokenlist ?
        JR      NZ,J5350                ; nope,
J534E:  LD      A,(HL)                  ; single char token
        INC     HL
J5350:  LD      E,A
        AND     7FH
        LD      (BC),A
        INC     BC
        DEC     D
        JP      Z,PPSWRT		; pop af, ret
        OR      E
        JP      P,J534E
        POP     HL
        JP      J5293

;       Subroutine      decode numeric tokens
;       Inputs          ________________________
;       Outputs         ________________________

J5361:  DEC     HL
        _RST    CHRGTR                  ; get numeric token
        PUSH    DE
        PUSH    BC
        PUSH    AF
        CALL    C46E8                   ; get numeric constant
        POP     AF
        LD      BC,I537E
        PUSH    BC
        CP      0BH
        JP      Z,FOUTO                 ; convert integer to octal text
        CP      0CH
        JP      Z,FOUTH                 ; convert integer to hexadecimal text
        LD      HL,(CONLO)
        JP      FOUT                    ; convert DAC to text, unformatted

I537E:  POP     BC
        POP     DE
        LD      A,(CONSAV)
        LD      E,"O"
        CP      0BH                     ; octal constant ?
        JR      Z,J538F                 ; yep, &O
        CP      0CH                     ; hexadecimal constant ?
        LD      E,"H"
        JR      NZ,J539A                ; nope, skip &x
J538F:  LD      A,"&"
        LD      (BC),A
        INC     BC
        DEC     D
        RET     Z
        LD      A,E
        LD      (BC),A
        INC     BC
        DEC     D
        RET     Z
J539A:  LD      A,(CONTYP)
        CP      4                       ; single real ?
        LD      E,0
        JR      C,J53A9                 ; integer, 
        LD      E,"!"
        JR      Z,J53A9                 ; single real,
        LD      E,"#"                   ; double real
J53A9:  LD      A,(HL)
        CP      " "
        JR      NZ,J53AF

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C53AE:  INC     HL
J53AF:  LD      A,(HL)
        INC     HL
        OR      A
        JR      Z,J53D4
        LD      (BC),A

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C53B5:  INC     BC
        DEC     D
        RET     Z
        LD      A,(CONTYP)
        CP      4
        JR      C,J53AF
        DEC     BC
        LD      A,(BC)
        INC     BC
        JR      NZ,J53C8
        CP      "."
        JR      Z,J53D0
J53C8:  CP      "D"
        JR      Z,J53D0
        CP      "E"
        JR      NZ,J53AF
J53D0:  LD      E,00H
        JR      J53AF

J53D4:  LD      A,E
        OR      A
        JR      Z,J53DC
        LD      (BC),A
        INC     BC
        DEC     D
        RET     Z
J53DC:  LD      HL,(CONTXT)
        JP      J5293

;       Subroutine      DELETE statement
;       Inputs          ________________________
;       Outputs         ________________________

DELETE:
C53E2:  CALL    C4279                   ; evaluate linenumber (range) and search start linenumber
        PUSH    BC
        CALL    DEPTR                   ; convert to linepointers to linenumbers if needed
        POP     BC
        POP     DE
        PUSH    BC
        PUSH    BC
        CALL    FNDLIN                  ; search linenumber from start of program (end linenumber)
        JR      NC,J53F7                ; no exact match found, illegal function call
        LD      D,H
        LD      E,L
        EX      (SP),HL
        PUSH    HL
        _RST    DCOMPR
J53F7:  JP      NC,FCERR                ; illegal function call
        LD      HL,REDDY
        CALL    STROUT                  ; message to interpreter output
        POP     BC
        LD      HL,FINI
        EX      (SP),HL

;       Subroutine      remove line(s)
;       Inputs          HL = start of BASIC text that follows, BC = start of deleted BASIC text
;       Outputs         ________________________

C5405:  EX      DE,HL
        LD      HL,(VARTAB)
J5409:  LD      A,(DE)
        LD      (BC),A
        INC     BC
        INC     DE
        _RST    DCOMPR
        JR      NZ,J5409
        LD      H,B
        LD      L,C
        LD      (VARTAB),HL             ; start variable area
        LD      (ARYTAB),HL             ; start arrayvariable area = start variable area (no variables)
        LD      (STREND),HL             ; start free area = start variable area (no arrayvariables)
        RET

;       Subroutine      PEEK function
;       Inputs          ________________________
;       Outputs         ________________________

PEEK:
C541C:  CALL    FRQINT                  ; convert address to integer
        LD      A,(HL)
        JP      SNGFLT                  ; byte to DAC

;       Subroutine      POKE statement
;       Inputs          ________________________
;       Outputs         ________________________

POKE:
C5423:  CALL    GETUIN                  ; evaluate address operand
        PUSH    DE
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    GETBYT                  ; evaluate byte operand
        POP     DE
        LD      (DE),A
        RET

;       Subroutine      evaluate address operand
;       Inputs          ________________________
;       Outputs         ________________________

GETUIN:
C542F:  CALL    FRMEVL                  ; evaluate expression
        PUSH    HL
        CALL    FRQINT                  ; convert address to integer
        EX      DE,HL
        POP     HL
        RET

;       Subroutine      convert address to integer
;       Inputs          ________________________
;       Outputs         ________________________

FRQINT:
C5439:  LD      BC,FRCINT
        PUSH    BC                      ; convert DAC to integer
        _RST    GETYPR
        RET     M                       ; already a integer, quit
        CALL    H.FRQI
        CALL    SIGN                    ; get sign DAC
        RET     M                       ; DAC is negative, just convert
        CALL    FRCSNG                  ; convert DAC to single real
        LD      BC,03245H
        LD      DE,08076H               ; 32768
        CALL    FCOMP                   ; single real compare
        RET     C                       ; smaller as 32768, just convert
        LD      BC,06545H
        LD      DE,06053H               ; 65536
        CALL    FCOMP                   ; single real compare
        JP      NC,OVERR                ; bigger as 65535, overflow error
        LD      BC,065C5H
        LD      DE,06053H               ; -65536
        JP      SGNADD                  ; single real addition

;       Subroutine      RENUM statement
;       Inputs          ________________________
;       Outputs         ________________________

RESEQ:
C5468:  LD      BC,10			; new linenumber default = 10
        PUSH    BC			; step default = 10
        LD      D,B
        LD      E,B			; starting linenumber of renum default = 0 (start of program)
        JR      Z,J5496			; end of statement, start renum with default
        CP      ","
        JR      Z,J547D			; new linenumber not specified, use default
        PUSH    DE
        CALL    LINSPC                  ; collect linenumber (with DOT supported)
        LD      B,D
        LD      C,E			; new linenumber
        POP     DE
        JR      Z,J5496			; end of statement, start renum
J547D:  _RST    SYNCHR
        DEFB    ","                     ; check for ,
        CALL    LINSPC                  ; collect linenumber (with DOT supported)
        JR      Z,J5496			; end of statement, start renum
        POP     AF
        _RST    SYNCHR
        DEFB    ","                     ; check for ,
        PUSH    DE
        CALL    LINGET                  ; collect linenumber (step)
        JP      NZ,SNERR                ; not end of statement, syntax error
        LD      A,D
        OR      E			; step is 0 ?
        JP      Z,FCERR                 ; yep, illegal function call
        EX      DE,HL
        EX      (SP),HL
        EX      DE,HL			; update step value

J5496:  PUSH    BC
        CALL    FNDLIN                  ; search linenumber (starting of renum) from start of program
        POP     DE
        PUSH    DE
        PUSH    BC			; save line pointer
        CALL    FNDLIN                  ; search linenumber (new) from start of program
        LD      H,B
        LD      L,C
        POP     DE
        _RST    DCOMPR
        EX      DE,HL
        JP      C,FCERR                 ; illegal function call
        POP     DE
        POP     BC
        POP     AF
        PUSH    HL
        PUSH    DE
        JR      J54BD

J54AF:  ADD     HL,BC
        JP      C,FCERR                 ; illegal function call
        EX      DE,HL
        PUSH    HL
        LD      HL,0FFF9H
        _RST    DCOMPR
        POP     HL
        JP      C,FCERR                 ; illegal function call
J54BD:  PUSH    DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      A,D
        OR      E
        EX      DE,HL

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C54C4:  POP     DE
        JR      Z,J54CE
        LD      A,(HL)
        INC     HL
        OR      (HL)
        DEC     HL
        EX      DE,HL
        JR      NZ,J54AF
J54CE:  PUSH    BC
        CALL    SCCLIN                  ; convert linenumbers to pointers
        POP     BC
        POP     DE
        POP     HL
J54D5:  PUSH    DE
        LD      E,(HL)
        INC     HL
        LD      D,(HL)
        LD      A,D
        OR      E
        JR      Z,SCCALL
        EX      DE,HL
        EX      (SP),HL
        EX      DE,HL
        INC     HL
        LD      (HL),E
        INC     HL
        LD      (HL),D
        EX      DE,HL
        ADD     HL,BC
        EX      DE,HL
        POP     HL
        JR      J54D5

;       Subroutine      convert to linepointers to linenumbers if needed
;       Inputs          ________________________
;       Outputs         ________________________

DEPTR:
C54EA:  LD      A,(PTRFLG)
        OR      A
        RET     Z
        JR      SCCPTR                  ; convert pointers to linenumbers

SCCALL:
J54F1:  LD      BC,STPRDY
        PUSH    BC                      ; ok and mainloop (+POP)
        DEFB    0FEH                    ; CP xx, skip to J54F7

;       Subroutine      convert linenumbers to pointers
;       Inputs          ________________________
;       Outputs         ________________________

SCCLIN:
C54F6:  DEFB    0F6H                    ; OR xx, skip next instruction, A<>0 (now linepointers)

;       Subroutine      convert pointers to linenumbers
;       Inputs          ________________________
;       Outputs         ________________________

SCCPTR:
J54F7:  XOR     A                       ; now linenumbers
        LD      (PTRFLG),A
        LD      HL,(TXTTAB)
        DEC     HL
J54FF:  INC     HL
        LD      A,(HL)
        INC     HL
        OR      (HL)                    ; endpointer ?
        RET     Z                       ; yep, quit
        INC     HL
        LD      E,(HL)
        INC     HL
        LD      D,(HL)                  ; linenumber
J5508:  _RST    CHRGTR                  ; get next BASIC character
J5509:  OR      A                       ; end of line ?
        JR      Z,J54FF                 ; yep, next line
        LD      C,A
        LD      A,(PTRFLG)
        OR      A                       ; convert to linenumbers ?
        LD      A,C
        JR      Z,J556A                 ; yep, handle
        CALL    H.SCNE
        CP      0A6H                    ; ERROR token ?
        JR      NZ,J552F                ; nope,
        _RST    CHRGTR                  ; get next BASIC character
        CP      89H                     ; GOTO token ?
        JR      NZ,J5509                ; nope,
        _RST    CHRGTR                  ; get next BASIC character
        CP      0EH                     ; linenumber token ?
        JR      NZ,J5509                ; nope,
        PUSH    DE
        CALL    C4771                   ; get linenumber
        LD      A,D
        OR      E                       ; linenumber 0 ?
        JR      NZ,J5537                ; nope,
        JR      J5556

J552F:  CP      0EH                     ; linenumber token ?
        JR      NZ,J5508                ; nope, next char
        PUSH    DE
        CALL    C4771                   ; get linenumber
J5537:  PUSH    HL
        CALL    FNDLIN                  ; search linenumber from start of program
        DEC     BC
        LD      A,0DH                   ; linepointer token
        JR      C,J557C                 ; found, replace linenumber with pointer
        CALL    CRDONZ                  ; fresh line to interpreter output
        LD      HL,I555A
        PUSH    DE
        CALL    STROUT                  ; message to interpreter output
        POP     HL
        CALL    LINPRT                  ; number to interpreter output
        POP     BC
        POP     HL
        PUSH    HL
        PUSH    BC
        CALL    INPRT                   ; "in" number to interpreter output
I5555:  POP     HL
J5556:  POP     DE
        DEC     HL
J5558:  JR      J5508                   ; next

I555A:  DEFB    "Undefined line ",0

J556A:  CP      0DH                     ; linepointer token ?
        JR      NZ,J5558                ; nope, next
        PUSH    DE
        CALL    C4771                   ; get linepointer
        PUSH    HL
        EX      DE,HL
        INC     HL
        INC     HL
        INC     HL
        LD      C,(HL)
        INC     HL
        LD      B,(HL)                  ; linenumber
        LD      A,0EH                   ; linenumber token
J557C:  LD      HL,I5555
        PUSH    HL
        LD      HL,(CONTXT)

;       Subroutine      __________________________
;       Inputs          ________________________
;       Outputs         ________________________

C5583:  PUSH    HL
        DEC     HL
        LD      (HL),B
        DEC     HL
        LD      (HL),C
        DEC     HL
        LD      (HL),A
        POP     HL
        RET

;       Subroutine      SYNCHR
;       Inputs          ________________________
;       Outputs         ________________________

SYNCHR:
C558C:  LD      A,(HL)			; get BASIC character
        EX      (SP),HL
        CP      (HL)			; same as required ?
        INC     HL
        EX      (SP),HL
        JP      NZ,SNERR                ; nope, quit with syntax error
        JP      CHRGTR                  ; get next BASIC character

;       Subroutine      GETYPR
;       Inputs          ________________________
;       Outputs         ________________________

GETYPR:
C5597:  LD      A,(VALTYP)
        CP      8
        JR      NC,J55A3
        SUB     3
        OR      A
        SCF
        RET

J55A3:  SUB     3
        OR      A
        RET

; END	SUBTTL	BINTRP

        END

